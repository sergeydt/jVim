*usr_30.txt*	Для Vim version 6.3.  Последнее изменение: 2004 Jan 17

		РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ VIM - Брам Мооленаар

			   Редактирование программ


В Vim имеется несколько встроенных команд, которые сильно облегчают жизнь
программиста. Вы можете компилировать программу, не выходя из редактора, и
перемещаться по списку обнаруженных в коде ошибок. Вы также можете настроить
автоматическое форматирование отступов для многих языков программирования и
форматировать комментарии в тексте программ.

|30.1|	Компиляция
|30.2|	Отступы в файлах C
|30.3|	Автоматические отступы
|30.4|	Другие виды форматирования отступов
|30.5|	Пробелы и табуляция
|30.6|	Форматирование комментариев

 Следующая глава: |usr_31.txt|  Работа с графическим интерфейсом
Предыдущая глава: |usr_29.txt|	Перемещение в программном коде
      Содержание: |usr_toc.txt|

==============================================================================
*30.1*	Компиляция

В редакторе Vim есть целый набор команд быстрого исправления кода программы.
Эти команды позволяют компилировать программу прямо из Vim с последующим
исправлением ошибок, которые проявились в процессе компиляции. После
исправления ошибок вы можете попытаться снова скомпилировать программу и, если
потребуется, вновь исправить возникшие ошибки. Цикл повторяется до тех пор,
пока программа не будет компилироваться без ошибок. 

Следующая команда запускает программу "make" с любыми приведёнными в командной
строке аргументами, и затем "подхватывает" результат её выполнения: >

	:make {аргументы}

Если в процессе выполнения этой программы были выявлены какие-либо ошибки, то
редактор поймёт это и поместит курсор в том месте, где была допущена первая
ошибка.
   Посмотрите на пример сеанса работы с командой ":make". (Обычно команда
:make выдаёт гораздо больше ошибок, и не таких дурацких, как в этом примере).
После набора команды ":make" экран выглядит примерно так:

	:!make | &tee /tmp/vim215953.err ~
	gcc -g -Wall -o prog main.c sub.c ~
	main.c: In function 'main': ~
	main.c:6: too many arguments to function 'do_sub' ~
	main.c: At top level: ~
	main.c:10: parse error before '}' ~
	make: *** [prog] Error 1 ~

	2 returned ~
	"main.c" 11L, 111C ~
	(3 of 6): too many arguments to function 'do_sub' ~
	Для продолжения нажмите ENTER или наберите команду ~

Из вывода этой команды видно, что у вас есть ошибки в файле "main.c". После
нажатия <Enter>, Vim покажет файл "main.c", и поместит курсор на строку 6, где
произошла первая ошибка. Vim сделает это без вашего вмешательства, опираясь на
информацию, полученную из вывода команды ":make".

		+---------------------------------------------------+
		|int main()					    |
		|{						    |
		|	int i=3;				    |
      cursor -> |	do_sub("foo");				    |
		|	++i;					    |
		|	return (0);				    |
		|}						    |
		|}						    |
		| ~						    |
		|(3 of 12): too many arguments to function 'do_sub' |
		+---------------------------------------------------+

Для перехода к позиции, где возникла следующая ошибка, пользуйтесь командой >

	:cnext

Vim переходит к строке 10, последней в файле, где вставлена лишняя скобка '}'.
   Vim будет сокращать сообщения об ошибках, если ему не хватает места для
вывода строки. Чтобы посмотреть сообщение целиком, используйте команду: >

	:cc

Посмотреть список ошибок можно по команде ":clist". Её вывод выглядит примерно
так: >

	:clist
<	3 main.c: 6:too many arguments to function 'do_sub' ~
	5 main.c: 10:parse error before '}' ~

В списке приводятся только те ошибки, для которых Vim определил положение
ошибки в тексте программы. Vim предполагает, что именно эти сообщения
представляют интерес. Но что если вы хотите посмотреть на все сообщения: на
вывод сборщика относительно неопределённой функции, например? Чтобы посмотреть
все сообщения, добавьте к команде "!": >

	:clist!
<	1 gcc -g -Wall -o prog main.c sub.c ~
	2 main.c: In function 'main': ~
	3 main.c:6: too many arguments to function 'do_sub' ~
	4 main.c: At top level: ~
	5 main.c:10: parse error before '}' ~
	6 make: *** [prog] Error 1 ~

Текущая ошибка в списке будет выделена. Для перехода к предыдущей ошибке,
используйте: >
>
	:cprevious

Другие команды, которые позволяют перемещаться в списке ошибок:

	:cfirst		to first error
	:clast		to last error
	:cc 3		to error nr 3


ИСПОЛЬЗОВАНИЕ ДРУГОГО КОМПИЛЯТОРА

Имя программы, которая запускается при работе команды ":make", определяется
опцией 'makeprg'. Обычно это "make", но пользователи Visual C++, возможно,
захотят использовать "nmake". Это можно сделать при помощи команды: >

	:set makeprg=nmake

В этой опции также могут быть включены и аргументы. Спецсимволы должны при
этом вводиться с обратной косой чертой. Пример: >

	:set makeprg=nmake\ -f\ project.mak

В команде также могут быть использованы специальные определения Vim . Одно из
таких спецопределений -- символ %, который при выполнении будет заменён на имя
текущего файла. Так что, если вы выполните команду >
	
	:set makeprg=make\ %

во время редактирования main.c, то ":make" фактически будет выполняться как: >

	make main.c

Это не так полезно, поэтому мы немного усовершенствуем команду,
воспользовавшись модификатором :r (корень имени, root): >

	:set makeprg=make\ %:r.o

Теперь команда будет выполняться как >

	make main.o

Подробнее о таких модификаторах читайте здесь: |имя_файла-модификаторы|.


СТАРЫЕ СПИСКИ ОШИБОК

Предположим, вы выполняете команду ":make". В одном из файлов вы видите
предупреждение, а в другом файле -- сообщение об ошибке. Вы исправляете ошибку
и запускаете ":make" снова, чтобы проверить -- была ли исправлена ошибка.
Теперь вы хотите посмотреть на предупреждение, но поскольку файл, в котором
возникло предупреждающее сообщение, не был заново скомпилирован, то в
последнем списке ошибок предупреждений нет. Чтобы переключиться на более
старый список ошибок, используйте команду: >

	:colder

После этого пользуйтесь командами ":clist" и ":cc {номер}" для перехода к
месту предупреждения.
   Чтобы перейти к более свежему списку ошибок, пользуйтесь командой: >

	:cnewer

Vim хранит в памяти 10 списков ошибок.


ПЕРЕКЛЮЧЕНИЕ МЕЖДУ КОМПИЛЯТОРАМИ

Вам нужно сообщить редактору, в каком формате выводятся сообщения об ошибках в
вашем компиляторе. Это делается с помощью опции 'errorformat'. Синтаксис,
используемый при задании значения этой опции, довольно сложный, но с его
помощью можно описать сообщения об ошибках, выдаваемые практически любым
компилятором. Подробное объяснение можно найти здесь: |формат_ошибок|.

Возможно, вы пользуетесь различными компиляторами. Установка значения опции
'makeprg' и, особенно, значения опции 'errorformat' каждый раз, когда вы
меняете компилятор -- дело хлопотное. Vim предлагает простой способ решения
этой проблемы. Например, чтобы переключиться к использованию компилятора
Microsoft Visual C++: >

	:compiler msvc

Эта команда заставит Vim найти сценария для компилятора "msvc" и установить
необходимые опции в соответствии с ним.
   Вы можете написать собственные определения для различных компиляторов. См.
|создание_модулей_для_компиляторов|.


ПЕРЕНАПРАВЛЕНИЕ ВЫВОДА

Команда ":make" перенаправляет вывод выполняемой программы в файл с ошибками.
Точный механизм зависит от нескольких вещей, например, от значения опции
'shell'. Если команда ":make" по каким-либо причинам не подхватывает вывод
ошибок компилятора, то проверьте значения опций 'makeef' и 'shellpipe'. Кроме
того, своё влияние могут оказывать и опции 'shellquote' и 'shellxquote'.

Если вы никак не можете заставить команду ":make" перенаправлять вывод в
необходимый файл, то можно компилировать программу в другом окне с
перенаправлением вывода в файл. Чтобы Vim прочитал этот файл, дайте ему
команду: >

	:cfile {имя_файла}

Прыжки к различным ошибкам будут работать так, как будто вы использовали
команду ":make".

==============================================================================
*30.2*	Отступы в файлах C

Понимать программу гораздо проще, если в строках соблюдаются правильные
отступы. Vim предлагает несколько способов автоматизировать этот процесс.
   Для программ на языке C включите опцию 'cindent'. Vim знает о программах на
языке C достаточно, чтобы стараться как можно грамотнее расставлять требуемые
отступы автоматически. Ширину отступа задавайте при помощи опции 'shiftwidth'.
Отлично работает значение, равное 4. Всё это можно выполнить одной командой
:set": >

	:set cindent shiftwidth=4

С включённой опцией 'cindent' при наборе выражения вроде "if (x)", следующая
строка будет автоматически оформлена с дополнительным отступом. 

					    if (flag)
	Автоматический отступ	      --->	do_the_work();
	Автоматический меньший отступ <--   if (other_flag) {
	Автоматический отступ         --->	do_file();
	Сохранение отступа		        do_some_more();
	Автоматический меньший отступ <--   }

При наборе текста в фигурных скобках, отступы будут добавлены в начале блока,
и уменьшены в конце. Уменьшение отступов произойдёт после набора '}',
поскольку Vim не владеет телепатией, чтобы угадать, что вы хотите напечатать.

Побочный эффект использования автоматических отступов состоит в более раннем
обнаружении ошибок в коде. Если при наборе } вы обнаруживаете, что
автоматические отступы для этой строки больше, чем ожидалось, то скорее всего
где-то пропущена }. Используйте команду "%" для поиска соответствия {
набранной }.
   Лишние отступы также могут быть вызваны пропущенными символами ) и ;. Так
что если вы видите в строке больше отступ, чем ожидалось, проверьте предыдущие
строки кода.

Если у вас есть код, который неправильно отформатирован, либо вы вставляли и
удаляли строки кода, вам потребуется переформатировать отступы в строках. Для
этого используется оператор "=". Самая простая форма этой команды: >

	==

Это приводит к форматированию отступов в текущей строке. Как и у любого
другого оператора, команду "=" можно использовать тремя способами. В
Визуальном режиме "=" оформляет отступы у выделенных строк. Полезным для
такого рода форматирования является текстовый объект "a{", который выделяет
текущий блок {}. Таким образом, для оформления отступов в блоке, в котором
размещён курсор, пользуйтесь командой >

	=a{

Если код совсем никак толком не отформатирован, то можно пользоваться командой 
>
	gg=G

Тем не менее, не стоит применять эту команду в файлах, в которых строки были
тщательно отформатированы вручную. Автоматическое форматирование отступов
работает на ура, но в некоторых ситуациях вам может понадобиться поправить
отступы вручную.


НАСТРОЙКА СТИЛЯ ОТСТУПОВ

Разные люди привыкли к разному стилю отступов. По умолчанию Vim работает очень
даже неплохо, используя стиль, к которому привыкло 90% программистов. В то же
время, существует несколько стилей. При желании вы можете настроить стиль по
своему вкусу при помощи опции 'cinoptions'.
   По умолчанию значение опции 'cinoptions' не установлено и Vim использует
стиль по умолчанию. Если вы хотите как то изменить стиль по умолчанию, то вам
потребуется добавить элементы, в которых стиль будет меняться, к значению
опции. Например, чтобы помещать фигурные скобки таким образом:

	if (flag) ~
	  { ~
	    i = 8; ~
	    j = 0; ~
	  } ~

используйте команду >

	:set cinoptions+={2

Элементов для настройки отступов существует довольно много. Подробнее смотрите
в |cinoptions-значения|.

==============================================================================
*30.3*	Автоматические отступы

Чтобы не включать опцию 'cindent' вручную каждый раз, когда вы редактируете
файл на языке C, можно заставить эту операцию выполняться автоматически: >

	:filetype indent on

На самом деле, эта команда делает несколько большее, чем включает опцию
'cindent' для файлов C. Прежде всего, она позволяет определять тип файла,
аналогично тому, как определяется тип файла для подсветки синтаксиса.
   Когда тип файла известен, то Vim попытается найти файл сценария отступов
для данного типа файлов. В поставку Vim включён целый комплект таких сценариев
для различных языков. Файл сценария позволит Vim подготовиться к
автоматическому форматированию отступов с использованием правил, свойственных
для данного типа файлов.

Если вы не хотите пользоваться автоматическим форматированием отступов, то
можно выключить его при помощи команды >

	:filetype indent off

Если вам нужно отключить форматирование отступов только для одного типа
файлов, то добиться этого можно следующим образом. Создайте файл со строкой: >

	:let b:did_indent = 1

Теперь запишите этот файл с необходимым именем:

	{каталог}/indent/{тип-файла}.vim

{тип-файла} это имя типа файла, например "cpp" или "java". Чтобы посмотреть
точное имя типа файла, которое определяет Vim, пользуйтесь командой >

	:set filetype

Например, в данном файле вывод должен быть:

	filetype=help ~

В таком случае вы можете использовать для {тип-файла} "help".
   В качестве {каталога} необходимо указать рабочий каталог Vim. Посмотрите на
вывод команды >

	:set runtimepath

Используйте первый путь, указанный до запятой. Если вывод выглядит так:

	runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~

то в качестве {каталога} надо использовать "~/.vim". Таким образом, имя файла
в нашем случае должно быть 

	~/.vim/indent/help.vim ~

Вместо того, чтобы выключать автоматическое форматирование отступов, вы можете
написать собственный файл отступов. Подробно о том, как это сделать,
рассказывается в |отступы-выражения|.

==============================================================================
*30.4*	Другие виды форматирования отступов

Самая простая форма автоматических отступов -- использование опции
'autoindent'. Если эта опция включена, то используется такой же отступ, как и
в предыдущей строке. Несколько более интеллектуальная опция -- 'smartindent',
которая может применяться с языками, для которых нет файла с правилами
отступов. Опция 'smartindent' не настолько умна, как опция 'cindent', но умнее
чем 'autoindent'.
   Включённая опция 'smartindent' позволяет добавлять дополнительный уровень
отступов с каждым набранным символом { (и уменьшать уровень отступов с каждым
набранным }). Дополнительный уровень отступа также задаётся для каждого слова
из перечисленных в значении опции 'cinwords'. Строки, которые начинаются с #,
рассматриваются отдельно -- в них убираются любые отступы. Это сделано для
того, чтобы все директивы препроцессора начинались в колонке 1. В последующих
строках требуемый уровень отступов восстанавливается. 


ИСПРАВЛЕНИЕ ОТСТУПОВ

При использовании опций 'autoindent' или 'smartindent' часто возможны
ситуации, когда вам требуется добавить или удалить величину отступа на
значение 'shiftwidth'. В режиме вставки это быстрее всего можно сделать с
помощью команд CTRL-D и CTRL-T.
   Например, представьте, что вы редактируете сценарий оболочки, который
должен выглядеть следующим образом:

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	fi ~

Начните с установки опций: >

	:set autoindent shiftwidth=3

Теперь, после набора первой строки и ввода <Enter>, начните ввод второй
строки:

	if test -n a; then ~
	echo ~

Поскольку вам требуется добавить отступ, то нажмите CTRL-T. Результат:

	if test -n a; then ~
	   echo ~

Команда CTRL-T в режиме Вставки всегда добавляет величину 'shiftwidth' к
отступам в строке, независимо от того, где в строке вы находитесь.
   Закончив набор второй строки, перейдите к набору третьей строки с помощью
<Enter>. На этот раз с отступами всё в порядке. Нажмите <Enter> и перейдите к
набору последней строки. У вас будет лишний отступ:

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	   fi ~

Чтобы удалить отступ в последней строке, нажмите CTRL-D. Эта команда удаляет
из отступа строки величину 'shiftwidth', независимо от того, где в строке вы
находитесь.
   В Обычном режиме для увеличения и уменьшения отступов строк можно
пользоваться командами ">>" и "<<". Команды ">" и "<" являются операторами,
поэтому вы можете использовать любой из трёх доступных способов указания
строк, в которых следует изменить отступ. Полезный текстовый объект для
использования с этими командами -- i{: >

	>i{

Эта команда позволяет добавить отступ в текущем блоке строк внутри {}. Сами
строки с { и } останутся без изменений. Команда ">a{" выполнит также и
изменение отступа в строках, содержащих { и }. В приведённом ниже примере
курсор находится на слове "printf":

	изначальный текст	после ">i{"		после ">a{"

	if (flag)		if (flag)		if (flag) ~
	{			{			    { ~
	printf("yes");		    printf("yes");	    printf("yes"); ~
	flag = 0;		    flag = 0;		    flag = 0;  ~
	}			}			    } ~

==============================================================================
*30.5*	Пробелы и табуляция

По умолчанию, значение опции 'tabstop' равно восьми символам. Хотя вы можете
изменить это значение, позднее вы скорее всего столкнётесь с проблемами.
Другие программы не могут знать о том, сколько пробелов вы использовали для
табуляции в Vim. Они будут пользоваться стандартным значением, равным восьми
символам, и ваш текст будет выглядеть совершенно иначе. Кроме того, значение
по умолчанию (8) также используется в большинстве принтеров. Так что лучше
всего оставить опцию 'tabstop' в покое. (Если вы редактируете файл, который
был написан с использованием другого значения табуляции, то читайте, как это
можно исправить, в |25.3|.)
   С другой стороны, при написании программ с использованием отступов для
форматирования, значения ширины отступов, кратные восьми, быстро приведут вас
к правой границе экрана. Использование одиночного пробела не производит
достаточного эффекта. Многие люди используют компромиссное значение, равное
четырём пробелам.
   Поскольку <Tab> равен восьми пробелам, а вам нужно использование четырёх
пробелов, то вы не сможете пользоваться для ввода отступов символом <Tab>.
Чтобы исправить ситуацию, возможны два выхода:

1. Используйте совместно <Tab> и пробелы. Поскольку <Tab> заменяет собой
   восемь символов, то в вашем файле будет меньше символов. Вставка <Tab>
   гораздо быстрее, чем вставка восьми пробелов, кроме того, быстрее работает
   и забой символа слева от курсора.

2. Используйте только пробелы. Это позволяет избежать проблем с программами,
   которые используют отличное значение для табуляции.

К счастью, Vim отлично поддерживает оба способа.


ПРОБЕЛЫ И ТАБУЛЯЦИЯ

При использовании комбинации пробелов и табуляции, вы редактируете файл в
обычном порядке. Vim сам знает чем пользоваться в каждой ситуации по
умолчанию.
   Установив опцию 'softtabstop' в нужное значение вы можете значительно
облегчить себе жизнь. Эта опция заставляет Vim использовать кнопку <Tab> как
будто табуляция была установлена в значение, равное значению этой опции, но на
самом деле при этом используется комбинация пробелов и символов табуляции.
   После выполнения приведённой ниже команды каждое нажатие на кнопку <Tab>
перемещает курсор в начало следующей области из четырёх колонок: >

	:set softtabstop=4

При нажатии <Tab> в первой колонке, в текст будет вставлено 4 пробела. При
следующем нажатии, Vim удаляет эти 4 пробела и помещает символ <Tab>,
перемещая курсор в девятую колонку. Vim использует столько символов <Tab>,
сколько можно, и дополняет остаток необходимым количеством пробелов. 
   При использовании кнопки <BS>, всё происходит в обратном порядке. <BS>
всегда удаляет количество пробелов, указанное в значении опции 'softtabstop'.
После этого, для заполнения пустоты используется необходимое количество <Tab>
с дополнением пробелами.
   Приведём пример, иллюстрирующий, что происходит, когда вы нажимаете <Tab>
несколько раз, и затем пользуетесь кнопкой <BS>. Пробелы отмечены ".", а <Tab>
выглядит на нашей схеме как "------->".

	ввод			  результат ~
	<Tab>			  ....
	<Tab><Tab>		  ------->
	<Tab><Tab><Tab>		  ------->....
	<Tab><Tab><Tab><BS>	  ------->
	<Tab><Tab><Tab><BS><BS>   ....

Также можно использовать опцию 'smarttab'. Если она включена, то Vim
использует 'shiftwidth' для задания ширины отступа при наборе <Tab> в начале
строки, однако после первого непробельного символа в строке применяется
настоящий <Tab>. Однако, в этом случае <BS> будет работать иначе.


ТОЛЬКО ПРОБЕЛЫ

Если вы хотите полностью отказаться от использования символов табуляции в
тексте, то можно включить опцию 'expandtab': >

	:set expandtab

При включённой опции 'expandtab' нажатие на кнопку <Tab> приводит к вставке
серии пробелов. Таким образом, внешне это выглядит так, как если бы вы
вставили настоящий символ <Tab>, между тем, как в файле будут использоваться
только пробелы.
   Кнопка <BS> будет удалять вставленные пробелы по одному. Таким образом,
после нажатия <Tab>, для отмены придётся нажимать <BS> восемь раз. Если речь
идёт об отступе в строке, то гораздо быстрее выполнить это с помощью CTRL-D.


ЗАМЕНА ТАБУЛЯЦИИ НА ПРОБЕЛЫ (И ОБРАТНО)

Включение опции 'expandtab' никак не задевает существующие пробелы. Другими
словами, все символы табуляции в документе остаются символами табуляции. Если
вам нужно превратить их в набор пробелов, то используйте команду ":retab".
Например: >

	:set expandtab
	:%retab

Теперь Vim изменит все отступы с использованием пробелов вместо табуляции.
Однако, все символы табуляции, которые встречаются после непробельного
символа, будут сохранены. Если вам необходимо заменить и их, то добавьте !: >

	:%retab!

Это немного опасная операция, поскольку она может также задеть символы
табуляции внутри строковой константы. Чтобы проверить, если такое возможно,
используйте команду поиска >

	/"[^"\t]*\t[^"]*"

Рекомендуется внутри строковой константы использовать метасимволы табуляции.
Во избежание проблем, замените их на "\t".

Вы можете также выполнить и обратное преобразование: >

	:set noexpandtab
	:%retab!

==============================================================================
*30.6*	Форматирование комментариев

Одна из классных особенностей Vim состоит в том, что он понимает комментарии.
Если вы попросите Vim отформатировать комментарий в программе, то он всё
сделает правильно.
   Предположим, у вас имеется такой комментарий:

	/* ~
	 * Это тест ~
	 * форматирования текста. ~
	 */ ~

Вы помещаете курсор в начале комментария и вводите команду >

	gq]/

"gq" это оператор форматирования текста, а "]/" это перемещение, которое
переносит курсор в конец комментария. Результат выглядит так:

	/* ~
	 * Это тест форматирования текста. ~
	 */ ~

Обратите внимание, что Vim корректно работает с началом каждой строки.
   Вы можете также выбрать текст комментария в Визуальном режиме и набрать
"gq".

Чтобы добавить в комментарий новую строку, поместите курсор на среднюю строку
и нажмите "o". Результат выглядит так:

	/* ~
	 * Это тест форматирования текста. ~
	 * ~
	 */ ~
	
Vim автоматически вставляет в открытой строке звёздочку и пробел. Теперь вы
можете набрать необходимый текст. Если он будет длиннее, чем значение опции
'textwidth', то Vim перенесёт строку с автоматической вставкой звёздочки в
необходимом месте:

	/* ~
	 * Это тест форматирования текста. ~
	 * Набор длинного текста приведёт к тому, что Vim ~
	 * автоматически перенесёт~
	 */ ~

Чтобы эта особенность работала правильно, нужно установить некоторые флаги в
опции 'formatoptions':

	r	вставлять звёздочку при нажатии <Enter> в режиме Вставки
	o	вставлять звёздочку при использовании "o" или "O" в Обычном
	           режиме
	c	переносить текст комментария в соответствии со значением опции
	           'textwidth'

Подробнее о флагах смотрите в |fo-таблица|.


ОПРЕДЕЛЕНИЕ КОММЕНТАРИЯ

Вид комментариев определяется опцией 'comments'. Vim различает однострочные
комментарии и комментарии, состоящие из различных частей.
   Однострочные комментарии, как правило, начинаются с определённого символа.
В C++ используется //, в Makefiles #, в сценариях Vim ". Например, чтобы Vim
понимал комментарии C++: >

	:set comments=://

Двоеточие отделяет флаг элемента от текста, по которому распознаётся
комментарий. Общий синтаксис элемента опции 'comments':

	{флаги}:{текст}

{флаги}, как это было в данном случае, могут отсутствовать.
   В опции можно задавать несколько элементов, разделяя их запятыми. Это
позволяет одновременно различать разные типы комментариев. Например, при
редактировании письма, текст, который написан другими, обычно оформлен с
помощью символов ">" или "!". В этом случае можно использовать команду >

	:set comments=n:>,n:!

Здесь два элемента, один для комментариев, начинающихся с ">", другой для
комментариев, начинающихся с "!". Оба элемента используют флаг "n". Это
указывает на то, что оба комментария могут быть вложенными. Строка, которая
начинается с ">", может иметь и другой комментарий, после ">". Это позволяет
форматировать такие сообщения:

	> ! Ты что, не видел сайта? ~
	> ! Очень классно сделан. ~
	> Мне не нравится. Цвета вообще ~
	> ужасные. ~
	А какой у того сайта URL? ~

Попробуйте установить 'textwidth' в другое значение, например 80, и
переформатировать текст, набрав команду "gq" с Визуально выделенным текстом.
Результат выглядит так:

	> ! Ты что, не видел сайта? Очень классно сделан. ~
	> Мне не нравится. Цвета вообще ужасные. ~
	А какой у того сайта URL? ~

Обратите внимание, что Vim не перемешал различные типы комментариев. Слово
"Мне" начинается, как и положено, в отдельной строке, поскольку эта строка
начинается с ">", а предыдущая строка начинается с "> !". Vim знает, что это
разные комментарии.


КОММЕНТАРИЙ ИЗ ТРЁХ ЧАСТЕЙ

Комментарий C начинается с "/*", в середине строка начинается с "*", а в конце
комментария идёт "*/". Определение комментария в опции 'comments' выглядит
так: >

	:set comments=s1:/*,mb:*,ex:*/

Начало комментария определено с помощью "s1:/*". "s" указывает на начало
комментария из трёх частей. Двоеточие отделяет флаг от текста, по которому
распознаётся комментарий: "/*". Флаг "1" указывает на то, что в средней части
используется отступ в один пробел.
   Средняя часть "mb:*" начинается с "m", что указывает на среднюю часть
комментария. Флаг "b" указывает, что после текста должен следовать пробел.
Иначе Vim будет думать, что "*pointer" также является средней частью
комментария. 
   Последняя часть "ex:*/" задаётся с помощью компонента "e". Флаг "x" имеет
особое значение: он указывает на то, что после того, как Vim вставит
звёздочку, ввод / приведёт к удалению лишнего пробела.

Подробнее смотрите |форматирование-комментарии|.

==============================================================================

Следующая глава: |usr_31.txt|  Работа с графическим интерфейсом
Авторские права: см. |авторские_права_на_документацию|  

vim:tw=78:ts=8:ft=help:norl:
