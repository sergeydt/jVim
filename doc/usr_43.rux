*usr_43.txt*	Для Vim version 6.3.  Последнее изменение: 2002 Jul 14

		РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ VIM - Брам Мооленаар

			  Использование типов файлов


При редактировании файла определённого типа, например программы на языке C или
сценария для оболочки, часто приходится использовать одни и те же настройки и
привязки. Устанавливать их каждый раз вручную занятие неблагодарное и
утомительной. В этой главе рассказывается, как делать это автоматически.

|43.1|	Модули для типа файла
|43.2|	Добавление нового типа файла

 Следующая глава: |usr_44.txt|  Собственные правила подсветки синтаксиса
Предыдущая глава: |usr_42.txt|	Добавление новых меню
      Содержание: |usr_toc.txt|

==============================================================================
*43.1*	Модули для типа файла		  *filetype-plugin* *тип_файла-модули*

Как начать использовать модули типов файлов уже подробно обсуждалось нами
здесь: |добавление_модуля_типа_файла|. Однако, настройки по умолчанию, как
правило, сведены к минимуму, поэтому вам наверняка захочется их дополнить
своими. Например, для программ на языке C вам может понадобиться установить
значение опции 'softtabstop' равным 4 и определить привязку, которая вставляет
трёхстрочный комментарий. Этого можно добиться в два шага:

		        *your-runtime-dir* *каталог_для_ваших_файлы_настройки*
1. Создайте свой собственный каталог для файлов настройки. На Unix это обычно
   "~/.vim". В этом каталоге создайте каталог "ftplugin": >

	mkdir ~/.vim
	mkdir ~/.vim/ftplugin
<
   Если ваша система не Unix, то проверьте значение опции 'runtimepath', чтобы
   узнать, где Vim ищет каталог "ftplugin": >

	set runtimepath

<  Как правило, вам нужно использовать самый первый каталог в списке значений
   этой опции (до первой запятой). Если вас не устраивает значение по
   умолчанию, то вы можете добавить имя каталога к опции 'runtimepath' из
   файла |vimrc|.

2. Создайте файл "~/.vim/ftplugin/c.vim" со следующим текстом: >

	setlocal softtabstop=4
	noremap <buffer> <LocalLeader>c o/**************<CR><CR>/<Esc>

Теперь попробуйте редактировать файл C. Вы заметите, что опция 'softtabstop'
теперь имеет значение, равное 4. Однако, при редактировании другого файла, её
значение восстанавливается в 0. Так происходит потому, что вы использовали
команду ":setlocal", которая устанавливает значение опции 'softtabstop' только
для данного буфера. Как только вы начинаете редактирование другого буфера,
значение этой опции будет установлено в принятое для нового буфера, то есть
значение по умолчанию, либо значение, установленное при помощи последней
команды ":set".

Аналогично, привязка для "\c" перестанет работать при редактировании другого
буфера. Команда ":map <buffer>" создаёт привязку, которая является локальной
по отношению к данному буферу. Это работает с любой командой привязки:
":map!", ":vmap" и т.д. Значение |<LocalLeader>| в привязке заменяется на
значение переменной "maplocalleader".

Примеры модулей типа файла можно найти в каталоге: >

	$VIMRUNTIME/ftplugin/

Подробнее о написании модуля типа файла можно прочитать здесь:
|написать_свой_модуль|.

==============================================================================
*43.2*	Добавление нового типа файла

Если вы пользуетесь каким-то особенным типом файла, который не распознаётся
Vim, то читайте о том, как научить Vim вашему новому типу файла. Вам
потребуется собственный каталог для файлов настройки Vim, см. выше:
|каталог_для_ваших_файлы_настройки|.

Создайте файл "filetype.vim", который содержит автокоманду для вашего типа
файла (автокоманды объясняются в разделе |40.3|.) Например: >

	augroup filetypedetect
	au BufNewFile,BufRead *.xyz	setf xyz
	augroup END

Это позволяет распознавать все файлы, которые заканчиваются на ".xyz" как тип
файла "xyz". Команды ":augroup" помещают данную автокоманду в группу
"filetypedetect". Это позволяет удалять все автокоманды для определения типа
файла, когда выполняется ":filetype off". Команда "setf" устанавливает
значение опции 'filetype' равным своему аргументу, если оно ещё не
установлено. Это позволяет убедиться, что 'filetype' не устанавливается
дважды.

Для установления соответствия с именем файла можно пользоваться различными
шаблонами, включая указание каталогов. См. |автокоманды-шаблоны|. Предположим,
если все файлы в каталоге "/usr/share/scripts/" являются сценариями на языке
"ruby", хотя и не имеют требуемого расширения, то к предыдущему примеру
следует добавить: >
	
	augroup filetypedetect
	au BufNewFile,BufRead *.xyz			setf xyz
	au BufNewFile,BufRead /usr/share/scripts/*	setf ruby
	augroup END

Однако, имейте это в виду, что файл /usr/share/scripts/README.txt это не файл
ruby. Опасность использования шаблона, заканчивающегося на "*" состоит в том,
что он соответствует слишком многим файлам. Чтобы избежать этих проблем,
поместите файл filetype.vim в другой каталог, тот который расположен в самом
конце значения 'runtimepath'. Например, для Unix вы можете использовать
"~/.vim/after/filetype.vim".
   В этом случае вы могли бы определять текстовые файлы раньше, в файле
~/.vim/filetype.vim: >

	augroup filetypedetect
	au BufNewFile,BufRead *.txt			setf text
	augroup END

А файлы ruby будут определяться в самом конце, в файле
~/.vim/after/filetype.vim: >

	augroup filetypedetect
	au BufNewFile,BufRead /usr/share/scripts/*	setf ruby
	augroup END

При этом происходит следующее. Vim ищет файл "filetype.vim" в каждом каталоге
в 'runtimepath'. Сначала он находит ~/.vim/filetype.vim. Автокоманда для
текстовых файлов *.txt определена именно в нём. Затем Vim находит файл
filetype.vim в каталоге $VIMRUNTIME. Наконец, Vim находит и
~/.vim/after/filetype.vim и тогда добавляется автокоманда для определения
файлов ruby в /usr/share/scripts.
   При редактировании файла /usr/share/scripts/README.txt автокоманды
проверяются по порядку определения. Поскольку соответствие шаблону *.txt
есть, то выполняется команда "setf text" и устанавливается текстовый тип
файла. Затем выясняется также совпадение шаблону для ruby и выполняется
команда "setf ruby". Но, поскольку в данном случае уже установлен текстовый
тип файла, то ничего не происходит.
   При редактировании файла /usr/share/scripts/foobar выполняются те же самые
автокоманды. Поскольку соответствие существует только для ruby, то команда
"setf ruby" устанавливает значение опции 'filetype' равным ruby.


РАСПОЗНАВАНИЕ ПО СОДЕРЖАНИЮ ФАЙЛА

Если тип файла нельзя распознать по имени файла, то можно попробовать
распознать тип файла по его содержанию! Например, многие файлы сценариев
начинаются со строки, похожей на:

	#!/bin/xyz ~

Для распознавания такого сценария создайте в своём каталоге настроек Vim файл
"scripts.vim" (там же, где и файл filetype.vim). Содержание этого файла может
быть таким: >

	if did_filetype()
	  finish
	endif
	if getline(1) =~ '^#!.*[/\\]xyz\>'
	  setf xyz
	endif

Прежде всего мы вызываем функцию did_filetype(), чтобы избежать повторного
определения типа файла. Это позволяет сократить время проверки файла в том
случае, если команда "setf" всё равно ничего не делает.
   Файл scripts.vim считывается автокомандой в стандартном файле
filetype.vim. Иными словами, порядок проверки такой:

	1. файлы filetype.vim до $VIMRUNTIME в 'runtimepath'
	2. первая часть $VIMRUNTIME/filetype.vim
	3. все файлы scripts.vim в 'runtimepath'
	4. оставшаяся часть $VIMRUNTIME/filetype.vim
	5. файлы filetype.vim после $VIMRUNTIME в 'runtimepath'

Если вам этого недостаточно, то добавьте автокоманду, которая соответствует
всем файлам и считывает сценарий или выполняет функцию, которые проверяют
содержание файла.

==============================================================================

Следующая глава: |usr_44.txt|  Собственные правила подсветки синтаксиса
Авторские права: см. |авторские_права_на_документацию|  

vim:tw=78:ts=8:ft=help:norl:
