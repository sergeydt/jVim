*windows.txt*   Для Vim version 6.3.  Последнее изменение: 2004 Apr 29


		      СПРАВОЧНИК ПО VIM - Брам Мооленаар


                                                 	   *windows* *buffers*
Редактирование в нескольких окнах и буферах.                   *окна* *буферы*

Ниже рассматриваются команды, добавленные в Vim для обеспечения возможности
работы в нескольких окнах и с несколькими буферами. Кроме того, показано как
отличается работа некоторых команд, если они применяются к нескольким окнам.

Основные сведения по работе с окнами содержатся в 7 и 8 главах руководства
пользователя, см. |usr_07.txt| и |usr_08.txt|.

1.  Введение				     |окна-введение|
2.  Запуск Vim				     |окна-запуск|
3.  Открытие и закрытие окон	             |открытие_окна|
4.  Перемещение курсора в другие окна	     |окно-перемещение_курсора|
5.  Перемещение окон по экрану		     |окно-перемещение|
6.  Изменение размеров окна		     |окно-размеры|
7.  Команды для работы со списками           |буферы-список|
    аргументов и буферов         
8.  Выполнение команды во всех буферах	     |повтор_по_списку|
    или окнах
9.  Метки и имена файлов в позиции курсора   |окно-метки|
10. Окно предварительного просмотра	     |окно_предварительного_просмотра|
11. Использование скрытых буферов	     |буферы-скрытые|
12. Буферы специального назначения	     |специальные_буферы|

{Vi не имеет ни одной из рассматриваемых здесь команд}
{использование нескольких окон возможно только в том случае, если особенность
|+windows| была включена при компиляции}
{использование вертикально разделённых окон возможно только в том случае, если
особенность |+vertsplit| была включена при компиляции}

==============================================================================
1. Введение				       *windows-intro* *окна-введение*

Окном в Vim называется вид на буфер. Вы можете использовать как несколько окон
для одного и того же буфера, так и разные окна для разных буферов.

Буфером называется файл, загруженный в память Vim для редактирования. Исходный
файл остаётся в неприкосновенности до тех пор, пока не происходит запись
буфера в файл.

Буфер может находиться в одном из трёх состояний:

				              *active-buffer* *активный_буфер*
active:   Буфер, отображаемый в окне. Если данный буфер связан с файлом, то
	  содержимое файла считывается в буфер. Если содержимое буфера было
	  изменено, то оно будет отличаться от содержимого файла, пока
	  изменения не будут сохранены.

					       *hidden-buffer* *скрытый_буфер*
hidden:   Буфер не отображается на экране. Если данный буфер связан с файлом,
	  то содержимое файла считывается в буфер. Во всех остальных
	  отношениях такой буфер ведёт себя точно так же, как и активный
	  буфер, просто его не видно на экране.
	  
				          *inactive-buffer* *неактивный_буфер*
inactive: Буфер не отображается на экране и не имеет содержания. Опции,
	  заданные для такого буфера, запоминаются при первой загрузке файла.
	  Неактивный буфер может содержать отметки, полученные из файла
	  |viminfo|, но текст такой буфер не содержит.

Обобщая:

состояние	отображается    загружен        ":buffers"  ~
		в окне			        показывает~

active		  да 		 да 		  'a'
hidden		  нет	         да 		  'h'
inactive	  нет		 нет		  ' '

Замечание: Все команды CTRL-W могут также выполняться с помощью команды
|:wincmd|, которая применяется в тех случаях, когда команды Обычного режима не
могут быть использованы или их использование неудобно по каким-либо причинам.

==============================================================================
2. Запуск Vim				      *windows-starting* *окна-запуск*


По умолчанию, при запуске Vim открывается единственное окно, как в Vi.

Аргументы командной строки Vim "-o" и "-O" позволяют открывать при запуске
несколько окон, по одному на каждый файл в списке аргументов. Аргумент "-o"
применяется для горизонтального раскроя окон, а "-O" -- для вертикального.
Если в командной строке запуска указаны оба аргумента, то ориентация раскроя
окон определяется по последнему аргументу. Например, следующая команда
запускает Vim, в котором будет открыто три горизонтальных окна: >

	vim -o file1 file2 file3

При использовании аргумента "-oN", где N это десятичное число, происходит
открытие N разделённых по горизонтали окон. Если в командной строке указано
большее количество файлов, то открывается только N окон и некоторые файлы не
будут иметь окна. Если же окон больше, чем указанных в командной строке
запуска имён файлов, то последние несколько окон будут открыты с пустыми
буферами. Аналогично, аргумент командной строки "-ON" позволяет открывать N
разделённых по вертикали окон, с точно такими же ограничениями, что и при
использовании "-oN".

При открытии слишком большого количества файлов окна могут оказаться слишком
малого размера. Вы можете использовать опции 'winheight' и/или 'winwidth' для
настройки разумных размеров окна.

|автокоманды| Buf/Win Enter/Leave при открытии новых окон и чтении файлов не
выполняются. Их выполнение происходит при действительном переходе в
соответствующий буфер или окно.

				              *status-line* *строка_состояния*
Строка состояния используется для отделения окон друг от друга. Опция
'laststatus' используется для описания ситуаций, в которых последнее окно
может также использовать строку состояния:

	'laststatus' = 0	строка состояния у последнего окна выключена
	'laststatus' = 1	строка состояния у последнего окна включена в
				тех случаях, когда на экране открыто несколько
				окон
	'laststatus' = 2	строка состояния у последнего окна включена
				всегда

Содержимое строки состояния может быть настроено с помощью опции 'statusline'.

Строка состояния обычно отображается в инверсном режиме. Однако, это можно
изменить с помощью флага 's' в значении опции 'highlight'. Например, "sb"
позволяет показывать строку состояния жирным шрифтом. Если подсветка строки
состояния не используется ("sn"), то активное окно помечается символом '^', 
а остальные окна -- символом '='. Если опция 'mouse' включена и поддержка мыши
обеспечивается на вашей системе, строку состояния можно перетаскивать с целью
изменения размеров окна.

Замечание: если строка состояния не отображается в инверсном режиме,
проверьте, не содержится ли в опции 'highlight' содержалось значение "si". В
версии 3.0 такое значение применялось для инверсного режима, но в более
современных версиях для этой цели используется "sr", в то время как "si"
применяется для указания наклонного шрифта! Если наклонный шрифт отсутствует
на вашем терминале, то строка состояния будет отображаться в инверсном режиме
в любом случае; с этой проблемой вы можете столкнуться только на терминалах,
имеющих коды termcap для наклонного шрифта.

==============================================================================
3. Открытие и закрытие окон	        *opening-window* *E36* *открытие_окна*

CTRL-W s						            *CTRL-W_s*
CTRL-W S						            *CTRL-W_S*
CTRL-W CTRL-S						       *CTRL-W_CTRL-S*
:[N]sp[lit] [++опция] [+команда]			        *:sp* *:split*
		Разделить активное окно на два окна. В результате получается
		два окна с видом на один и тот же файл. N указывает на высоту
		окна в строках (по умолчанию: половина высоты активного окна).
		Высота активного окна уменьшается, чтобы появилось место для
		нового окна (если опция 'equalalways' включена, а значение
		опции 'eadirection' не равно "hor", то место для нового окна
		"откусывается" ото всех окон поровну).
                Замечание: CTRL-S не работает на всех терминалах и может
		привести к блокировке последующего ввода. В этом случае
		следует использовать CTRL-Q для продолжения работы.
		См. также |++опция| и |+команда|.

CTRL-W CTRL-V						       *CTRL-W_CTRL-V*
CTRL-W v						            *CTRL-W_v*
:[N]vs[plit] [++опция] [+команда] [файл]		       *:vs* *:vsplit*
		То же, что и |:split|, но с разделением окна по вертикали.
		Если включена опция 'equalalways', а значение опции
		'eadirection' не равно "ver", то окна будут равномерно
		распределены по горизонтали, если, конечно, не задана
		конкретная ширина окна.
                Замечание:  В остальных местах CTRL-Q может использоваться для
		тех же целей, что и CTRL-V, но в данном случае это не так!

CTRL-W n						            *CTRL-W_n*
CTRL-W CTRL_N						       *CTRL-W_CTRL-N*
:[N]new [++опция] [+команда]				                *:new*
		Создать новое окно и перейти к редактированию нового файла в
		этом окне. Высота окна может быть задана с помощью N (по
		умолчанию используется половина высоты активного окна). Место
		для нового окна создаётся за счёт активного окна (или всех
		открытых окон, если включена опция 'equalalways' и значение
		опции 'eadirection' не равно "hor").
		См. также |++опция| и |+команда|.
		При непустом значении опции 'fileformats' в новом буфере
		используется первый указанный в этой опции формат файла. Если
		значение опции 'fileformats' равно пустой строке, то
		используется формат файла активного буфера. Вы можете изменить
		это поведение с помощью параметра |++опция|.
		
		Автокоманды выполняются в следующем порядке:

		1. WinLeave для активного окна
		2. WinEnter для нового окна
		3. BufLeave для текущего буфера
		4. BufEnter для нового буфера
		
		Эта команда работает как команда ":split", после которой была
		выполнена команда ":e".

:[N]vne[w] [++опция] [+команда] [файл]			        *:vne* *:vnew*
		То же, что и |:new|, но окна будут разделяться по вертикали.
		Если включена опция 'equalalways', а значение опции
		'eadirection' не равно "ver", то окна будут равномерно
		распределены по горизонтали, если не задана конкретная ширина
		окна.

:[N]new [++опция] [+команда] {файл}
:[N]sp[lit] [++опция] [+команда] {файл}			            *:split_f*
		Создать новое окно и начать редактирование указанного {файла}
		в этом окне. Если указана [+команда], то она будет выполнена
		после загрузки этого файла, см. |+команда|.
		См. также |++опция|.
		Новое окно создаётся размером N строк в высоту (по умолчанию:
		половина существующей высоты). Высота активного окна (или всех
		окон, если включена опция 'equalalways') уменьшается на
		соответствующую величину.

:[N]sv[iew] [++опция] [+команда] {файл}		    *:sv* *:sview* *splitview*
		То же, что и ":split", но для данного буфера будет включена
		опция 'readonly'.

:[N]sf[ind] [++опция] [+команда] {файл}		    *:sf* *:sfind* *splitfind*
		То же, что и ":split", но с поиском {файла} по пути, заданном
		в значении опции 'path'.  Если {файл} не может быть найден, то
		разделение окна не происходит.

CTRL-W CTRL-^					    *CTRL-W_CTRL-^* *CTRL-W_^*
CTRL-W ^	Выполняет команду ":split #", разделяя окно на два и загружая
		для редактирования соседний файл.
		Если задано число, то выполняется команда ":split #N", то есть
		после разделения окна происходит редактирование буфера с
		указанным номером.

Обратите внимание, что на местоположение нового окна влияют значения опций
'splitbelow' и 'splitright'.

						           *:vert* *:vertical*
:vert[ical] {команда}
		Выполняется указанная {команда}.  Если в ней содержится
		команда, приводящая к разделению окна, то оно будет разделено
		по вертикали.

:lefta[bove] {команда}				         *:lefta* *:leftabove*
:abo[veleft] {команда}				           *:abo* *:aboveleft*
		Выполняется указанная {команда}. Если в ней содержится
		команда, приводящая к разделению окна, то оно будет открыто
		слева (при вертикальном разделении) или сверху (при
		горизонтальном разделении) от активного окна. Результат работы
		этой команды не зависит от значений опций 'splitbelow' и
		'splitright'.

:rightb[elow] {команда}				       *:rightb* *:rightbelow*
:bel[owright] {команда}				          *:bel* *:belowright*
		Выполняется указанная {команда}. Если в ней содержится
		команда, приводящая к разделению окна, то оно будет открыто
		справа (при вертикальном разделении) или снизу (при
		горизонтальном разделении) от активного окна. Результат работы
		этой команды не зависит от значений опций 'splitbelow' и
		'splitright'.

						             *:topleft* *E442*
:to[pleft] {команда}
		Выполняется указанная {команда}. Если в ней содержится
		команда, приводящая к разделению окна, то оно будет открыто в
		верхней части экрана на полную ширину. При вертикальном
		разделении окна, новое окно появляется в левой части экрана
		Vim и занимает полную высоту.

						                   *:botright*
:bo[tright] {команда}
		Выполняется указанная {команда}. Если в ней содержится
		команда, приводящая к разделению окна, то оно будет открыто в
		нижней части экрана на полную ширину. При вертикальном
		разделении окна, новое окно появляется в правой части экрана
		Vim и занимает полную высоту.

Указанные команды-модификаторы могут сочетаться для открытия разделённого по
вертикали окна на полную высоту. Например: >

	:vertical topleft edit tags

Эта команда открывает вертикальное окно на полную высоту в левой части экрана
и загружает в него файл "tags".


Закрытие окна
-------------

CTRL-W q						            *CTRL-W_q*
CTRL-W CTRL-Q						       *CTRL-W_CTRL-Q*
:q[uit]		Команда закрывает активное окно. При закрытии последнего окна
		(не считая окна справки) происходит завершение работы Vim. 
		При включённой опции 'hidden', если для активного буфера
		открыто только одно окно, то такой буфер становится скрытым.
		Если опция 'hidden' выключена, то команда не будет выполнена
		успешно, если буфер содержит несохранённые изменения и для
		этого буфера открыто только одно окно. 
		(Примечание: CTRL-Q работает не на всех терминалах)

:q[uit]!	Закрыть активное окно. Все изменения в соответствующем буфере
		будут утрачены, если для данного буфера открыто только одно
		окно. При закрытии последнего окна (не считая окна справки)
		происходит завершение работы Vim. Содержимое буфера
		утрачивается даже при включённой опции 'hidden'.

CTRL-W c					    *CTRL-W_c* *:clo* *:close*
:clo[se][!]	Закрыть активное окно. Если включена опция 'hidden' или в
		буфере содержатся несохранённые изменения и был использован
		модификатор [!], то буфер станет скрытым (если не открыто
		другое окно для того же самого буфера).
		                                                        *E444*
		Команда не будет выполнена в следующих ситуациях:
		
		- На экране есть только одно окно.
		- Опция 'hidden' выключена, модификатор [!] не используется, в
		  буфере содержатся несохранённые изменения и для данного
		  буфера открыто только одно окно.

		Изменения в буфере не будут записаны и не будут утрачены, так
		что эта команда может считаться "безопасной".

CTRL-W CTRL-C						       *CTRL-W_CTRL-C*
		Вам могло показаться, что команда CTRL-W CTRL-C используется
		для закрытия окна, но это не так, поскольку при вводе CTRL-C
		выполнение команды будет прервано.

							               *:hide*
:hid[e]		Закрыть активное окно, если оно не является последним окном на
		экране. Буфер становится скрытым (если, значение опции
		'bufhidden' не равно "unload" или "delete" и для этого буфера
		не открыто другое окно). При выполнении этой команды значение
		опции 'hidden' не принимается во внимание. Изменения в данном
		буфере не сохраняются в файл и не утрачиваются, так что эта
		команда может считаться "безопасной".

:hid[e] {команда}	
		Выполнить {команду} с включённой опцией 'hidden'.  Раннее
		установленное состояние опции 'hidden' восстанавливается сразу
		после выполнения {команды}. Например: >

		    :hide edit Makefile
		    
<		Эта команда выполняет редактирование файла "Makefile" и
		скрывает активный буфер, если в нём имеются несохранённые
		изменения.

CTRL-W o						     *CTRL-W_o* *E445*
CTRL-W CTRL-O					 *CTRL-W_CTRL-O* *:on* *:only*
:on[ly][!]	Эта команда делает активное окно единственным открытым окном
		на экране. Все остальные окна будут закрыты.
		При включённой опции 'hidden' все буферы, связанные с
		закрытыми окнами, становятся скрытыми.
		При выключенной опции 'hidden' и включённой опции 'autowrite'
		происходит автоматическая запись всех несохранённых изменений.
		В противном случае, буферы, в которых имеются несохранённые
		изменения, не удаляются с экрана, если не указан 
		модификатор [!], либо становятся скрытыми, если этот
		модификатор был задан. В любом случае, изменённые буферы
		никогда не оставляются, так что изменения не могут быть
		утрачены.

==============================================================================
                                    	                  *window-move-cursor*
4. Перемещение курсора в другие окна	            *окно-перемещение_курсора*

CTRL-W <Вниз>				       *CTRL-W_<Down>* *CTRL-W_<Вниз>*
CTRL-W CTRL-J					    *CTRL-W_CTRL-J* *CTRL-W_j*
CTRL-W j	Переместить курсор в N-ное окно снизу от активного. Позиция
		курсора используется для выбора между несколькими вариантами.

CTRL-W <Вверх>					*CTRL-W_<Up>* *CTRL-W_<Вверх>*
CTRL-W CTRL-K					    *CTRL-W_CTRL-K* *CTRL-W_k*
CTRL-W k	Переместить курсор в N-ное окно сверху от активного. Позиция
		курсора используется для выбора между несколькими вариантами.

CTRL-W <Влево>				      *CTRL-W_<Left>* *CTRL-W_<Влево>*
CTRL-W CTRL-H					               *CTRL-W_CTRL-H*
CTRL-W <BS>					      *CTRL-W_<BS>* *CTRL-W_h*
CTRL-W h	Переместить курсор в N-ное окно слева от активного. Позиция
		курсора используется для выбора между несколькими вариантами.

CTRL-W <Вправо>				    *CTRL-W_<Right>* *CTRL-W_<Вправо>*
CTRL-W CTRL-L					    *CTRL-W_CTRL-L* *CTRL-W_l*
CTRL-W h	Переместить курсор в N-ное окно справа от активного. Позиция
		курсора используется для выбора между несколькими вариантами.

CTRL-W w					    *CTRL-W_w* *CTRL-W_CTRL-W*
CTRL-W CTRL-W	Без указания числа-приставки: переместить курсор в окно
		снизу/справа от активного. Если внизу или справа от активного
		окна нет окна, то выполняется перемещение курсора в верхнее
		левое окно. 
		Если указано число-приставка, то выполняется переход в N-ное
		окно (окна нумеруются от верхнего левого окна к нижнему
		правому). Для получения номера окна можно использовать функции
		|bufwinnr()| и |winnr()|.

						                    *CTRL-W_W*
CTRL-W W	Без указания числа-приставки: переместить курсор в окно
		сверху/слева от активного. Если сверху или слева от активного
		окна нет окна, то выполняется перемещение курсора в нижнее
		правое окно. Если указано число-приставка, то выполняется
		переход в N-ное окно (окна нумеруются от верхнего левого окна
		к нижнему правому).

CTRL-W t					    *CTRL-W_t* *CTRL-W_CTRL-T*
CTRL-W CTRL-T	Переместить курсор в верхнее левое окно.

CTRL-W b					    *CTRL-W_b* *CTRL-W_CTRL-B*
CTRL-W CTRL-B	Переместить курсор в нижнее правое окно.

CTRL-W p					    *CTRL-W_p* *CTRL-W_CTRL-P*
CTRL-W CTRL-P	Перейти к окну, в котором курсор находился до этого.

					      	             *CTRL-W_P* *E441*
CTRL-W P	Переход к окну предварительного просмотра. Если окно
		предпросмотра отсутствует, то выводится сообщение об ошибке.
		{доступно только в том случае, если Vim скомпилирован со
		включённой особенностью |+quickfix|}

При выполнении этих команд в Визуальном режиме происходит выход из Визуального
режима, если новое окно не связано с тем же самым буфером. Если окно открыто
для того же самого буфера, то позиция курсора изменяется таким образом, чтобы
сохранить выделение той же самой Визуальной области, что и в исходном окне.

						             *:winc* *:wincmd*
Перечисленные выше команды могут быть также выполнены с помощью команды
":wincmd":

:[число]winc[md] {параметр}
		То же, что и команда Обычного режима
		CTRL-W [число] {параметр}. Например:
>
			:wincmd j
			
<		Эта команда выполняет перемещение курсора в окно,
		расположенное ниже активного окна.
		Данная команда полезна в тех случаях, когда нельзя
		использовать команды Обычного режима, например при обработке
		автокомандного события |CursorHold|, или в тех случаях, когда
		применение команд Обычного режима неудобно.
 		Число может также быть номером окна. Например:
>
			:exe nr . "wincmd w"
<
		Эта команда выполняет переход в окно "nr".

==============================================================================
5. Перемещение окон по экрану		    *window-moving* *окно-перемещение*

CTRL-W r				     *CTRL-W_r* *CTRL-W_CTRL-R* *E443*
CTRL-W CTRL-R	Сдвинуть окна вниз или вправо. При этом первое окно становится
		вторым, второе -- третьим и т.д. Последнее окно занимает
		место первого. Курсор остаётся в том же окне, в котором он
		находился до выполнения этой команды.
		Эта команда работает только в пределах ряда или колонки окон,
		в котором находится активное окно.

						                    *CTRL-W_R*
CTRL-W R	Сдвинуть окна вверх или влево. При этом второе окно становится
		первым, третье -- вторым и т.д. Первое окно занимает место
		последнего. Курсор остаётся в том же окне, в котором он
		находился до выполнения этой команды.
		Эта команда работает только в пределах ряда или колонки окон,
		в котором находится активное окно.

CTRL-W x					    *CTRL-W_x* *CTRL-W_CTRL-X*
CTRL-W CTRL-X	При использовании команды без числовой приставки: поменять
		местами активное окно и следующее за ним окно. Если следующее
		окно отсутствует, то выполняется обмен с предыдущим окном. 
		Если в команде используется числовая приставка, то активное
		окно меняется местами с N-ным окном (первое окно имеет 
		номер 1). Курсор перемещается в другое окно. В случае,
		если разделённые по горизонтали и вертикали окна смешаны на
		экране, обмен выполняется только в пределах того ряда или
		колонки окон, в которых находится активное окно.

Ниже рассматриваются команды, которые могут быть использованы для изменения
раскроя окон на экране. Например, если имеется два разделённых по вертикали
окна, команда CTRL-W K изменяет раскрой окон таким образом, что образуется два
окна, разделённых по горизонтали, а команда CTRL-W H выполняет обратную
операцию.

						                    *CTRL-W_K*
CTRL-W K	Переместить активное окно на самый верх и развернуть его на
		полную ширину экрана. Команда работает так, как если бы мы
		закрыли активное окно и затем создали новое окно по команде
		":topleft split", но при этом в новое окно было бы загружено
		содержимое активного раннее окна.

						                    *CTRL-W_J*
CTRL-W J	Переместить активное окно в самый низ и развернуть его на
		полную ширину экрана. Команда работает так, как если бы мы
		закрыли активное окно и затем создали новое окно по команде
		":botright split", но при этом в новое окно было бы загружено
		содержимое активного раннее окна.

						                    *CTRL-W_H*
CTRL-W H	Переместить активное окно в самую левую часть экрана и
		развернуть его на полную высоту. Команда работает так, как
		если бы мы закрыли активное окно и затем создали новое окно по
		команде ":vert topleft split", но при этом в новое окно было
		бы загружено содержимое активного раннее окна.
		{доступно только в том случае, если Vim скомпилирован с
		особенностью |+vertsplit|}

						                    *CTRL-W_L*
CTRL-W L	Переместить активное окно в самую правую часть экрана и
		развернуть его на полную высоту. Команда работает так, как
		если бы мы закрыли активное окно и затем создали новое окно по
		команде ":vert botright split", но при этом в новое окно было
		бы загружено содержимое активного раннее окна.
		{доступно только в том случае, если Vim скомпилирован с
		особенностью |+vertsplit|}

==============================================================================
6. Изменение размеров окна		        *window-resize* *окно-размеры*

						                    *CTRL-W_=*
CTRL-W =	Сделать все окна (почти) одинакового размера (по высоте и по
		ширине), но при этом использовать для активного окна значения
		опций 'winheight' и 'winwidth'.

:res[ize] -N					   *:res* *:resize* *CTRL-W_-*
CTRL-W -	Уменьшить высоту активного окна на N строк (по умолчанию: 1).
		При использовании после 'vertical': уменьшить ширину на N.

:res[ize] +N					                    *CTRL-W_+*
CTRL-W +	Увеличить высоту активного окна на N строк (по умолчанию: 1).
		При использовании после 'vertical': увеличить ширину на N.

:res[ize] [N]
CTRL-W CTRL-_					    *CTRL-W_CTRL-_* *CTRL-W__*
CTRL-W _	Распахнуть активное окно на N строк по высоте (по умолчанию:
		на максимально возможную высоту).

z{nr}<CR>	Распахнуть активное окно на {nr} строк по высоте.

						                    *CTRL-W_<*
CTRL-W <	Уменьшить ширину активного окна на N колонок 
		(по умолчанию: 1).

						                    *CTRL-W_>*
CTRL-W >	Увеличить ширину активного окна на N колонок
		(по умолчанию: 1).

                                                   *CTRL-W_вертикальная_черта*
:vertical res[ize] [N]			       *:vertical-resize* *CTRL-W_bar*
CTRL-W |	Распахнуть активное окно на N колонок по ширине 
		(по умолчанию: на максимально возможную ширину).

Вы можете также изменять размеры окна, перетаскивая строку состояния с помощью
мыши вверх или вниз, либо перетаскивая вертикальную колонку-разделитель влево
или вправо. Эта возможность доступна только в том случае, если ваша версия Vim
поддерживает работу с мышью и если опция 'mouse' настроена соответствующим
образом.

Опция 'winheight' ('wh') используется для управления минимальной высотой
активного окна. Её значение проверяется каждый раз, когда курсор перемещается
в другое окно. Если значение этой опции равно '0', то она не влияет на размеры
активного окна. Чтобы активное окно всегда распахивалось на максимально
возможную высоту, назначьте этой опции очень большое значение, 
например '9999'. Наиболее удобным для работы является более разумное значение
этой опции, например '10'.

Аналогичная опция 'winwidth' ('wiw') используется для настройки минимальной
ширины активного окна.

При включённой опции 'equalalways' ('ea'), все окна автоматически
выравниваются по размеру при закрытии или разделении окна. В том случае, если
эта опция выключена, разделение окна приводит к уменьшению размеров активного
окна, в то время как остальные окна не изменяют своего размера, а при закрытии
окна освободившееся пространство передаётся вышерасположенному окну.

Опция 'eadirection' используется для ограничения направления, в котором
работает опция 'equalalways'. Значение по умолчанию "both" приводит 
к изменению размеров окон в обоих направлениях. При использовании 
значения "ver" будет выравниваться только высота окон, что может оказаться
полезным в тех случаях, когда вы установили ширину разделённого по вертикали
окна вручную, и хотели бы сохранять эту ширину во время работы. Аналогично,
значение "hor" используется для того, чтобы окна выравнивались только по
ширине.

Опция 'cmdheight' ('ch') используется для настройки высоты командной строки.
Если вас раздражает необходимость отвечать на приглашение |нажмите-enter|,
которое выводится после длинных сообщений, то вы можете установить значение
этой опции равным 2 или 3.

Высота командной строки также может быть изменена путём изменения размеров
единственного окна. Если на экране имеется несколько окон, то при изменении
высоты активного окна также происходит изменение высоты нижерасположенного
окна (а иногда и вышерасположенного).

Минимальная высота и ширина окна устанавливается при помощи опций
'winminheight' и 'winminwidth'. Значения этих опций являются жёсткими: окно не
может быть меньше соответствующих значений ни при каких обстоятельствах.

==============================================================================
                                                                 *buffer-list*
7. Команды для работы со списками аргументов и буферов         *буферы-список*

   список аргументов        список буферов       значение~
1. :[N]argument [N]	11. :[N]buffer [N]	 к аргументу/буферу N
2. :[N]next [файл ..]	12. :[N]bnext [N]	 к N-ному следующему
						 аргументу/буферу
3. :[N]Next [N]		13. :[N]bNext [N]	 к N-ному предыдущему
						 аргументу/буферу
4. :[N]previous	[N]	14. :[N]bprevious [N]	 к N-ному предыдущему
						 аргументу/буферу
5. :rewind / :first	15. :brewind / :bfirst	 к первому аргументу/буферу
6. :last		16. :blast		 к последнему аргументы/буферу
7. :all			17. :ball		 редактировать все позиции в
                                                 списке аргументов или буферов
			18. :unhide		 редактировать все загруженные
						 буферы
			19. :[N]bmod [N]	 к N-ному буферу с
						 несохранёнными изменениями

    список аргументов       список буферов       значение~
    с разделением           с разделением~
21. :[N]sargument [N]   31. :[N]sbuffer [N]	 разделить окно и перейти к
						 аргументу/буферу N
22. :[N]snext [файл ..] 32. :[N]sbnext [N]       разделить окно и перейти к
						 N-ному следующему
						 аргументу/буферу
23. :[N]sNext [N]       33. :[N]sbNext [N]       разделить окно и перейти к 
                                                 N-ному предыдущему
						 аргументу/буферу
24. :[N]sprevious [N]   34. :[N]sbprevious [N]   разделить окно и перейти к 
                                                 N-ному предыдущему
						 аргументу/буферу
25. :srewind / :sfirst	35. :sbrewind / :sbfirst разделить окно и перейти к
						 первому аргументу/буферу
26. :slast		36. :sblast		 разделить окно и перейти к
						 последнему аргументы/буферу
27. :sall		37: :sball		 редактировать все позиции в
						 списке аргументов или буферов
			38. :sunhide		 редактировать все загруженные
						 буферы
			39. :[N]sbmod [N]	 разделить окно и перейти к
						 N-ному буферу с
						 несохранёнными изменениями

40. :args		вывести список аргументов
41. :buffers		вывести список буферов

Значение [N] зависит от используемой команды:

 [N] это количество буферов, на которые нужно перейти вперёд или назад в
     командах ?2, ?3 и ?4
 [N] это номер аргумента, по умолчанию активный элемент списка аргументов,
     в командах 1 и 21
 [N] это номер буфера, по умолчанию активный буфер, в командах 11 и 31
 [N] это число, в командах 19 и 39

Замечание: команда ":next" является своего рода исключением, поскольку она
должна принимать в качестве параметра список имён файлов, для обеспечения
совместимости с Vi.


Список аргументов и использование нескольких окон
-------------------------------------------------

Текущая позиция в списке аргументов может отличаться от окна к окну. При
выполнении команды ":e файл" позиция в списке аргументов остаётся той же
самой, однако вы будете редактировать вовсе не тот файл, что находится в этой
позиции списка аргументов. Чтобы это было более наглядно, в сообщении,
указывающем на имя файла (и в заголовке окна) отображается "файл (N) из M",
где "(N)" это текущая позиция в списке файлов, а "M" это количество файлов в
списке.

Все элементы списка аргументов добавляются в список буферов. Таким образом, вы
также можете перемещаться по списку аргументов с помощью команд списка
буферов, например ":bnext".

:[N]al[l][!] [N]				   *:al* *:all* *:sal* *:sall*
:[N]sal[l][!] [N]
		Изменить раскрой окон на экране таким образом, чтобы для
		каждого элемента списка аргументов было открыто по одному
		окну. Все остальные окна при этом закрываются. Если в команде
		задано число, то оно указывает на максимально возможное
		количество окон.
		При включённой опции 'hidden' все буферы, связанные с
		закрытыми окнами, становятся скрытыми.
		Если опция 'hidden' выключена и включена опция 'autowrite', то
		все изменения в буферах будут сохранены. В противном случае,
		окна, которые связаны с буферами с несохранёнными изменениями,
		не будут закрыты, если не был задан модификатор [!]. При
		использовании ! изменённые буферы становятся скрытыми. В любом
		случае, изменённые буферы не будут брошены программой, так что
		изменения не могут быть утрачены.
 		[N] указывает на максимальное число открытых окон. Количество
		открытых окон также ограничивается значением опции 'winheight'
		(или 'winwidth', если используется команда-модификатор
		|:vertical|).
		Автокоманды Buf/Win Enter/Leave не выполняются при создании
		новых окон. Эти автокоманды выполняются только при фактическом
		перемещении в соответствующее окно.

:[N]sa[rgument][!] [++опция] [+команда] [N]	            *:sa* *:sargument*
		То же, что и ":split | argument [N]": выполняется разделение
		окна с последующим переходом к N-ной позиции в списке
		аргументов. Однако, если заданный аргумент отсутствует в
		списке, то окно разделяться не будет. См. также |++опция| и
		|+команда|.

:[N]sn[ext][!] [++опция] [+команда] [файл ..]                   *:sn* *:snext*
		То же, что и ":split | [N]next": выполняется разделение
		окна с последующим переходом к N-ному следующему элементу
		списка аргументов. Однако, если в списке отсутствует следующий
		аргумент, то окно разделяться не будет. См. также |++опция| и
		|+команда|.

:[N]spr[evious][!] [++опция] [+команда] [N] 		   *:spr* *:sprevious*
:[N]sN[ext][!] [++опция] [+команда] [N]			        *:sN* *:sNext*
		То же, что и ":split | [N]next": выполняется разделение
		окна с последующим переходом к N-ному предыдущему элементу
		списка аргументов. Однако, если в списке отсутствует
		предыдущий аргумент, то окно разделяться не будет. См. также
		|++опция| и |+команда|.

						             *:sre* *:srewind*
:sre[wind][!] [++опция] [+команда]
		То же, что и ":split | rewind": выполняется разделение окна с
		последующим переходом к первому элементу в списке аргументов.
		Однако, если список аргументов отсутствует, то окно
		разделяться не будет. См. также |++опция| и |+команда|.

						             *:sfir* *:sfirst*
:sfir[st [++опция] [+команда]
		То же, что и ":srewind".

						               *:sla* *:slast*
:sla[st][!] [++опция] [+команда]
		То же, что и ":split | last": выполняется разделение окна с
		последующим переходом к последнему элементу в списке
		аргументов. Однако, если список аргументов отсутствует, то
		окно разделяться не будет. См. также |++опция| и |+команда|.

						                 *:dr* *:drop*
:dr[op] {файл} ..
		
		Редактирование первого {файла} в окне.

		- если файл уже открыт в каком-нибудь окне, то курсор
		  перемещается в это окно. 
		- если окно для файла не открыто, то файл будет загружен для
		  редактирования в активном окне. Если Vim не может |оставить|
		  активный буфер, то окно будет разделено перед тем, как
		  произойдёт загрузка.
	
		Как и в случае с использованием команды |:next|, при этом
		происходит изменение |списка_аргументов|. Эта команда полезна
		в тех случаях, когда внешняя программа, например отладчик,
		желает заставить Vim перейти к редактированию другого файла.
		{доступно только в том случае, если Vim скомпилирован 
		с особенностью |+gui|}

==============================================================================
                                                                 *list-repeat*
8. Выполнение команды во всех буферах или окнах             *повтор_по_списку*

							              *:windo*
:windo[!] {команда}	Выполнить указанную {команду} в каждом окне.
			
			Эта команда работает примерно следующим образом:
>
				CTRL-W t
				:{команда}
				CTRL-W w
				:{команда}
				и т.д.
<				
			Если выполнение команды в одном из окон приводит к
			возникновению ошибки, то последующие окна не
			посещаются.
			Последнее окно (или окно, в котором произошла ошибка)
			становится активным окном.
			{команда} может на самом деле включать несколько
			команд, объединённых с помощью символа '|'.
			{команда} не должна выполнять открытие или закрытие
			окон или изменять их порядок.
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован 
			с особенностью |+listcmds|}

			См. также |:argdo| и |:bufdo|.

							              *:bufdo*
:bufdo[!] {команда}	Выполнить указанную {команду} в каждом буфере в списке
			буферов.

			Эта команда работает примерно следующим образом:
>
				:bfirst
				:{команда}
				:bnext
				:{команда}
				и т.д.
<			
			Если Vim не может |оставить| активный в настоящий
			момент файл, а модификатор [!] не указан, то команда
			завершается неудачно.
			Если выполнение команды в одном из буферов приводит к
			возникновению ошибки, то последующие буферы не
			посещаются.
			Буферы вне списка пропускаются.
			Последний буфер (или буфер, в котором произошла
			ошибка) становится активным буфером.
			{команда} может на самом деле включать несколько
			команд, объединённых с помощью символа '|'.
			{команда} не должна выполнять удаление буферов или
			добавление буферов к списку буферов.
			Замечание: во время выполнения этой команды обработка
			автокомандного события Syntax отключается путём
			изменения значения опции 'eventignore'. Это позволяет
			значительно ускорить выполнение команды в каждом
			буфере.
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован 
			с особенностью |+listcmds|}

			См. также |:argdo| и |:bufdo|.

Примеры: >

	:windo set nolist nofoldcolumn | normal zn

Эта команда отключает опцию 'list' и отменяет использование складок во всех
окнах.
>
	:bufdo set fileencoding= | update

Данная команда сбрасывает значение опции 'fileencoding' в каждом буфере и
выполняет запись буфера в том случае, если это привело к появлению
несохранённых изменений. В результате, все буферы будут использовать
кодировку, соответствующую значению опции 'encoding' (если преобразование
кодировок работает правильно).

==============================================================================
9. Метки и имена файлов в позиции курсора            *window-tag* *окно-метки*

							        *:sta* *:stag*
:sta[g][!] [метка]
		Выполняется команда ":tag[!] [метка]", после чего найденная
		метка открывается в новом окне. См. также |:tag|.

CTRL-W ]					    *CTRL-W_]* *CTRL-W_CTRL-]*
CTRL-W CTRL-]	Активное окно разделяется на две части. Имя в позиции курсора
		используется в качестве метки, к которой выполняется переход в
		новом верхнем окне. Новое окно будет иметь N строк в высоту.

							           *CTRL-W_g]*
CTRL-W g ]	Активное окно разделяется на две части. Имя в позиции курсора
		используется в качестве метки, к которой применяется команда
		":tselect" в новом верхнем окне. Новое окно будет иметь N
		строк в высоту.

							     *CTRL-W_g_CTRL-]*
CTRL-W g CTRL-]	Активное окно разделяется на две части. Имя в позиции курсора
		используется в качестве метки, к которой применяется команда
		":tjump" в новом верхнем окне. Новое окно будет иметь N
		строк в высоту.

CTRL-W f					    *CTRL-W_f* *CTRL-W_CTRL-F*
CTRL-W CTRL-F	Активное окно разделяется на две части и в новом окне
		загружается файл с именем, соответствующим имени файла в
		позиции курсора.
		 
		Эта команда аналогична команде ":split ]f", однако новое окно
		не будет открываться, если соответствующий файл не
		существует.
		Поиск файла выполняется в каталогах, перечисленных в значении
		опции 'path'. Кроме того, используется путь к активному
		файлу.
		Если имя является гипертекстовой ссылкой, похожей на
		конструкцию "протокол://компьютер/путь", то будет использован
		только компонент "путь".
		При указании числовой приставки выполняется редактирование
		N-ного файла в полученном списке соответствий.
		{доступно только в том случае, если Vim скомпилирован 
		с особенностью |+file_in_path|}

См. также |CTRL-W_CTRL-I|: открытие окна для включённого файла по имени в
позиции курсора.

==============================================================================
                                                              *preview-window*
					     *окна_предварительного_просмотра*
10. Окно предварительного просмотра	     *окно_предварительного_просмотра*

Окно предварительного просмотра является специальным окном, в котором
происходит предварительный просмотр другого файла. Обычно оно открывается в
виде небольшого окна, в котором отображается включённый файл или определение
функции. 
{доступно только в том случае, если Vim скомпилирован с особенностью
|+quickfix|}

В Vim может быть открыто только одно окно предпросмотра. Оно создаётся с
помощью одной из нижеперечисленных команд. Высота окна предпросмотра
настраивается с помощью опции 'previewheight'. Чтобы окно предпросмотра
воспринималось Vim в качестве такового, в нём включается опция
'previewwindow'. Опция 'winfixheight' используется для сохранения высоты окна
предпросмотра при открытии или закрытии других окон.

						                *:pta* *:ptag*
:pta[g][!] [метка]
		Выполняется команда ":tag[!] [метка]" с последующим
		отображением найденной метки в окне предпросмотра, без
		изменения активного буфера и позиции курсора. Если окно
		предпросмотра уже существует, то оно будет использовано
		повторно (как в случае с окном справки). При открытии нового
		окна предпросмотра его высота определяется в соответствии со
		значением опции 'previewheight'. См. также |:tag|.
		Пример использования этой команды приводится ниже,
		см. |CursorHold-пример|.
		Небольшое отличие от команды |:tag|: Если [метка] является уже
		отображаемой меткой, то позиция в списке соответствий имени
		метки не сбрасывается. Это делает возможной работу
		примера CursorHold после выполнения команды |:ptnext|.

CTRL-W z					                    *CTRL-W_z*
CTRL-W CTRL-Z				       *CTRL-W_CTRL-Z* *:pc* *:pclose*
:pc[lose][!]	Команда используется для закрытия окна предварительного
		просмотра. При включённой опции 'hidden' или при использовании
		модификатора [!] соответствующий буфер становится скрытым
		(если этот буфер не редактируется также в другом окне).
		Команда завершается неудачно, если один из буферов
		предпросмотра не может быть закрыт. См. также |:close|.

							         *:pp* *:ppop*
:[число]pp[op][!]
		Выполнить команды ":[число]pop[!]" в окне предпросмотра. 
		См. справку по командам |:pop| и |:ptag|.  
		{Vi не имеет такой возможности}

CTRL-W }						            *CTRL-W_}*
		То же, что и команда |:ptag| с использованием имени в позиции
		курсора. Если в результате выполнения команды открывается
		новое окно предпросмотра, то оно создаётся высотой в N строк.
		Если N не задано, то используется значение опции
		'previewheight'.

CTRL-W g }						           *CTRL-W_g}*
		То же, что и команда |:ptjump| с использованием имени в
		позиции курсора. Если в результате выполнения команды
		открывается новое окно предпросмотра, то оно создаётся высотой
		в N строк. Если N не задано, то используется значение опции
		'previewheight'.

							       *:ped* *:pedit*
:ped[it][!] [++опция] [+команда] {файл}
		Начать редактирование указанного {файла} в окне предпросмотра.
		Окно предпросмотра открывается как при использовании команды
		|:ptag|. При этом активное окно и позиция курсора не
		изменяются. Полезный пример: >

			:pedit +/fputc /usr/include/stdio.h
<
							      *:ps* *:psearch*
:[диапазон]ps[earch][!] [число] [/]шаблон[/]
		Работает как |:ijump|, однако найденные соответствия
		отображаются в окне предпросмотра. Окно предварительного
		просмотра открывается как при выполнении команды |:ptag|.
		Активное окно и позиция курсора не изменяются. Полезный
		пример:
>
			:psearch popen
<		
		Как и при выполнении команды |:ptag|, вы можете использовать
		эту возможность для автоматического отображения информации о
		слове в позиции курсора. Это, конечно, не такой
		интеллектуальный метод, как использование команды |:ptag|, но
		в этом случае не требуется файл меток и будет также
		выполняться поиск в системных включаемых файлах. Пример:
>
  :au! CursorHold *.[ch] nested exe "silent! psearch " . expand("<cword>")
<
		Предупреждение: выполнение команды может потребовать какое-то
		время.

Пример		                      *CursorHold-example* *CursorHold-пример*
>
  :au! CursorHold *.[ch] nested exe "silent! ptag " . expand("<cword>")

Эта команда позволяет выполнять команду ":ptag" для имени в позиции курсора в
том случае, если курсор не перемещается в течение интервала времени, заданного
в значении опции 'updatetime'. Параметр "nested" позволяет также выполняться и
другим автокомандам, так что в окне предпросмотра будет работать подсветка
синтаксиса. Команда "silent!" позволяет избегать вывода сообщения об ошибке
в том случае, если метка не может быть найдена. См. также |CursorHold|. Для
отключения указанной возможности используйте команду
>
  :au! CursorHold

Показанная возможность может быть также дополнена подсветкой найденной метки,
пропуском выполнения команды ":ptag" в том случае, если в позиции курсора не
обнаружено слово, и рядом других вещей: 
>
  :au! CursorHold *.[ch] nested call PreviewWord()
  :func PreviewWord()
  :  if &previewwindow			" не выполнять в окне предпросмотра
  :    return
  :  endif
  :  let w = expand("<cword>")		" получить слово в позиции курсора
  :  if w =~ '\a'			" если в слове есть буква
  :
  :    " Удалить имеющуюся подсветку перед отображением новой метки
  :    silent! wincmd P			" перейти в окно предпросмотра
  :    if &previewwindow			" если переход выполнен...
  :      match none			" удалить существующую подсветку
  :      wincmd p			" вернуться в прежнее окно
  :    endif
  :
  :    " Попытаться отобразить метку, соответствующую слову в позиции курсора
  :    try
  :      exe "ptag " . w
  :    catch
  :      return
  :    endtry
  :
  :    silent! wincmd P			" выполнить переход в окно
  :                                     " предпросмотра
  :    if &previewwindow		" если переход выполнен...
  :	 if has("folding")
  :	   silent! .foldopen		" открыть закрытую складку
  :	 endif
  :	 call search("$", "b")		" переместиться в конец предыдущей
  :                                     " строки
  :	 let w = substitute(w, '\\', '\\\\', "")
  :	 call search('\<\V' . w . '\>')	" поместить курсор в позицию
  :                                     " найденного соответствия
  :	 " Добавить подсветку соответствия к слову в данной позиции
  :      hi previewWord term=bold ctermbg=green guibg=green
  :	 exe 'match previewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
  :      wincmd p			" вернуться в прежнее окно
  :    endif
  :  endif
  :endfun

==============================================================================
11. Использование скрытых буферов	      *buffer-hidden* *буферы-скрытые*

Скрытый буфер не отображается в окне, но остаётся загруженным в память. Это
позволяет перемещаться между файлами без необходимости выполнять чтение или
запись файла всякий раз, когда буфер загружается в окно.
{доступно только в том случае, если Vim скомпилирован с особенностью
|+listcmds|}

							           *:buffer-!*
При включённой опции 'hidden' ('hid'), оставленные, или "брошенные", буферы
остаются загруженными в память при выполнении всех команд, которые приводят
к редактированию нового файла: ":edit", ":next", ":tag" и т.д. Команды,
позволяющие перемещаться по списку буферов, иногда скрывают активный буфер
даже в тех случаях, когда опция 'hidden' выключена. Это происходит в тех
случаях, когда буфер был изменён, но должен быть удалён с экрана, поскольку
используется модификатор '!', в то время как сохранение буфера невозможно или
опция 'autowrite' выключена.

Чтобы скрытый буфер снова стал видимым достаточно начать его редактирование
при помощи любой подходящей для этого команды. Вы можете также удалить буфер с
помощью команды ":bdelete".

Опция 'hidden' является глобальной и применяется для всех буферов сразу. Чтобы
сделать исключение для какого-то отдельно выбранного буфера, используется
опция 'bufhidden', которая может принимать следующие значения:

	<пусто>		Используется значение опции 'hidden'.
	hide		Скрыть этот буфер, даже если опция 'hidden' выключена.
	unload		Буфер не скрывается, а выгружается из памяти, даже
			если опция 'hidden' включена.
	delete		Удалить этот буфер из списка.

				          *hidden-quit* *скрытые_буферы-выход*
При попытке прекращения работы Vim, если в память загружены изменённые скрытые
буферы, выводится сообщение об ошибке, после чего такой буфер становится
активным буфером. Вы можете либо сохранить изменения в данном буфере (":wq"),
либо выйти из Vim без сохранения (":q!"). Будьте внимательны: у вас могут
иметься и другие скрытые изменённые буферы!

Буфер также может быть помещён вне списка. Это означает, что буфер существует,
но не присутствует в списке буферов. См. |буфер_вне_списка|.


:files[!]					                      *:files*
:buffers[!]					              *:buffers* *:ls*
:ls[!]		Показать список всех буферов.  Например: 

			1 #h  "/test/text"		строка 1 ~
			2u    "asdf"			строка 0 ~
			3 %l+ "version.c"		строка 1 ~

		При использовании модификатора [!] будут показаны все буферы,
		в том числе и те, которые находятся вне списка (в этом случае
		термин "вне списка" является немного неточным...).

		Каждому буферу присваивается свой уникальный номер. Этот номер
		не изменяется, так что вы всегда можете перейти к
		определённому буферу по команде ":buffer N" или "N CTRL-^",
		где N это номер буфера.

		В списке буферов используются следующие пометки (те из них,
		которые здесь показаны в одной колонке, являются
		взаимоисключающими):

		u	буфер вне списка (отображается только при
			использовании [!]). См. |буфер_вне_списка|.
		 %	буфер загружен в активном окне
		 #	"соседний" буфер, для использования в командах ":e #"
		  	и CTRL-^
		  a	активный буфер: содержимое буфера загружено и
		        отображается на экране
		  h	скрытый буфер: буфер загружен, но в данный момент не
		        отображается на экране. См. |скрытый_буфер|.
		   -	буфер с выключенной опцией 'modifiable'
		   =	буфер, загруженный только для чтения
		    +	буфер с изменённым содержанием
		    x   буфер, при чтении которого возникли ошибки

						                *:bad* *:badd*
:bad[d]	[+номер_строки] {имя_файла}
		Добавить файл с указанным {именем_файла} к списку буферов, не
		загружая его в память. Если указан параметр "номер_строки", то
		при переходе в данный буфер курсор будет размещён в указанной
		строке. Обратите внимание, что любая другая команда после +
		будет игнорироваться.

:[N]bd[elete][!]			       *:bd* *:bdel* *:bdelete* *E516*
:bd[elete][!] [N]
		Выгрузить буфер [N] (по умолчанию: текущий буфер) из памяти и
		удалить его из списка буферов. Команда не будет выполнена,
		если в буфере содержатся несохранённые изменения, если,
		конечно, не указан модификатор [!] -- в этом случае имеющиеся
		изменения будут утрачены. Соответствующий файл не
		затрагивается при выполнении этой команды. Все открытые для
		данного буфера окна будут закрыты. Если буфер [N] является
		текущим буфером, то вместо него будет показан другой буфер, 
		а именно буфер, соответствующий последней позиции в списке
		прыжков, которая указывает на загруженный буфер.
		На самом деле, буфер не удаляется из памяти полностью: он
		просто удаляется из списка буферов (|буфер_вне_списка|), после
		чего очищаются все значения опций, переменных, привязок и
		сокращений, которые были определены для данного буфера.

:bdelete[!] {имя_буфера}					   *E93* *E94*
		То же, что и ":bdelete[!] [N]", но буфер задаётся по имени.
		Обратите внимание, что буфер, именем которого является число,
		не может быть указан по имени; вместо этого необходимо
		использовать номер буфера. Если в имени буфера содержится
		пробел, то его следует экранировать с помощью символа обратной
		косой черты.

:bdelete[!] N1 N2 ...
		Выполнить команду ":bdelete[!]" для буферов N1, N2 и т.д.
		В качестве параметров могут использоваться номера буферов или
		имена буферов (кроме имён, которые представляют собой
		число). Если в имени буфера содержится пробел, то его следует
		экранировать с помощью символа обратной косой черты.

:N,Mbdelete[!]	Выполнить команду ":bdelete[!]" для всех буферов в диапазоне
		от N до M |включительно|.

:[N]bw[ipeout][!]			     *:bw* *:bwipe* *:bwipeout* *E517*
:bw[ipeout][!] {имя_буфера}
:N,Mbw[ipeout][!]
:bw[ipeout][!] N1 N2 ...
		То же, что и |:bdelete|, но буфер будет действительно
		удаляться из памяти. При этом становятся недействительными все
		отметки, определённые в этом буфере, теряются настройки опций
		и т.д. Эту команду не стоит использовать, если вы не уверены в
		своих действиях.

:[N]bun[load][!]				      *:bun* *:bunload* *E515*
:bun[load][!] [N]
		Выгрузить из памяти буфер [N] (по умолчанию: текущий буфер).
		При этом освобождается выделенная для этого буфера память, но
		сам буфер остаётся в списке буферов.
		Если в буфере имеются несохранённые изменения, то команда не
		будет выполнена, если не указан модификатор [!] -- в этом
		случае имеющиеся изменения будут утрачены. Все открытые для
		данного буфера окна будут закрыты. Если буфер [N] является
		текущим буфером, то вместо него будет показан другой буфер, 
		а именно буфер, соответствующий последней позиции в списке
		прыжков, которая указывает на загруженный буфер.

:bunload[!] {имя_буфера}
		То же, что и ":bunload[!] [N]", но буфер задаётся по имени.
		Обратите внимание, что буфер, именем которого является число,
		не может быть указан по имени; вместо этого необходимо
		использовать номер буфера. Если в имени буфера содержится
		пробел, то его следует экранировать с помощью символа обратной
		косой черты.

:N,Mbunload[!]	То же, что и ":bunload[!]", но для всех буферов в диапазоне 
		от N до M |включительно|.

:bunload[!] N1 N2 ...
		Выполнить команду ":bunload[!]" для буферов N1, N2 и т.д.
		В качестве параметров могут использоваться номера буферов или
		имена буферов (кроме имён, которые представляют собой
		число). Если в имени буфера содержится пробел, то его следует
		экранировать с помощью символа обратной косой черты.

:[N]b[uffer][!] [N]			     *:b* *:bu* *:buf* *:buffer* *E86*
		Перейти к редактированию буфера [N] из списка буферов. Если
		параметр [N] не задан, то продолжается выполнение
		редактирования текущего буфера. Об использовании [!] см. в
		разделе |:buffer-!|. Эта команда также позволяет выполнить
		редактирование буфера вне списка без включения опции
		'buflisted'.

:[N]b[uffer][!] {имя_файла}
		Перейти к редактированию буфера с заданным {именем_файла} из
		списка буферов. Об использовании [!] см. в разделе
		|:buffer-!|. Эта команда также позволяет выполнить
		редактирование буфера вне списка без включения опции
		'buflisted'.

:[N]sb[uffer] [N]					      *:sb* *:sbuffer*
		Разделить окно и перейти к редактированию буфера [N] из списка
		буферов. Если параметр [N] не задан, то выполняется
		редактирование текущего буфера. При разделении окна
		учитывается значение "useopen" опции 'switchbuf'. Эта команда
		также позволяет выполнить редактирование буфера вне списка без
		включения опции 'buflisted'.

:[N]sb[uffer] {имя_файла}
		Разделить окно и перейти к редактированию буфера из списка,
		заданного по указанному {имени_файла}. Эта команда также
		позволяет выполнить редактирование буфера вне списка без
		включения опции 'buflisted'.

							  *:bn* *:bnext* *E87*
:[N]bn[ext][!] [N]
		Перейти к [N]-ному следующему буферу в списке буферов. По
		умолчанию, [N] равно 1.
		При достижении конца списка буферов отсчёт продолжается от
		начала списка.
		Об использовании [!] см. раздел |:buffer-!|.
		Если текущим буфером является буфер справки, то выполняется
		переход к следующему буферу справки, если такой имеется.
		Аналогично, если текущий буфер является обычным буфером (не
		является буфером справки), то эта команда выполняет переход 
		к следующему обычному буферу. Таким образом, если вы открыли
		окно справки, то связанные с ним буферы не будут мешать
		просмотру содержимого буферов с обычным текстом или исходным
		кодом программ. Три нижеперечисленные команды работают
		аналогичным образом.

							      *:sbn* *:sbnext*
:[N]sbn[ext] [N]
		Разделить окно и перейти к [N]-ному следующему буферу в списке
		буферов. При достижении конца списка буферов отсчёт
		продолжается от начала списка. Учитывается значение опции
		'switchbuf'.

:[N]bN[ext][!] [N]		       *:bN* *:bNext* *:bp* *:bprevious* *E88*
:[N]bp[revious][!] [N]
		Перейти к [N]-ному предыдущему буферу в списке буферов. По
		умолчанию, [N] равно 1.
		При достижении начала списка буферов отсчёт продолжается от
		конца списка.
		Об использовании [!] см. раздел |:buffer-!|.
		См. также справку по опции 'switchbuf'.

:[N]sbN[ext] [N]			 *:sbN* *:sbNext* *:sbp* *:sbprevious*
:[N]sbp[revious] [N]
		Разделить окно и перейти к [N]-ному предыдущему буферу в
		списке буферов. При достижении начала списка буферов отсчёт
		продолжается от конца списка. Учитывается значение опции
		'switchbuf'.

							      *:br* *:brewind*
:br[ewind][!]	Перейти к первому буферу в списке буферов. Если список буферов
		пустой, то выполняется переход к первому буферу вне списка.
		Об использовании [!] см. раздел |:buffer-!|.

							       *:bf* *:bfirst*
:bf[irst]	То же, что и ":brewind".

							    *:sbr* *:sbrewind*
:sbr[ewind]	Разделить окно и перейти к первому буферу в списке буферов.
                Если список буферов пустой, то выполняется переход к первому
		буферу вне списка.
		Учитывается значение опции 'switchbuf'.

							     *:sbf* *:sbfirst*
:sbf[irst]	То же, что и ":sbrewind".

							        *:bl* *:blast*
:bl[ast][!]	Перейти к последнему буферу в списке буферов. Если список
		буферов пустой, то выполняется переход к последнему буферу
		вне списка.
		Об использовании [!] см. раздел |:buffer-!|.

							      *:sbl* *:sblast*
:sbl[ast]	Разделить окно и перейти к последнему буферу в списке буферов.
		Если список буферов пустой, то выполняется переход к
		последнему буферу вне списка.
		Учитывается значение опции 'switchbuf'.

:[N]bm[odified][!] [N]				      *:bm* *:bmodified* *E84*
		Перейти к [N]-ному следующему буферу с несохранёнными
		изменениями. Замечание: эта команда также включает и буферы
		вне списка. Если нет ни одного буфера с несохранёнными
		изменениями, то выводится сообщение об ошибке.

:[N]sbm[odified] [N]					  *:sbm* *:sbmodified*
		Разделить окно и перейти к [N]-ному следующему буферу с
		несохранёнными изменениями.
		Учитывается значение опции 'switchbuf'.
		Замечание: эта команда также включает и буферы вне списка.

:[N]unh[ide] [N]			    *:unh* *:unhide* *:sun* *:sunhide*
:[N]sun[hide] [N]
		Команда изменяет раскрой окон на экране таким образом, что
		открывается по одному окну для каждого загруженного буфера 
		в списке буферов. Если указано число-приставка, то она
		определяет максимальное количество открытых окон.

:[N]ba[ll] [N]					 *:ba* *:ball* *:sba* *:sball*
:[N]sba[ll] [N]	Команда изменяет раскрой окон на экране таким образом, что
                открывается по одному окну для каждого буфера в списке
		буферов. Если указано число-приставка, то она определяет
		максимальное количество открытых окон. Количество открытых
		окон также ограничивается значением опции 'winheight' (или
		'winwidth', если применяется команда-модификатор |:vertical|).
		При выполнении этой команды не отрабатываются автокоманды 
		Buf/Win Enter/Leave, эти события происходят при действительном
		переходе в соответствующий буфер или окно.

Замечание: все вышеперечисленные команды, выполнение которых приводит к
редактированию другого буфера, оставляют значение опции 'readonly' без
изменений. Это отличается от команды ":edit", при выполнении которой значение
опции 'readonly' изменяется каждый раз, когда происходит чтение файла.

==============================================================================
12. Буферы специального назначения	*special-buffers* *специальные_буферы*

Буферы могут использоваться не только для хранения содержимого файла, но и
выполнять другие задачи. Для изменения поведения буфера применяется несколько
специальных опций:

	'bufhidden'	определяет, что происходит с буфером, когда он
			перестаёт отображаться на экране
	'buftype'	задаёт тип буфера
	'swapfile'	определяет наличие своп-файла для этого буфера
	'buflisted'	определяет, должен ли этот буфер отображаться в списке
			буферов

Несколько полезных типов буфера:

quickfix	Используется для хранения списка ошибок. См. |:cwindow| -- эта
		команда устанавливает значение опции 'buftype' равным
		"quickfix". Вы не должны менять значение этой опции вручную!
		При использовании такого буфера опция 'swapfile' отключается.

help		Используется для отображения справки. Такой буфер может быть
		создан только с помощью команды |:help|. Признак справочного
		буфера включается внутри Vim и не может быть изменён вручную.
		В буфере справки отключается опция 'buflisted'.

directory	Этот буфер используется |проводником_по_файловой_системе| для
		отображения содержимого каталога. Буфер создаётся со
		следующими настройками:
>
			:set buftype=nowrite
			:set bufhidden=delete
			:set noswapfile
<		
		Имя буфера является именем каталога и автоматически изменяется
		при использовании команды |:cd|.

scratch		Буфер содержит текст, который может быть в любой момент
		удалён. При закрытии окна этот буфер сохраняется, так что для
		его удаления требуется явно использовать соответствующую
		команду.
		Настройки:
>
			:set buftype=nofile
			:set bufhidden=hide
			:set noswapfile
<		
		Для обращения к такому буферу можно использовать имя буфера.

				          *unlisted-buffer* *буфер_вне_списка*
unlisted	Буфер, который находится вне списка буферов. Такой буфер не
		используется для обычных задач редактирования, но может
		применяться для отображения файла справки или для сохранения
		имени файла или отметок. Буфер помещается вне списка также при
		выполнении команды ":bdelete", так что эта команда не удаляет
		буфер полностью. Настройки:
>
			:set nobuflisted
<

==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
