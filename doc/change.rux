*change.txt*    Для Vim version 6.3.  Последнее изменение: 2004 May 08


		      СПРАВОЧНИК ПО VIM - Брам Мооленаар


В этом файле описываются команды, благодаря которым можно удалять или изменять
текст. Под изменением текста понимается удаление фрагмента текста и замена
удалённого фрагмента другим текстом при помощи единственной команды. Каждая из
рассматриваемых здесь команд может быть отменена. Команды, которые не являются
командами Ex могут быть повторены при помощи команды ".".

1. Удаление текста		|удаление|
2. Удаление и вставка		|удаление-вставка|
3. Простые изменения		|простые_изменения|	*изменения* *changing*
4. Сложные изменения		|сложные_изменения|
5. Копирование и перемещение	|копирование-перемещение|
   текста
6. Форматирование текста	|форматирование|

Справку по вставке текста читайте в |insert.txt|.

==============================================================================
1. Удаление текста			          *deleting* *удаление* *E470*

["x]<Del>	или					      *<Del>* *x* *dl*
["x]x			Удалить заданное [число] символов, начиная с символа в
			позиции курсора [в регистр x] (не |построчно|).
			Команда делает то же, что и "dl".
			Кнопка <Del> не принимает параметр [число]. Вместо
			этого, с её помощью можно удалить последний символ из
			указанных с помощью числа. 
			Если кнопка <Del> ведёт себя не так, как требуется,
			обратитесь к справке по команде |:fixdel|. Информацию
			об удалении символа переноса строки (для склеивания
			строк) можно прочитать в справке по опции
			|'whichwrap'|.
			{Vi не поддерживает использование <Del>}

							              *X* *dh*
["x]X			Удалить заданное [число] символов перед курсором
			[в регистр x] (не |построчно|). Команда делает то же,
			что и "dh". См. также |'whichwrap'|.

							                   *d*
["x]d{перемещение}	Удалить текст, над которым происходит {перемещение} 
			[в регистр x]. Об исключениях смотрите ниже.

							                  *dd*
["x]dd			Удалить заданное [число] строк [в регистр x]
			|построчно|.

							                   *D*
["x]D			Удалить символы, начиная с символа в позиции курсора
			до конца строки, а также [число]-1 строк дополнительно
			[в регистр x]; эта команда является синонимом для
			команды "d$". 
			(не |построчно|)

{Визуально}["x]x	или			         *v_x* *v_d* *v_<Del>*
{Визуально}["x]d	или
{Визуально}["x]<Del>	
			Удалить выделенный текст [в регистр x]. Подробнее о
			{Визуально} см. |визуальный_режим|.
			{Vi не имеет такой возможности}

{Визуально}["x]CTRL-H   или				   *v_CTRL-H* *v_<BS>*
{Визуально}["x]<BS>	
			В режиме Выделения: удалить выделенный текст 
			[в регистр x].

{Визуально}["x]X	или				   *v_X* *v_D* *v_b_D*
{Визуально}["x]D	
			Удалить выделенные строки [в регистр x] (подробнее о
			{Визуально} см. |визуальный_режим|). В режиме
			Визуального блока команда "D" удаляет не только
			выделенный текст, но и весь текст до конца строки.
			{Vi не имеет такой возможности}

						   *:d* *:de* *:del* *:delete*
:[диапазон]d[elete] [x]	Удалить [диапазон] строк (по умолчанию: текущую
			строку) [в регистр x].

:[диапазон]d[elete] [x] {число}
			Удалить заданное {число} строк, начиная со строки, на
			которую указывает [диапазон] (по умолчанию: текущая
			строка |командная_строка-диапазоны|) [в регистр x].

Эти команды служат для удаления текста. Вы можете повторять их при помощи
команды "." (кроме команды ":d"), а также при необходимости их можно
отменить. Для удаления блоков текста используйте Визуальный режим.
Использование регистров поясняется здесь: |регистры|.

Исключение составляет команда d{перемещение}: Если перемещение не является
построчным, начало и конец перемещения не находятся на одной строке, а перед
началом перемещения и после конца перемещения в тексте присутствуют только
пробелы, то команда удаления становится построчной. Иными словами, команда
удаления также затронет и пробелы, которые вы, возможно, планировали оставить
на месте.

Попытка удаления пустой области текста (например, по команде "d0" в первой
колонке) приводит к ошибке, если значение опции 'cpoptions' включает флаг 'E'. 

							                   *J*
J			Склеить заданное [число] строк, не менее двух.
			При этом также удаляется отступ и вставляется до двух
			пробелов (см. ниже).

							                 *v_J*
{Визуально}J		Склеить выделенные строки, не менее двух. При этом
			удаляется отступ и вставляется до двух пробелов.
			{Vi не имеет такой возможности}

							                  *gJ*
gJ			Склеить заданное [число] строк, не менее двух. При
			этом вставки или удаления пробелов не происходит.
			{Vi не имеет такой возможности}

							                *v_gJ*
{Визуально}gJ		Склеить выделенные строки, не менее двух. При этом
			вставки или удаления пробелов не происходит.
			{Vi не имеет такой возможности}

							          *:j* *:join*
:[диапазон]j[oin][!]	Склеить строки, заданные [диапазоном]. Команда
			работает так же, как и "J", с тем исключением, что при
			использовании [!] не происходит вставки или удаления
			пробелов. Если [диапазон] имеет одинаковое начало и
			конец, то команда ничего не делает. По умолчанию
			команда склеивает текущую строку со следующей строкой.
			{Vi не использует !}
			
:[диапазон]j[oin][!] {число}
			Склеить {число} строк, начиная со строки, заданной
			[диапазоном] (по умолчанию: начиная с текущей строки
			|командная_строка-диапазоны|). Команда работает так
			же, как и "J", с тем исключением, что при
			использовании [!] не происходит вставки или удаления
			пробелов.
			{Vi не использует !}

Эти команды удаляют символ <EOL> между строками. Это равноценно склеиванию
нескольких строк в одну. Эти команды можно повторять (кроме ":j"), а также
отменять.

Команды склейки строк, за исключением "gJ", вставляют один пробел вместо
символа <EOL>, за исключением ситуаций, когда на конце строки имеется пробел
или следующая строка начинается с ')'. Кроме того, эти команды, за исключением
"gJ" удаляют все пробелы в начале следующей строки. Если включена опция
'joinspaces', то после символов '.', '!', '?' вставляется два пробела (однако,
если в значении опции 'cpoptions' присутствует флаг 'j', то два пробела
вставляется только после '.').
Флаги 'B' и 'M' в значении опции 'formatoptions' изменяют поведение при
вставке пробелов до и после мультибайтного символа |fo-таблица|.

==============================================================================
						   *удаление-вставка* *замена*
2. Удаление и вставка				   *delete-insert* *replacing*

							                   *R*
R			Перейти в режим Замены: каждый набранный символ
			заменяет уже существующий, начиная с символа,
			находящегося в позиции курсора. Подробнее 
			см. |режим_замены|.

							                  *gR*
gR			Перейти в режим Виртуальной Замены: каждый набранный
			символ заменяет уже существующий символ в данной
			позиции экрана. Таким образом, символ <Tab> может
			привести к одновременной замене нескольких символов.
			Введённый текст можно повторить [число]-1 раз.
			Подробнее см. |режим_виртуальной_замены|.
			{доступно только в том случае, если Vim скомпилирован
			с особенностью +vreplace}

							                   *c*
["x]c{перемещение}	Удалить текст, над которым произойдёт указанное
			{перемещение} [в регистр x] и начать вставку. Если в
			значении опции 'cpoptions' содержится флаг 'E' и текст
			для удаления отсутствует (например, если курсор
			находится сразу после 'x' и вводится команда "cTx"),
		        то выдаётся сообщение об ошибке и перехода в режим
			Вставки не происходит (для совместимости с Vi). Если
			опция 'cpoptions' не содержит флаг 'E', то команда "c"
			всегда вызывает переход в режим вставки, даже если
			отсутствует текст для удаления.

							                  *cc*
["x]cc			Удалить заданное [число] строк [в регистр x] и начать
			вставку |построчно|. Если включена опция 'autoindent',
			то отступ первой строки сохраняется.

							                   *C*
["x]C			Удалить символы от курсора до конца строки, а также
			[число]-1 строк дополнительно [в регистр x], затем
			перейти к вставке текста. Команда является синонимом
			команды "c$" (не |построчно|).

							                   *s*
["x]s			Удалить заданное [число] символов [в регистр x] и
			перейти к вставке (s от английского "substitute",
			"замена"). Команда является синонимом команды "cl" 
			(не |построчно|).

							                   *S*
["x]S			Удалить указанное [число] строк [в регистр x] и
			перейти к вставке текста. Команда является синонимом
			команды "cc" |построчно|.

{Визуально}["x]c	или					   *v_c* *v_s*
{Визуально}["x]s		
			Удалить выделенный текст [в регистр x] и перейти к
			вставке текста (подробнее о {Визуально} см.
			|визуальный_режим|).
			{Vi не имеет такой возможности}

							                 *v_r*
{Визуально}["x]r{симв}	Заменить все выделенные символы на символ {симв}.

							                 *v_C*
{Визуально}["x]C		
			Удалить выделенные строки [в регистр x] и начать
			вставку. В режиме Визуального блока имеются
			определённые отличия, см. |v_b_C|.
			{Vi не имеет такой возможности}

							                 *v_S*
{Визуально}["x]S		
			Удалить выделенные строки [в регистр x] и начать
			вставку (подробнее о {Визуально} см.
			|визуальный_режим|).
			{Vi не имеет такой возможности}
							
							                 *v_R*
{Визуально}["x]R	Команда в текущей версии работает так же, как и
			{Визуально}["x]S. В следующих версиях возможны
			изменения в поведении этой команды.
			{Vi не имеет такой возможности}

Замечания:

- Выход из режимов Вставки и Замены может быть осуществлён по нажатию на
  кнопку <Esc>.
- О специальных кнопках в режимах Вставки и Замены см. раздел "Вставка и
  замена текста" (|режим_вставки_и_замены|).
- Влияние параметра [число] проявляется после того, как Vim выйдет из режима
  Вставки или Замены.
- Если значение опции 'cpoptions' содержит флаг '$', а изменения затрагивают
  только одну строку, то Vim продолжает показывать текст, который будет удалён
  и помещает '$' на месте последнего удалённого символа.


Регистры объясняются в разделе |регистры|.

В режиме Замены редактор работает так же, как и в режиме Вставки, за
исключением того обстоятельства, что каждый перед вставкой каждого символа
старый удаляется. При достижении конца строки Vim просто добавляет новые
символы, точно так же, как и в режиме Вставки. В режиме Замены кнопка <BS>
позволяет восстанавливать первоначальный текст, если таковой имеется.
Подробнее см. раздел "Вставка и замена текста" |режим_вставки_и_замены|.

						                     *cw* *cW*
Особый случай: команды "cw" и "cW" работают также, как и команды "ce" и "cE",
если курсор находится в позиции непробельного символа. Это связано с тем, что
Vim понимает "cw" как "change-word", "изменить слово", а слово не включает
следующий за ним пробел.  
{Vi: команда "cw", если курсор находится в позиции пробельного символа, за
которым следуют другие пробелы, приводит к замене только первого пробела; это,
по всей видимости, ошибка, поскольку "dw" удаляет все пробелы. Если вам по
каким-то причинам необходимо, чтобы в Vim эта команда работала так, как в Vi,
то добавьте флаг 'w' в значение опции 'cpoptions'}

Если вам больше нравится, чтобы команда "cw" включала пробел после слова, то
используйте такую привязку: >

	:map cw dwi
<
							  *:c* *:ch* *:change*
:{диапазон}c[hange]	Замена строк текста другим текстом. 
			Для прекращения замены введите строку, которая
			содержит одиночный символ ".". Если {диапазон} не
			указан, то происходит замена текущей строки.

==============================================================================
3. Простые изменения		           *simple-change* *простые_изменения*

							                   *r*
r{симв}			Заменить символ в позиции курсора на символ {симв}. 
			Если {симв} это <CR> или <NL>, то символ в позиции
			курсора заменяется на перенос строки. Для замены
			символа на настоящий символ <CR> используйте CTRL-V
			<CR>. CTRL-V <NL> позволяет осуществить замену на
			символ <Nul>.
			{Vi: CTRL-V <CR> приводит также к замене на перенос
			строки. Замена символа на символ <CR> невозможна}
			Если вы укажете в качестве параметра [число], то Vim
			заменит [число] символов текста на [число] символов
			{симв}. Однако, если в качестве {симв} используется
			<CR> или <NL>, то Vim подставит только один <CR>:
			например, по команде "5r<CR>" произойдёт замена пяти
			символов на один перенос строки. 
			Если в качестве символа {симв} выступает <CR> или
			<NL>, то Vim выполнит автоматическое форматирование
			отступов. В этом смысле команда будет работать точно
			так же, как и удаление символов, которые подлежат
			замене, с последующим вводом команды "i<CR><Esc>".
			Символ {симв} может быть введён в виде диграфа, см.
			|диграф-аргумент|. 
			Привязки |:lmap| применяются к символу {симв}. Команда
			CTRL-^ в режиме Вставки может использоваться для
			включения и отключения этой возможности |i_CTRL-^|. 
			Если значением опции 'encoding' является кодировка
			Unicode, то вам может также пригодиться информация в
			|utf8-символ-аргумент|.

							                  *gr*
gr{симв}		Замена виртуальных символов в позиции курсора на
			символ {симв}. В данном случае замене подлежат символы
			на экране, а не в файле. Подробнее см. |gR| и
			|режим_виртуальной_замены|. Как и для команды |r|,
			может быть указан параметр-[число]. Ввод символа
			{симв} осуществляется по тем же принципам, что и для
			команды |r|. 
			{доступно только в том случае, если Vim скомпилирован
			с особенностью +vreplace}

					       *digraph-arg* *диграф-аргумент*
Параметром для таких команд Обычного режима, как |r| и |t| является
единственный символ. Если в значении опции 'cpo' не указан флаг 'D', то этот
символ также может быть введён в виде диграфа (см. |диграфы|). Для этого нужно
ввести CTRL-K и затем двойной символ диграфа. 
{доступно только в том случае, если Vim скомпилирован с особенностью
|+digraphs|}

						      *case* *регистр_символа*
Команды, рассматриваемые ниже, позволяют изменять регистр символов. При этом
используются активные в данный момент настройки (см. |локаль|). См. также
|:language|. В данном случае используется значение переменной LC_CTYPE.

							                   *~*
~			Опция 'notildeop': изменить регистр символа в позиции
			курсора и переместить курсор вправо. При заданном
			параметре [число], изменить регистр указанного
			количества символов.
			{Vi: возможность указывать параметр [число]
			отсутствует}

~{перемещение}		Опция 'tildeop': изменить регистр символов текста, над
			которыми произойдёт {перемещение}.
			{Vi: тильда не может использоваться в качестве
			оператора}
			
							                  *g~*
g~{перемещение}		Изменить регистр символов текста, над которыми
			произойдёт {перемещение}.
			{Vi не имеет такой возможности}

g~g~							          *g~g~* *g~~*
g~~			Изменить регистр символов текущей строки.
			{Vi не имеет такой возможности}

							                 *v_~*
{Визуально}~		Изменить регистр символов выделенного текста
			(подробнее о {Визуально} см. |визуальный_режим|).
			{Vi не имеет такой возможности}

							                 *v_U*
{Визуально}U		Изменить символы выделенного текста на символы
			верхнего регистра (подробнее о {Визуально} см.
			|визуальный_режим|).
			{Vi не имеет такой возможности}

				            *gU* *uppercase* *верхний_регистр*
gU{перемещение}		Изменить регистр символов текста, над которыми
			произойдёт {перемещение} на верхний.
			{Vi не имеет такой возможности}

			Пример: >

				:map! <C-F> <Esc>gUiw`]a
<			
			Эта привязка работает в режиме Вставки: при нажатии
			CTRL-F слово перед курсором будет набрано в верхнем
			регистре. Этим удобно пользоваться при наборе: слово
			можно вводить в нижнем регистре и затем изменять
			регистр символов на верхний одним движением.
			
gUgU							          *gUgU* *gUU*
gUU			Перевести символы текущей строки в верхний регистр.
			{Vi не имеет такой возможности}

							                 *v_u*
{Визуально}u		Изменить символы выделенного текста на символы нижнего
			регистра (подробнее о {Визуально} см.
			|визуальный_режим|).
			{Vi не имеет такой возможности}

					     *gu* *lowercase* *нижний_регистр*
gu{перемещение}		Изменить регистр символов текста, над которыми
			произойдёт {перемещение} на нижний.
			{Vi не имеет такой возможности}

gugu							          *gugu* *guu*
guu			Перевести символы текущей строки в нижний регистр.
			{Vi не имеет такой возможности}

							          *g?* *rot13*
g?{перемещение}		Зашифровать текст, над которым произойдёт перемещение
			по алгоритму Rot13.
			{Vi не имеет такой возможности}

							                *v_g?*
{Визуально}g?		Зашифровать выделенный текст по алгоритму Rot13
			(подробнее о {Визуально} см. |визуальный_режим|).
			{Vi не имеет такой возможности}

g?g?						 	          *g?g?* *g??*
g??			Зашифровать текущую строку по алгоритму Rot13.
			{Vi не имеет такой возможности}


Сложение и вычитание ~
							              *CTRL-A*
CTRL-A			Добавить [число] к числу или алфавитному символу в
			позиции курсора или после курсора.
			{Vi не имеет такой возможности}

							              *CTRL-X*
CTRL-X			Вычесть [число] из числа или алфавитного символа в
			позиции курсора или после курсора.
			{Vi не имеет такой возможности}

Команды CTRL-A и CTRL-X можно применять к десятичным числам, в том числе со
знаком, беззнаковым восьмеричным и шестнадцатеричным числам, а также к
символам алфавита. Это зависит от значения опции 'nrformats'.

- Если в значении опции 'nrformats' указано "alpha", то Vim будет изменять
  алфавитные символы в позиции курсора или после курсора. Это полезно при
  создании списков, в которых элементы списка отмечаются символами.

- Если в значении опции 'nrformats' указано "hex", то Vim будет считать числа,
  начинающиеся с '0x' или '0X' шестнадцатеричными. Регистр символов в
  полученном в результате сложения или вычитания числе определяется регистром
  крайнего правого символа. Если в данном числе не используются алфавитные
  символы, то Vim пользуется регистром символов, который был установлен
  раннее. 

- Если в значении опции 'nrformats' указано "octal", то Vim будет считать
  числа, начинающиеся с '0' восьмеричными. Все остальные числа считаются
  десятичными и могут сопровождаться знаком минус. Если курсор находится на
  числе, то операция производится над этим числом; в противном случае операция
  производится над числом, расположенном справа от курсора.

Если число начинается с нулей (включая все восьмеричные и шестнадцатеричные
числа), то Vim будет пытаться сохранить количество символов в числе, если это
возможно. CTRL-A с числом "0077" приводит к числу "0100", CTRL-X с числом
"0x100" приводит к числу "0x0ff". Обратите внимание, что если в значении опции
'nrformats' присутствует "octal", то десятичные числа с начальными нулями
невозможны, поскольку они будут неотличимы от восьмеричных чисел.

Команда CTRL-A очень полезна в макросах. Например, для создания нумерованного
списка можно использовать такую последовательность действий:

1. Создать первый элемент списка, убедившись, что он начинается с числа.
2. qa	     - начать запись в буфер 'a'.
3. Y	     - скопировать элемент списка.
4. p	     - вклеить копию элемента под первым.
5. CTRL-A    - увеличить число 
6. q	     - остановить запись
7. <число>@a - повторить копирование, вклейку и увеличение числа заданное
	       <число> раз


СДВИГ СТРОКИ ВЛЕВО ИЛИ ВПРАВО	       *shift-left-right* *сдвиг-влево-вправо*

							                   *<*
<{перемещение}		Сдвинуть строки, указанные в {перемещении}, на
			величину одного 'shiftwidth' влево.
			
							                  *<<*
<<			Сдвинуть заданное [число] строк на величину одного
			'shiftwidth' влево.

							                 *v_<*
{Визуально}[число]<	Сдвинуть выделенные строки на [число] 'shiftwidth'
			влево (подробнее о {Визуально} см.
			|визуальный_режим|).
			{Vi не имеет такой возможности}

							                   *>*
 >{перемещение}		Сдвинуть строки, указанные в {перемещении}, на
			величину одного 'shiftwidth' вправо.

							                  *>>*
 >>			Сдвинуть заданное [число] строк на величину одного
			'shiftwidth' вправо.

							                 *v_>*
{Визуально}[число]>	Сдвинуть выделенные строки на [число] 'shiftwidth'
			вправо (подробнее о {Визуально} см.
			|визуальный_режим|).
			{Vi не имеет такой возможности}

							                  *:<*
:[диапазон]<		Сдвиг строк, указанных в [диапазоне] на величину
			одного 'shiftwidth' влево. Для сдвига на величину
			нескольких 'shiftwidth' добавьте требуемое количество
			символов '<'.
			
:[диапазон]< {число}	Сдвиг указанного {числа} строк на величину одного
			'shiftwidth' влево, начиная со строки, на которую
			указывает [диапазон] (по умолчанию: текущая строка,
			см. |командная_строка-диапазоны|). Для сдвига на
			величину нескольких 'shiftwidth' добавьте требуемое
			количество символов '<'.

:[число]le[ft] [отступ] Выравнивание строк, заданных [диапазоном], по левому
			краю. Отступ в этих строках задаётся параметром
			[отступ] (по умолчанию: 0).
			{Vi не имеет такой возможности}

							                  *:>*
:[диапазон]>		Сдвиг строк, указанных в [диапазоне] на величину
			одного 'shiftwidth' вправо. Для сдвига на величину
			нескольких 'shiftwidth' добавьте требуемое количество
			символов '>'.

:[диапазон]> {число}	Сдвиг указанного {числа} строк на величину одного
			'shiftwidth' вправо, начиная со строки, на которую
			указывает [диапазон] (по умолчанию: текущая строка,
			см. |командная_строка-диапазоны|). Для сдвига на
			величину нескольких 'shiftwidth' добавьте требуемое
			количество символов '>'.

Команды ">" и "<" очень удобны для изменения отступов в программном коде.
Значение опции 'shiftwidth' следует установить равным количеству пробелов,
которые будут добавлены или удалены при использовании этих команд. Обычно
значение этой опции равно 8, но вы можете установить и меньшее значение для
получения меньших сдвигов, например, 3. Сдвиг влево останавливается, когда
строка больше не может быть сдвинута. Сдвиг вправо не затрагивает пустые
строки.

Если включена опция 'shiftround', то величина отступа округляется до значения,
кратного величине 'shiftwidth'.

Если включена опция 'smartindent' или включена опция 'cindent' и в значении
опции 'cinkeys' содержится '#', то сдвиг вправо не затрагивает строки,
начинающиеся с '#' (поскольку предполагается, что это команды препроцессора
языка C, которые должны начинаться в первой колонке).

Если опция 'expandtab' выключена (по умолчанию), то Vim использует как можно
больше символов <Tab>, чтобы отобразить отступ. Для замены отступов,
выполненных с помощью пробелов, аналогичными, но выполненными преимущественно
с помощью символов <Tab>, используйте команду ">><<". Если опция 'expandtab'
включена, то Vim использует для отступов только пробелы. В этом случае команда
">><<" может использоваться для замены символов табуляции <Tab> на пробелы.
Этой же цели может служить и команда ":retab!".

Для перемещения строки на величину нескольких 'shiftwidth', используйте
Визуальный режим или команды, начинающиеся с ":". Например: >

	Vjj4>		переместить три строки на 4 отступа вправо
	:<<<		переместить текущую строку на 3 отступа влево
	:>> 5		переместить 5 строк на 2 отступа вправо
	:5>>		переместить строку 5 на 2 отступа вправо

==============================================================================
4. Сложные изменения			  *complex-change* *сложные_изменения*

						         *!* *filter* *фильтр*
!{перемещение}{фильтр}	Пропустить строки текста, над которыми произойдёт
			{перемещение} через внешнюю программу-{фильтр}.

							                  *!!*
!!{фильтр}		Пропустить заданное [число] строк через внешнюю
			программу-{фильтр}.

							                 *v_!*
{Визуально}!{фильтр}	Пропустить выделенные строки через внешнюю
			программу-{фильтр} (подробнее о {Визуально} 
			см. |визуальный_режим|).
			{Vi не имеет такой возможности}

:{диапазон}![!]{фильтр} [!][аргумент]                             *:диапазон!*
			Пропустить строки, на которые указывает {диапазон}
			через внешнюю программу-{фильтр}. Vim позволяет
			добавить необязательный [аргумент] для программы.
			Вывод фильтра сохраняется во временный файл, который
			затем считывается в буфер. Vim использует опцию
			'shellredir' для перенаправления вывода фильтра во
			временный файл.
			Если в значении опции 'cpoptions' включён флаг 'R', то
			отметки в отфильтрованных строках будут удаляться,
			если не используется команда |:keepmarks|. Например:
>
				:keepmarks '<,'>!sort
<
			Если количество строк после выполнения команды-фильтра
			оказывается меньше, чем исходное количество строк, то
			отметки в исчезнувших строках удаляются в любом
			случае.

							                   *=*
={перемещение}		Пропустить строки, над которыми произойдёт
			{перемещение} через внешнюю программу, на которую
			указывает значение опции 'equalprg'. Если значение
			опции 'equalprg' не задано (по умолчанию), то
			используется внутренняя функция форматирования
			отступов |C-отступы|. Однако, если задано значение
			опции 'indentexpr', то оно будет использоваться вместо
			внутренней функции |отступы-выражения|.

							                  *==*
==			Пропустить указанное [число] строк через фильтр, как
			это делается с помощью команды ={перемещение}.

							                 *v_=*
{Визуально}=		Пропустить выделенные строки через фильтр, как это
			делается с помощью команды ={перемещение}.
			{Vi не имеет такой возможности}

Фильтр - это программа, которая принимает текст на стандартном вводе,
производит над ним какие-либо действия и отправляет результат на стандартный
вывод. Команды, приведённые выше, могут использоваться для работы с такими
программами. Примерами фильтров являются программа "sort", которая сортирует
строки по алфавиту, "indent", которая служит для форматирования файлов с
исходным кодом на языке C (не все версии программы "indent" являются
фильтрами). Опция 'shell' служит для указания оболочки, которую Vim использует
для выполнения команды-фильтра (см. также справку по опции 'shelltype').
Команды, работающие с фильтрами, можно повторять с помощью ".". Vim не
распознаёт комментарии (начинающиеся с '"') после команды :!.

						      *:s* *:su* *:substitute*
:[диапазон]s[ubstitute]/{шаблон}/{строка}/[&][c][e][g][p][r][i][I] [число]
			Для каждой строки в [диапазоне] заменить соответствие
			{шаблону} на указанную {строку}.
			О шаблонах см. |шаблон|.
			{строка} может быть строкой текста или специальной
			строкой; см. |спецсимволы_для_замены|.
			Если [диапазон] и [число] не указаны, то замена
			происходит только в текущей строке. 
			Если указано [число], то замена происходит в заданном
			числе строк, начиная с последней строки [диапазона].
			Если [диапазон] не указан, то замена происходит
			начиная с текущей строки.
			См. также |командная_строка-диапазоны|.
			Подробнее о флагах см. |:s_флаги|.

:[диапазон]s[ubstitute] [c][e][g][p][r][i][I] [число]
:[диапазон]&[&][c][e][g][p][r][i][I] [число]			          *:&*
			Повторить предыдущую команду :substitute с тем же
			шаблоном и строкой для замены, но с другими флагами
			или без флагов (см. |:s_флаги|).
			Обратите внимание, что после команды ":substitute"
			в данном случае нельзя использовать флаг '&',
			поскольку он воспринимается как разделитель шаблона.
			Пробел между ":substitute" и флагами 'c', 'g' и 'r' не
			обязателен, но в сценариях пробел лучше всё-таки
			вставлять, чтобы не было путаницы.

:[диапазон]~[&][c][e][g][p][r][i][I] [число]			          *:~*
			Повторить предыдущую команду замены с той же строкой
			для замены, но в качестве шаблона использовать
			последний шаблон для поиска. Это похоже на
			использование ":&r". Подробнее о флагах см. ниже
			|:s_флаги|.

						                           *&*
&			Синоним для ":s//~/" (повторить последнюю замену).
			Обратите внимание, что флаги не запоминаются, поэтому
			команда может работать с некоторыми отличиями. Для
			того, чтобы повторить команду вместе с флагами, можно
			пользоваться ":&&".

						                          *g&*
g&			Синоним для ":%s//~/&" (повторить последнюю замену на
			всех строках с теми же флагами).
			Мнемоника: global substitute ("глобальная замена").
			{Vi не имеет такой возможности}

						            *:snomagic* *:sno*
:[диапазон]sno[magic] ...	
			То же, что и ":substitute", но с использованием
			'nomagic'.
			{Vi не имеет такой возможности}

						               *:smagic* *:sm*
:[диапазон]sm[agic] ...	
			То же, что и ":substitute", но с использованием
			'magic'.
			{Vi не имеет такой возможности}

					               *:s_flags* *|:s_флаги|*
С командами замены можно использовать следующие флаги:

[&]	Это должен быть первый флаг в списке. Он позволяет скопировать флаги,
	которые были использованы в предыдущей команде замены. Примеры: >

		:&&
		:s/this/that/&
		
<	Обратите внимание, что ":s" и ":&" не сохраняют флаги.	
	{Vi не имеет такой возможности}

								        *:s_c*
[c]	Требовать подтверждения для каждой замены. Vim подсвечивает строку с
	найденным соответствием (при помощи |hl-IncSearch|). Далее вы можете
	ввести:
	    
	    'y'	    заменить данное соответствие
	    'l'	    заменить данное соответствие и прекратить замену ("last",
		    "последнее").
	    'n'	    пропустить данное соответствие
	    <Esc>   прекратить замену
	    'a'	    заменить данное и все последующие соответствия
		    {Vi не имеет такой возможности}
	    'q'	    прекратить замену
		    {Vi не имеет такой возможности}
	    CTRL-E  прокрутка экрана вверх
		    {Vi не имеет такой возможности; доступно только в том
		    случае, если Vim скомпилирован с особенностью
		    +insert_expand}
	    CTRL-Y  прокрутка экрана вниз
		    {Vi не имеет такой возможности; доступно только в том
		    случае, если Vim скомпилирован с особенностью
		    +insert_expand}
		    
	Если включена опция 'edcompatible', то Vim запоминает флаг [c] и
	переключает его всякий раз, когда он используется, однако при замене с
	новым шаблоном поиска происходит его сброс.
	{Vi позволяет использовать только 'y' или 'n', а также не может
	подсвечивать соответствия}

[e]     Если соответствий заданному шаблону не обнаружено, то сообщение об
	ошибке не будет выдаваться. При этом будет продолжено выполнение
	сценария или привязки, в которых используется команда замены, так, как
	будто никакой ошибки и не было. Этот флаг полезен в тех случаях, когда
	нежелательно, чтобы сообщение "Шаблон не найден" мешало выполнению
	привязки. В то же время, Vim не подавляет следующие сообщения об
	ошибках:

	        Регулярные выражения не могут быть разделены буквами
		После \ должен быть один из символов /, ?, или &
		Нет предыдущего шаблона для замены
		Лишние символы
		Прервано

	{Vi не имеет такой возможности}

[g]	Заменить все соответствия в строке. Без указания данного флага замена
	производится замена только первого соответствия в каждой строке. Если
	включена опция 'edcompatible', то Vim запоминает этот флаг и
	переключает его при каждом использовании, но сбрасывает в случае
	использования нового шаблона поиска. При включённой опции 'gdefault'
	этот флаг устанавливается по умолчанию, а указание флага [g] в команде
	замены отключает его.

[i]	Не обращать внимания на регистр символов в шаблоне. Опции 'ignorecase'
	и 'smartcase' не используются.
	{Vi не имеет такой возможности}

[I]	Обращать внимание на регистр символов в шаблоне. Опции 'ignorecase' и
	'smartcase' не используются.
	{Vi не имеет такой возможности}

[p]	Напечатать строку, содержащую последнюю замену.
	{Vi не имеет такой возможности}

[r]	Флаг имеет смысл только в командах ":&" или ":s" без параметров. ":&r"
	работает так же, как и ":~": если шаблон поиска не указан, то в
	качестве шаблона используется предыдущий шаблон поиска вместо шаблона
	из предыдущей команды замены или команды ":global". Если последней
	командой, в которой использовался шаблон для поиска, была команды
	замены или ":global", то флаг не оказывает никакого влияния. Если же
	такой командой была команда поиска, например "/", то используется
	шаблон из этой команды.
	В команде ":s" с параметрами это происходит в любом случае: >
	
		:s/синий/красный/
		/зелёный
		:s//красный/   или  :~   или  :&r
<	
	Последняя команда будет заменять "зелёный" на "красный". >

		:s/синий/красный/
		/зелёный
		:&
<
	Последняя команда будет заменять "синий" на "красный".
	{Vi не имеет такой возможности}

Обратите внимание, что флага, который изменял бы "волшебность" шаблона
("magic") не существует. Вместо этого используются специальные команды. Дело в
том, что состояние флагов выясняется уже после прочтения шаблона, а для того,
чтобы прочитать шаблон правильно, необходимо знать, волшебный он или нет --
проблема яйца и курицы, одним словом. 

Если {шаблон} для команды замены не указан, то команда использует шаблон из
последней использованной команды замены или команды ":global". Флаг [r]
позволяет использовать шаблон из последней команды замены, команды ":global"
или команды поиска. 

Для совместимости с Vi допустимы два исключения из правил:
"\/{строка}/" и "\?{строка}?" делают то же, что и "//{строка}/r".
"\&{строка}&" делает то же, что и "//{строка}/".

							                *E146*
Вместо символа '/', который используется для разделения шаблона и строки
замены, можно пользоваться любым другим символом, кроме символов алфавита,
цифр, '\', '"' или '|'. Это бывает полезно, когда необходимо включить символ
'/' в шаблон поиска или в строку замены. Например: >

	:s+/+//+

Подробнее о шаблонах читайте здесь: |шаблон|.

		         *sub-replace-special* *:s\=* *спецсимволы_для_замены*
Если {строка} начинается с "\=", то она рассматривается как выражение, 
см. |замена-выражение|. В противном случае символы в {строке} имеют
специальное значение:

волшебные   не волшебные    действие    ~

  &	      \&	    заменяется на найденное соответствие        *s/\&*
 \&	      &	            заменяется на &
         \0		    заменяется на найденное соответствие   *\0* *s/\0*
         \1		    заменяется на соответствие в первой паре () *s/\1*
         \2	            заменяется на соответствие во второй
			    паре () 				        *s/\2*
         ..	            ..	 				        *s/\3*
         \9	            заменяется на соответствие в девятой 
			    паре ()				        *s/\9*
  ~	      \~	    заменяется на {строку} из предыдущей 
			    команды замены                                *s~*
 \~	      ~		    заменяется на ~			        *s/\~*
	\u		    следующий символ переводится в верхний 
			    регистр					*s/\u*
	\U		    следующие символы переводятся в верхний 
			    регистр, вплоть до символа \E		*s/\U*
	\l		    следующий символ переводится в нижний 
			    регистр					*s/\l*
	\L		    следующие символы переводятся в нижний 
			    регистр, вплоть до символа \E		*s/\L*
	\e		    завершает \u, \U, \l и \L 
			    (ЗАМЕЧАНИЕ: не <Esc>!)			*s/\e*
	\E		    завершает \u, \U, \l и \L			*s/\E*
	<CR>		    разделить строку в данном месте на две
			    (<CR> вводится как CTRL-V <Enter>)	       *s<CR>*
	\r		    то же				        *s/\r*
	\<CR>		    вставить символ возврата каретки (CTRL-M)		
			    (<CR> вводится как CTRL-V <Enter>)	     *s/\<CR>*
	\n		    вставить символ <NL> (в файле <NUL>)    
			    (не переносит строку)		        *s/\n*
	\b		    вставить символ <BS>			*s/\b*
	\t		    вставить символ <Tab>			*s/\t*
	\\		    вставить символ обратной косой черты        *s/\\*
	\x		    здесь x это любой символ, не перечисленный выше:
			    зарезервировано для будущего использования

Примеры: >

  :s/а\|б/xxx\0xxx/g		 заменяет "а б"	     на "xxxаxxx xxxбxxx"
  :s/\([абв]\)\([деж]\)/\2\1/g	 заменяет "ае еа бж" на "еа еа жб"
  :s/абвгд/абв^Mгд/		 заменяет "абвгд"    на "абв", "гд" (две
							строки)
  :s/$/\^M/			 заменяет "абвгд"    на "абвгд^M"

Замечание: в предыдущих версиях символ CTRL-V обрабатывался особым способом.
В дальнейшем это было устранено, поскольку нарушало совместимость с Vi. Вместо
этого следует пользоваться символом обратной косой черты.

команда		текст	результат ~
:s/aa/a^Ma/	aa	a<перенос-строки>a
:s/aa/a\^Ma/	aa	a^Ma
:s/aa/a\\^Ma/	aa	a\<перенос-строки>a

(для ввода ^M вам потребуется ввести CTRL-V <CR>)

Нумерация "\1", "\2" и т.д. осуществляется на основании порядка, в котором
"\(" впервые встречается в шаблоне (слева направо). Если обнаруживается
несколько соответствий для группы скобок, то в качестве "\1", "\2" и т.д.
используется последнее обнаруженное соответствие. Например: >

  :s/\(\(a[a-d] \)*\)/\2/      изменяет "aa ab x" на "ab x"

При использовании скобок в сочетании с '|', как, например, в шаблоне
\([ab]\)\|\([cd\), соответствие не будет найдено либо для первого, либо для
второго шаблона в скобках, поэтому либо \1, либо \2 будет пустым. Например: >

  :s/\([ab]\)\|\([cd]\)/\1x/g   изменяет "a b c d"  на "ax bx x x"
<
Замена с помощью выражений         *sub-replace-expression* *замена-выражение*

Если строка для замены начинается с символов "\=", то остальная часть строки
рассматривается как выражение, которое должно быть вычислено. Имейте только в
виду, что это не работает рекурсивно: функция substitute() внутри выражения не
может использовать "\=" в строке замены.

В этом случае особый смысл символов, упомянутых в разделе
|спецсимволы_для_замены| не играет роли, за исключением символов "<CR>",
"\<CR>" и "\\". Иными словами, в выражении необходимо использовать двойную
обратную косую, чтобы получить одну обратную косую черту, для вставки символа
<CR> необходимо экранировать его обратной косой, а для вставки переноса строки
использовать <CR> как есть.

Для удобства также разрешено использование <NL> в качестве символа переноса
строки. Для вставки настоящего символа <NL> (представленного в файле символом
NUL) следует предварять <NL> символом обратной косой черты.

К тексту, соответствующему шаблону, можно обратиться с помощью "submatch(0)".
Текст, который соответствует первой паре () в шаблоне, доступен с помощью
"submatch(1)", и так далее для всех элементов соответствия внутри пары ().

Будьте осторожны: символ-разделитель не должен появляться в выражении! 
Вы можете использовать в качестве разделителя другие символы, например, "@" 
или ":". В то же время, результат выражения вполне может содержать
символ-разделитель.

Например: >

	:s@\n@\="\r" . expand("$HOME") . "\r"@
<
Эта команда выполняет замену символов конца строки новой строкой, содержащей
значение переменной окружения $HOME.

						          *:pro* *:promptfind*
:promptf[ind] [строка]
			Вывести диалоговое окно для поиска. Если указана
			[строка], то она используется в качестве строки для
			поиска по умолчанию.
			{доступно только в версиях с графическим интерфейсом
			для Win32, Motif и GTK}

						      *:promptr* *:promptrepl*
:promptr[epl] [строка]
			Вывести диалоговое окно для поиска и замены. Если
			указана [строка], то она используется в качестве
			строки для поиска по умолчанию.
			{доступно только в версиях с графическим интерфейсом
			для Win32, Motif и GTK}

							       *:ret* *:retab*
:[диапазон]ret[ab][!] [новая_величина_табуляции]
			Заменить все последовательности пробелов, содержащие
			символ <Tab> новыми, используя указанное значение
			табуляции. Если новое значение величины табуляции не
			указано, или равняется нулю, то Vim использует текущее
			значение опции 'tabstop'.
			Текущее значение опции 'tabstop' всегда используется
			для вычисления величины существующих символов
			табуляции. 
			Добавление ! заставляет Vim также заменять строки,
			состоящие исключительно из пробелов, на символы
			табуляции там, где это возможно.
			При включённой опции 'expandtab' Vim заменяет все
			символы табуляции на соответствующее число пробелов.
			Эта команда переопределяет значение опции 'tabstop',
			используя указанное новое значение. В случае, если она
			применяется ко всему файлу, что происходит по
			умолчанию, она не приводит к каким-либо видимым
			изменениям.
			Осторожно: эта команда изменяет символы <Tab> в
			строках в программах на языке C. Чтобы этого не
			происходило, лучше всего использовать в таких случаях
			"\t" (это вообще полезная привычка).
			":retab!" также может заменять последовательность
			пробелов символами <Tab>, что может привести к
			проблемам в работе функции printf().
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+ex_extra|}

					        *retab-example* *retab-пример*
Приведём пример использования автокоманд и команды ":retab" для редактирования
файла, который был сохранён с использованием ширины табуляции равной 8, но
редактировался с табуляцией, равной 4. Предупреждение: пробелы внутри строк
могут изменяться! См. также справку по опции 'softtabstop'. >

  :auto BufReadPost	*.xx	retab! 4
  :auto BufWritePre	*.xx	retab! 8
  :auto BufWritePost	*.xx	retab! 4
  :auto BufNewFile	*.xx	set ts=4

==============================================================================
5. Копирование и перемещение текста      *copy-move* *копирование-перемещение*

						             *quote* *кавычка*
"{a-zA-Z0-9.%#:-"}	Использовать регистр {a-zA-Z0-9.%#:-"} для следующей
			операции удаления, копирования или вклейки текста
			(символы в верхнем регистре используются для
			добавления текста при удалении и копировании).
			Регистры {.%#:} работают только с командами вклейки.

							   *:reg* *:registers*
:reg[isters]		Показать содержимое всех цифровых и именных регистров.
			{Vi не имеет такой возможности}

:reg[isters] {параметр}	Показать содержимое цифровых и именных регистров,
			которые перечислены в {параметре}. Например: >

				:dis 1a
				
<			показывает содержимое регистров '1' и 'a'. 
			В {параметре} допустимо использование пробелов.
			{Vi не имеет такой возможности}

							      *:di* *:display*
:di[splay] [параметр]	То же, что и ":registers".
			{Vi не имеет такой возможности}

						      *y* *yank* *копирование*
["x]y{перемещение}	Скопировать текст, над которым произойдёт
			{перемещение} [в регистр x]. Если нет символов,
			которые могли бы быть скопированы (например, при
			выполнении команды "y0" в колонке 1), то при наличии
			флага 'E' в значении опции 'cpoptions' будет выдано
			сообщение об ошибке.
			
							                  *yy*
["x]yy			Скопировать указанное [число] строк [в регистр x]
			|построчно|.

							                   *Y*
["x]Y			Скопировать указанное [число] строк [в регистр x]
			(команда-синоним для yy, выполняется |построчно|).
			Если вам больше нравится, чтобы команда "Y" копировала
			символы от позиции курсора до конца строки, что более
			логично, но нарушает требование совместимости с Vi, то
			используйте привязку ":map Y y$".

							                 *v_y*
{Визуально}["x]y	Скопировать выделенные строки [в регистр x] (подробнее
			о {Визуально} см. |визуальный_режим|).
			{Vi не имеет такой возможности}

							                 *v_Y*
{Визуально}["x]Y	Скопировать выделенные строки [в регистр x] (подробнее
			о {Визуально} см. |визуальный_режим|).
			{Vi не имеет такой возможности}

							          *:y* *:yank*
:[диапазон]y[ank] [x]	Скопировать указанный [диапазон] строк [в регистр x].

:[диапазон]y[ank] [x] {число}
			Скопировать заданное {число} строк, начиная с
			последней строки в [диапазоне] (по умолчанию: текущая
			строка, см. |командная_строка-диапазоны|), 
			[в регистр x].

						    *p* *put* *вклейка* *E353*
["x]p			Вклеить текст [из регистра x] после курсора указанное
			[число] раз.
			{Vi не предоставляет возможности указывать число}

							                   *P*
["x]P			Вклеить текст [из регистра x] перед курсором указанное
			[число] раз.
			{Vi не предоставляет возможности указывать число}

					 *<MiddleMouse>* *<СредняяКнопкаМыши>*
["x]<MiddleMouse>	Вклеить текст из регистра перед курсором указанное
			[число] раз. Если регистр не указан, то используется
			регистр "*. Мышь работает только в том случае, если
			значение опции 'mouse' равно 'n' или 'a'.
			{Vi не имеет такой возможности}
			Если у вас есть мышь с колесом и вы часто случайно
			вклеиваете текст средней кнопкой, то этого можно
			избежать при помощи следующих привязок: >

				:map <MiddleMouse> <Nop>
				:imap <MiddleMouse> <Nop>
<
			При желании вы можете также отменить привязки,
			использующие несколько щелчков мыши, 
			см. |двойной_щелчок|.

							                  *gp*
["x]gp			То же, что и "p", но курсор помещается сразу после
			вклеенного текста.
			{Vi не имеет такой возможности}

							                  *gP*
["x]gP			То же, что и "P", но курсор помещается сразу после
			вклеенного текста.
			{Vi не имеет такой возможности}

							          *:pu* *:put*
:[строка]pu[t] [x]	Вклеить текст [из регистра x] после указанной [строки]
			(по умолчанию: после текущей строки). Эта команда
			всегда выполняется |построчно|, её можно использовать
			для построчного вклеивания скопированного блока.
			В качестве регистра можно использовать '=' с
			каким-либо выражением. Выражение в этом случае
			продолжается до конца команды. Чтобы символы '|' и '"'
			не вызывали преждевременного прекращения команды, их
			следует экранировать. Например: >

				:put ='path' . \",/test\"

<			Если выражение после '=' не указано, то Vim использует
			предыдущее выражение. Его можно предварительно
			посмотреть по команде ":dis =".

:[строка]pu[t]! [x]	Вклеить текст [из регистра x] перед указанной
			[строкой] (по умолчанию: перед текущей строкой).

["x]]p		    или					*]p* *]<MiddleMouse>*
["x]]<MiddleMouse>	То же, что и "p", но с исправлением отступа в
			соответствии с отступом текущей строки. Мышь работает
			только в том случае, если значение опции 'mouse' равно
			'n' или 'a'.
			{Vi не имеет такой возможности}

["x][P		    или					*[P*
["x]]P		    или					*]P*
["x][p		    или					*[p* *[<MiddleMouse>*
["x][<MiddleMouse>	То же, что и "P", но с исправлением отступа в
			соответствии с отступом текущей строки. Мышь работает
			только в том случае, если значение опции 'mouse' равно
			'n' или 'a'.
			{Vi не имеет такой возможности}

Все эти команды используются для копирования текста из одного места в другое.
Сначала при помощи команд копирования, удаления или изменения текст помещается
в регистр, затем содержимое регистра вставляется в буфер при помощи команды
вклейки. Эти же команды могут использоваться также и для перемещения текста из
одного файла в другой, поскольку Vim сохраняет содержимое регистров при
переходе между буферами (для быстрого перехода между двумя файлами используйте
команду CTRL-^).

				   *построчный_регистр* *посимвольный_регистр*
				  *linewise-register* *characterwise-register*
Команду вклейки можно повторить с помощью команды "." (за исключением команды
:put) или отменить. Если команда, которая использовалась для копирования
текста, была |построчно|й, то Vim вклеивает фрагмент текста под ("p") или над
("P") строкой, в которой находится курсор. В противном случае Vim вставляет
текст после ("p") или перед ("P") курсором. По команде ":put" Vim всегда
вклеивает фрагмент текста в следующей строке. Для быстрой перестановки двух
символов можно пользоваться последовательностью команд "xp". Поменять местами
две строки можно при помощи последовательности "ddp". Два слова можно заменить
местами с помощью последовательности команд "deep" (курсор должен
располагаться в позиции пробела перед первым словом). После выполнения команды
вклейки можно пользоваться командами "']" или "`]" для перемещения курсора в
конец вклеенного текста, а для перемещения курсора в начало используйте
команды "'[" или "`[".

		      *вклейка-визуальный_режим* *put-Visual-mode* *v_p* *v_P*
При использовании команды вклейки, такой как |p| или |P| в Визуальном режиме,
Vim попытается заменить выделенный текст содержимым регистра. Успех такой
операции зависит от типа выделения и типа фрагмента, который хранится в
регистре. Если выделение является блоковым, то это также зависит от размера
блока и от того, находятся ли углы блока на существующих символах (дело в том,
что в действительности при этом сначала вклеивается содержимое регистра после
выделенного блока, а уже затем выделенный блок удаляется).

				       *blockwise-register* *блоковый_регистр*
При использовании режима Визуального блока для помещения текста в регистр,
текстовый блок будет вклеиваться до ("P") или после ("p") колонки, в которой
находится курсор в текущей и последующих строках. Vim позаботится о том, чтобы
весь блок располагался в одной и той же колонке. Благодаря этому, вклеенный
текст будет выглядеть так же, как и в момент копирования или удаления. Vim
может заменить некоторые символы <Tab> на пробелы для достижения такого
эффекта. В то же время, если ширина блока не кратна ширине табуляции, а текст
после вставленного блока содержит символы <Tab>, выравнивание этого текста
может быть нарушено.

Обратите внимание, что после команды посимвольного копирования Vim оставляет
курсор на первом символе скопированного фрагмента, который находится ближе к
началу буфера. Это приводит к тому, что команда "yl" не перемещает курсор, а
команда "yh" перемещает курсор на один символ влево. Логика такого поведения
заключается в следующем: в Vi команда "y", за которой следует перемещение в
обратном направлении, не всегда перемещает курсор к первому скопированному
символу, т.к. экран не обновляется. В Vim курсор всегда перемещается к первому
символу, как этого требует Posix.
При выполнении построчного копирования курсор помещается в первую строку, но
колонка, в которой он расположен, не изменяется, поэтому он не обязательно
будет находится в позиции первого скопированного символа.

Существует девять типов регистров:		 *регистры* *registers* *E354*

1. Безымянный регистр ""
2. 10 нумерованных регистров от "0 до "9
3. Регистр небольшого удаления "-
4. 26 именованных регистров от "a до "z или от "A до "Z
5. Четыре регистра только для чтения ":, "., "% и "#
6. Регистр выражения "=
7. Регистры выделения "*, "+ и "~ 
8. Регистр-"чёрная дыра" "_
9. Регистр последнего шаблона для поиска "/


1. Безымянный регистр ""	  *quote_quote* *quotequote* *кавычка_кавычка*

Vim заполняет этот регистр текстом, который был удалён с помощью команд "d",
"c", "s", "x", или скопирован по команде "y", независимо от того, был ли
указан какой-нибудь специальный регистр (например, "xdd). Исключением является
регистр "_: команда "_dd не сохраняет удалённый текст вообще нигде. Vim
использует содержимое этого регистра в любой команде вклейки, которая не
указывает регистр явно. Этот регистр также доступен явно по имени '"', т.е.
вам потребуется ввести две двойные кавычки. Запись в регистр "" приводит к
записи в регистр "0.
{Vi: при переходе к другому файлу содержимое регистров не сохраняется; в Vi
нет регистра '"'}

	                                 *кавычка_число* *кавычка0* *кавычка1* 
		                   *кавычка2* *кавычка3* *кавычка4* *кавычка9*
          *quote_number* *quote0* *quote1* *quote2* *quote3* *quote4* *quote9*


2. Нумерованные регистры от "0 до "9	

Vim заполняет эти регистры фрагментами текста, которые затронуты командами
удаления и копирования. 
   Нумерованный регистр 0 содержит фрагмент от самой последней команды
копирования, если в команде не был указан какой-либо специальный регистр
["x].
   Нумерованный регистр 1 содержит фрагмент от самой последней команды
удаления или изменения текста, если в команде не был указан какой-либо
специальный регистр и удалённый фрагмент был больше, чем одна строка (если
фрагмент меньше строки, то используется регистр небольшого удаления).
Исключение из правила сделано для следующих команд: |%|, |(|, |)|, |`|, |/|,
|?|, |n|, |N|, |{| и |}|. С этими командами всегда используется регистр 1,
поскольку этого требует совместимость с Vi. При этом, если удаление происходит
в пределах строки, то регистр "- также задействуется. 
   С каждым последующим удалением или изменением Vim сдвигает предыдущее
содержимое регистра 1 в регистр 2, регистра 2 - в регистр 3, и т.д.;
предыдущее содержимое регистра 9 утрачивается. 
{Vi: содержимое нумерованных регистров не сохраняется при переходе к другому
файлу; в Vi нет регистра 0}


3. Регистр небольшого удаления "-    *quote_-* *quote-* *кавычка_-* *кавычка-*

Этот регистр содержит фрагмент текста от команды удаления, если этот фрагмент
меньше одной строки, кроме тех случаев, когда в команде явно указан какой-либо
другой регистр ["x].
{Vi не имеет такой возможности}

					            *кавычка_буква* *кавычкаa*
4. Именованные регистры от "a до "z и от "A до "Z       *quote_alpha* *quotea*

Vim заполняет эти регистры только при явном указании. При указании имени
регистра в нижнем регистре, предыдущее содержимое регистра заменяется новым.
При указании имени регистра в верхнем регистре новое содержимое добавляется к
предыдущему содержимому. 


5. Регистры только для чтения ":, "., "% и "#

Регистры '%', '#', ':' и '.' предназначены только для чтения. Их можно
указывать только с командами "p", "P" и ":put", а также с командой CTRL-R.
{Vi не имеет такой возможности}

			       *quote_.* *quote.* *кавычка_.* *кавычка.* *E29*
	".	Содержит последний вставленный текст (тот самый, что
		вставляется по командам CTRL-A и CTRL-@).
		Замечание: с командой CTRL-R в командной строке эта
		возможность работает несколько иначе: вместо вклейки текст
		вставляется с учётом значения опций 'textwidth' и других.

				     *quote_%* *quote%* *кавычка_%* *кавычка%*
	"%	Содержит имя текущего файла.

				     *quote_#* *quote#* *кавычка_#* *кавычка#*
	"#	Содержит имя соседнего файла.

			       *quote_:* *quote:* *кавычка_:* *кавычка:* *E30*
	":	Содержит последнюю выполненную команду из командной строки.
		Этим можно, например, пользоваться для выполнения предыдущей
		команды "@:".
		Команда сохраняется в этом регистре только в том случае, если
		хотя бы один её символ был введён с клавиатуры. Если команда
		выполняется из привязки, то этот регистр не будет затронут. 
                {доступно только в том случае, если Vim скомпилирован с
		особенностью |+cmdline_hist|}


6. Регистр выражения "=		     *quote_=* *quote=* *кавычка_=* *кавычка=*

Это в действительности даже не регистр для хранения текста, а способ
использования выражений в командах, которые используют регистры. Регистр
выражения открыт только для чтения - в него нельзя поместить текст. После
ввода '=' курсор перемещается в командную строку, где можно ввести любое
выражение (см. |выражение|). При этом вам доступны все обычные команды для
редактирования командной строки, включая просмотр истории выражений. Когда
режим ввода командной строки завершается при помощи ввода символа <CR>, то Vim
вычисляет результат выражения. Если режим командной строки завершается
нажатием <Esc>, то Vim оставляет выражение без внимания. Если выражение не
было введено, то Vim использует предыдущее выражение (как по команде "/").
Если регистр "= используется с командой "p", то строка будет разбиваться на
символах <NL>. Если строка заканчивается на <NL>, то регистр воспринимается
как построчный.
{Vi не имеет такой возможности}


7. Регистры выделения "*, "+ и "~ 

Эти регистры используются для сохранения и получения выделенного в графическом
интерфейсе фрагмента текста. См. также |кавычка_звёздочка| и |кавычка+|. Если
системный буфер обмена не работает или недоступен, то вместо этих регистров
используется безымянный регистр. 
{Vi не имеет такой возможности}

Обратите внимание, что на системах, которые используют X11 имеется отличие
между "* и "+. Это различие подробно объясняется в |x11-выделение|. В
MS-Windows использование "* и "+ практически ничем не отличается и идентично
обращению к системному буферу обмена, см. |gui-буфер_обмена|.

			    *quote_~* *quote~* *кавычка_~* *кавычка~* *<Drop>*
Регистр только для чтения "~ сохраняет фрагмент текста, который был перед этим
перетащен с помощью мыши (т.н. операция drag'n'drop). Если что-то было
помещено таким образом в окно редактора Vim, то это что-то помещается в
регистр "~ и происходит извещение редактора отправкой псевдокнопки <Drop>. Эта
кнопка может быть при желании переопределена привязкой; значением по умолчанию
для всех режимов является вставка содержимого регистра "~ в позиции курсора. 
{Vi не имеет такой возможности}
{доступно в данный момент только для версии с графическим интерфейсом GTK и
только в том случае, если Vim скомпилирован с особенностью |+dnd|}

Замечание: Регистр "~ используется только при переноске мышью в редактор Vim
обычного текста. Переноска в редактор списков ссылок URI обрабатывается иначе.


8. Регистр-"чёрная дыра" "_			           *quote_* *кавычка_*

При записи в этот регистр ничего не происходит. Этим можно пользоваться для
удаления фрагмента текста так, чтобы это не задевало обычные регистры. При
чтении из этого регистра ничего не возвращается.
{Vi не имеет такой возможности}


9. Регистр последнего шаблона для поиска "/                 *quote_/* *quote/*
                                                        *кавычка_/* *кавычка/*

Содержит самый последний из использованных шаблон для поиска. Содержимое этого
регистра используется в команде "n" и с опцией 'hlsearch'. В этот регистр
можно записывать информацию с помощью команды ":let", что позволяет заставить
'hlsearch' подсвечивать совсем иные соответствия без фактического выполнения
поиска. В этот регистр нельзя помещать текст командами копирования или
удаления.
{Vi не имеет такой возможности}

							                  *@/*
В регистр можно помещать информацию с помощью команды ":let" |let-@|. Пример:
>
	:let @/ = "the"

Если команда вклейки используется без указания регистра, то Vim использует
регистр, который был заполнен в последнюю очередь (это также содержимое
безымянного регистра). Если вы чувствуете неуверенность, то воспользуйтесь
командой ":dis" для того, чтобы посмотреть, что находится в интересующем вас
регистре (по этой команде выдаётся список всех именованных и нумерованных
регистров; безымянный регистр показывается как '"').

Три нижеследующих команды всегда работают над целыми строками.

:[диапазон]co[py] {адрес}				         *:co* *:copy*
			Скопировать строки, заданные [диапазоном], поместив
			копию под строку, заданную указанным {адресом}.

							                  *:t*
:t			Синоним для команды :copy.

:[диапазон]m[ove] {адрес}			     *:m* *:mo* *:move* *E134*
			Переместить строки, заданные [диапазоном], под строку,
			заданную указанным адресом.

==============================================================================
6. Форматирование текста		         *formatting* *форматирование*


:[диапазон]ce[nter] [ширина]				       *:ce* *:center*
			Выровнять строки в заданном [диапазоне] по центру, в
			колонке с заданной [шириной] (по умолчанию в качестве
			ширины колонки используется значение опции 'textwidth'
			или 80, если значение опции 'textwidth' равно 0).
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+ex_extra|}

:[диапазон]ri[ght] [ширина]					*:ri* *:right*
			Выровнять строки в заданном [диапазоне] по правому
			краю, с заданной [шириной] колонки (по умолчанию в
			качестве ширины колонки используется значение опции
			'textwidth' или 80, если значение опции 'textwidth'
			равно 0).
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+ex_extra|}

							         *:le* *:left*
:[диапазон]le[ft] [отступ]
			Выровнять строки в заданном [диапазоне] по левому
			краю. Отступ строк устанавливается равным указанному
			[отступу] (по умолчанию 0). 
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+ex_extra|}

							                  *gq*
gq{перемещение}		Отформатировать строки, над которыми произойдёт
			перемещение. Значение опции 'textwidth' управляет
			длиной каждой отформатированной строки. Если значение
			опции 'textwidth' равно 0, то отформатированная строка
			будет не больше ширины экрана (максимальная длина
			будет равна 79).
			{Vi не имеет такой возможности}
			Тип форматирования управляется значением опции
			'formatoptions', см. |fo-таблица|.
			ЗАМЕЧАНИЕ: раннее эту функцию выполняла команда "Q".
			Если вам больше нравится использовать эту команду, то
			воспользуйтесь привязкой: >

				:nnoremap Q gq

gqgq							          *gqgq* *gqq*
gqq			Отформатировать текущую строку.
			{Vi не имеет такой возможности}

							                *v_gq*
{Визуально}gq		Отформатировать выделенный текст (подробнее
			о {Визуально} см. |визуальный_режим|).
			{Vi не имеет такой возможности}
                                                                          *gw*
gw{перемещение}		Отформатировать строки, над которыми произойдёт
			перемещение. Почти то же, что и |gq|, но после
			выполнения форматирования курсор возвращается в
			прежнюю позицию в тексте. Кроме того, опция
			'formatprg' не используется.
			{Vi не имеет такой возможности}

Пример: для форматирования текущего абзаца используйте команду:         *gqap*
>
	gqap

Команда "gq" после своего выполнения оставляет курсор в строке, куда курсор
отправляется после совершения перемещения. Это позволяет повторять
форматирование с помощью команды ".". Такая техника отлично работает с
командами "gqj" (форматировать текущую и следующие строки) и "gq}"
(форматировать текст до конца абзаца). Замечание: при включённой опции
'formatprg' "gq" оставляет курсор на первой отформатированной строке (как при
работе с командой-фильтром). 

Если вы желаете после форматирования абзаца продолжить с той же самой
позиции в тексте, что и до выполнения операции форматирования, то используйте
команду:
>
	gwap
 
Чтобы всегда поддерживать абзацы текста в отформатированном состоянии, следует
добавить флаг 'a' к значению опции 'formatoptions', См. |автоформатирование|.

При включённой опции 'autoindent' Vim использует отступ первой строки для всех
последующих строк.

Форматирование не изменяет пустые строки (однако изменяет строки, в которых
есть только пробелы!).

Опция 'joinspaces' используется при склейке строк.

Вы можете установить значение опции 'formatprg' равным имени внешней
программы, которую Vim будет использовать для форматирования текста. При
форматировании текста при помощи внешней программы значение опции 'textwidth'
и других не учитывается.

			          *right-justify* *выравнивание_с_двух_сторон*
В Vim нет встроенной команды для выравнивания текста с двух сторон. Это можно
сделать при помощи внешней программы, например "par" (для форматирования до
конца абзаца можно ввести, например, команду "!}par"), либо установить
значение опции 'formatprg' равным "par".

			        *format-comments* *форматирование-комментарии*
Vim способен форматировать комментарии особым образом. Vim распознаёт
комментарий по специальным символам в начале строки (игнорируя пробелы). При
этом можно использовать три типа комментариев:

- Комментарий, который использует повторяющийся символ в начале каждой строки.
  Примером такого комментария служит комментарий в файлах сценариев оболочки,
  который начинается с символа '#'.
- Комментарий, который начинается со специального символа в первой строке, но
  не в последующих. Примером такого комментария служит этот список, в котором
  каждый элемент начинается с дефиса.
- Комментарий, который состоит из трёх частей, а именно: символы для начала
  комментария, символы для окончания комментария и необязательные символы для
  начала строк внутри комментария. Символы, которые используются в начале,
  середине и конце могут быть разными. Пример такого комментария - комментарий
  в стиле языка C: >

	/*
	 * это комментарий на языке C 
	 */

Значением опции 'comments' является список частей, разделённых запятой. Каждая
часть определяет тип символов комментария. Каждая часть выглядит следующим
образом:

	{флаги}:{строка}

{строка} это буквальный текст, который используется в данном комментария.

{флаги}:
  n	Вложенный комментарий. Допускается вложение смешанных типов
	комментариев. Если в опции 'comments' записано значение "n:),n:>", то
	строка, которая начинается с "> ) >" является комментарием.

  b	После {строки} в комментарии требуется один из символов <Space>, <Tab>
	или <EOL>.

  f	Строка комментария встречается только в первой строке. Символы,
	обозначающие комментарий, не повторяются на последующих строках, но
	при этом сохраняется отступ (например, список элементов).

  s	Начало трёхчастного комментария

  m	Середина трёхчастного комментария

  e	Конец трёхчастного комментария

  l	Выравнивать среднюю часть комментария по левому краю с началом
	комментария или с концом (по умолчанию). Распознаётся только в том
	случае, если используется совместно с 's' или 'e'.

  r	Выравнивать среднюю часть комментария по правому краю с началом
	комментария или с концом. Распознаётся только в том случае, если
	используется совместно с 's' или 'e'.

  O	Указанная строка не используется с командой "O".

  x	Позволяет завершать трёхчастный комментарий набором последнего символа
	конца комментария в качестве первого символа на новой строке, если
	средняя часть комментария уже была подставлена автоматически.
	Подробнее см. ниже.

  {цифры}
	При использовании совместно с 's' или 'e': добавить дополнительный
	отступ для средней части. Это может потребоваться для выравнивания
	средней части по левому краю с начальной или конечной частью
	комментария с последующим добавлением дополнительного отступа.

  -{цифры}
	То же, что и {цифры}, но отступ не добавляется, а уменьшается. Это
	работает только в том случае, если уже существует отступ в начальной
	или конечной части, который можно убрать.

Если строка не имеет флагов 'f', 's', 'm' или 'e', то Vim предполагает, что
символы комментария повторяются в начале каждой строки комментария. Поле
флагов может быть пустым.

Любой пробел в тексте перед {строкой} и после {строки} является частью
{строки}, поэтому не следует включать в строку комментария пробелы, если они
не являются обязательной частью комментария.

Если начало одного комментария является частью другого, то эту часть следует
указывать после целого. Например, чтобы описать в качестве комментариев как
"-", так и "->", используйте >

	:set comments=f:->,f:-

Трёхчастный комментарий должен всегда описываться в таком порядке: начало
комментария, средняя часть и конец комментария, без описания других частей
между ними. Пример трёхчастного комментария: >

	sr:/*,mb:*,ex:*/

В этом примере, в частности, описан комментарий в стиле языка C. Чтобы
избежать ошибочного распознавания строки вроде "*ptr" в качестве комментария,
средняя часть включает флаг 'b'. В трёхчастных комментариях Vim проверяет
текст после начала и средней части в поисках конца комментария. Если Vim
обнаруживает конец комментарий, то на следующей строке комментарий не
продолжается. Трёхчастные комментарии должны иметь среднюю часть, поскольку
иначе Vim не сможет распознать среднюю часть комментария.

Обратите внимание на использование флага "x" в приведённом выше определении
трёхчастного комментария. После того как вы нажмёте клавишу <Return> внутри
комментария в стиле языка C, Vim вставит в текст символы средней части
комментария, например " * ". Для завершения ввода комментария достаточно
просто ввести символ "/" перед вводом любого другого текста на новой строке.
При этом произойдёт замена средней части комментария на конечную часть
комментария и на строке останется только " */". Иными словами, вам не
потребуется предварительно нажимать кнопку <Backspace>.

Примеры: >

   "b:*"	Включает строки, начинающиеся с "*", кроме случая, если после
		"*" следует непробельный символ. Это позволяет избежать
		ситуации, при которой разъименование указателя ("*str")
		воспринимается как комментарий.
   "n:>"	Включает строки, которые начинаются с ">", ">>", ">>>" и т.д.
   "fb:-"	Форматирование списка, который начинается с "- "

По умолчанию включается "b:#". Это значит, что строка, которая начинается с
"#include" не воспринимается как комментарий, однако строка, которая
начинается с "# define" будет считаться комментарием. 

Зачастую выравнивание по правому краю может быть заменено на выравнивание по
левому краю с помощью дополнительного пробела. Например, в комментариях в
стиле Javadoc, этим обстоятельством вполне можно пользоваться (при
использовании ":set" перед пробелом вставляется косая черта): >

	s1:/*,mb:*,ex:*/

Обратите внимание, что в начальной части указан отступ, поэтому средняя часть
выравнивается по левому краю с начальной частью, а затем добавляется один
символ. Это позволяет выравнивать по левому краю начальную и среднюю часть в
комментариях следующего вида: >

	/**
	 * комментарий
	 */

{доступно только в том случае, если Vim скомпилирован с особенностью
|+comments|}

						       *fo-table* *fo-таблица*
Опция 'formatoptions' может быть использована для контроля над тем, как Vim
форматирует текст. Значение опции 'formatoptions' представляет собой строку,
которая может содержать любой из перечисленных ниже символов. По умолчанию
значением этой опции является строка "tcq". Для удобочитаемости символы в
строке можно разбивать запятыми.

символ	значение в опции 'formatoptions'    ~

t	Автоматический перенос строки с использованием значения опции
	'textwidth' (кроме комментариев).
	
c	Автоматический перенос строки комментария с использованием значения
	опции 'textwidth', с автоматической подстановкой символов комментария.
	
r	Автоматически подставлять символы комментария после ввода <Enter> в
	режиме Вставки.
	
o	Автоматически подставлять символы комментария после ввода 'o' или 'O'
	в Обычном режиме.
	
q	Позволять форматирование комментариев по команде "gq".
	Замечание: форматирование не затрагивает пустые строки и строки,
	которые содержат только символ комментария. Новый абзац начинается
	после такой строки или при изменении начальных символов комментария.
	
w	Пробел в конце строки означает, что абзац продолжается в следующей
	строке. Строка, которая заканчивается непробельным символом, завершает
	абзац.
	
a	Автоматическое форматирование абзацев. Всякий раз, когда вставляется
	или удаляется текст, происходит форматирование абзаца. См. также
	|автоформатирование|.
	Если указан флаг 'c', то это происходит только для абзацев с
	комментариями.
	
n	Распознавать нумерованные списки при форматировании текста. Каждая
	следующая строка элемента списка использует отступ текста после числа.
	Число может сопровождаться символами '.', ':', ')', ']' или '}'.
	Обратите внимание, что также должна быть включена и опция
	'autoindent'. Это не совсем хорошо работает в сочетании с флагом "2".
	Пример: >

		1. первый элемент
		   переносится
		2. второй элемент

2	При форматировании текста использовать отступ второй строки абзаца для
	всех последующих строк абзаца, вместо отступа первой строки. Это
	позволяет вводить абзацы, в которых первая строка имеет отступ,
	отличный от отступа остальных строк. Обратите внимание, что также
	должна быть включена и опция 'autoindent'. Пример: >

			первая строка абзаца
		вторая строка того же абзаца
		третья строка.

v	Vi-совместимый автоматический перенос строки в режиме Вставки: строка
	переносится только на пробелах, введённых во время текущей операции
	вставки. (Замечание: это не совсем 100%-совместимо с Vi. Дело в том,
	что в Vi имеется ряд глюков, или "неожиданных особенностей" в этой
	области. Vi использует вместо колонок строки колонки экрана.)

b	То же, что и 'v', но автоматический перенос происходит только в том
	случае, если вы вводите пробел перед полем или в поле переноса. Если
	в начале вставки строка длиннее, чем значение опции 'textwidth', либо
	если вы не ввели пробел перед колонкой, определяемой значением опции
	'textwidth', то Vim не делает автоматический перенос строки. 
	
l	Длинные строки не разбиваются в режиме Вставки: если в начале режима
	Вставки строка была длиннее, чем значение опции 'textwindth', то Vim
	не будет автоматически переносить эту строку.
	
m	Переносить строку на мультибайтных символах с кодом более 255. Это
	полезно при наборе на языках с иероглифическим письмом, в которых
	каждый символ является словом. 
	
M	При склейке строк не вставлять пробел до или после мультибайтного
	символа. Этот флаг отменяет действие флага 'B'.
	
B	При склейке строк не вставлять пробел между двумя мультибайтными
	символами. Этот флаг отменяется флагом 'M'.

1	Не разбивать строку после слова из одного символа. Вместо этого
	строка разбивается перед таким словом, если это возможно.

Флаги 't' и 'c' позволяют указать, как Vim осуществляет автоматический перенос
строк:

значение    действие	~
""	    без автоматического форматирования (для форматирования вручную
	    можно использовать "gq")
"t"	    автоматическое форматирование текста, но не комментариев
"c"	    автоматическое форматирование комментариев, но не текста (хорошо
	    подходит для кода на языке C)
"tc"	    автоматическое форматирование текста и комментариев

Замечание: если значение опции 'textwidth' равно 0, то Vim не выполняет
форматирование, но вставляет начало комментариев в соответствии со значением
опции 'comments'.

Замечание: при включённой опции 'paste' Vim вообще не выполняет форматирование.

Замечание: значение опции 'textwidth' может быть ненулевым даже в том случае,
если Vim не переносит строки автоматически. В этом случае опция 'textwidth'
используется при форматировании вручную с помощью команды "gq".

Если опция 'comments' содержит "/*", "*" и/или "*/", то Vim располагает
встроенными механизмами для ещё более разумного обращения с такими
комментариями. 
Открытие новой строки до или после "/*" или "*/" (при наличии флага 'r' или
'o' в 'formatoptions') вставляет правильное начало строки автоматически. То же
самое происходит и при форматировании или автоматическом переносе строк.
Открытие строки после строки, которая начинается с "/*" или "*" и содержит
"*/", не будет приводить к вставке символов комментария в новой строке, а
отступ новой строки будет наследоваться из строки, которая содержит начало
комментария. Например:

    /* ~
     * Обычный комментарий. ~
     */ ~

    Отступ этой строки такой же, как и у строки, в которой начинается
    комментарий.

Описанные выше возможности действительно впечатляют, особенно в сочетании с
новой командой :autocmd, которая позволяет подготавливать разные настройки для
различных типов файлов.

Несколько примеров:
  для кода на языке C (форматировать только комментарии): >
  
	:set fo=croq
< 
  для почты и конференций новостей (форматировать всё, не подставлять
  символы комментария по команде "o"): >

	:set fo=tcrq
<

Автоматическое форматирование		    *auto-format* *автоформатирование*

Если в значении опции 'formatoptions' присутствует флаг 'a', то текст будет
форматироваться автоматически при каждой вставке или удалении фрагмента
текста. Это хорошо подходит для редактирования абзацев текста. Вот несколько
советов по использованию этой возможности:

- Вам потребуется явно отделять абзацы. Самый простой способ это сделать -
  разделять абзацы пустой строкой. Если абзацы не разделены пустой строкой,
  вам может подойти другой способ -  использование флага 'w' и добавление
  пробела в конце каждой строки абзаца кроме последней. 

- Значение опции 'formatoptions' можно устанавливать на основании типа файла
  (см. |тип_файла|) или для каждого файла в отдельности при помощи
  |режимной_строки|).

- Значение опции 'formatoptions' "aw2tq" позволяет создавать текст с таким
  форматированием: >

	    Раз, два, тpи, четыpе, пять -
	Вышел зайчик погулять.
	    Снижена опасность риска 
	Если в паспорте прописка.

- Флаг 'c' позволяет затрагивать автоматическим форматированием только
  комментарии. Это полезно при редактировании исходного кода.

Несколько предупреждений:

- Если часть текста неправильно разбита на абзацы, то внесение изменений в
  этом фрагменте в любом случае будет приводить к автоматическому
  форматированию. Подумайте о том, чтобы отключить автоматическое
  форматирование: >

	:set fo-=a

- При использовании флага 'w' (пробел на конце строки обозначает продолжение
  абзаца на следующей строке), при удалении последней строки абзаца по команде
  |dd| абзац будет склеен со следующим абзацем в одно целое. 

- Изменённый текст сохраняется для команды отмены. Любое форматирование также
  является изменением. Это значит, что любое действие по форматированию текста
  сохраняет исходное состояние для того, чтобы отмена команды была возможна.
  Это может потребовать большого количества памяти.

- Форматирование длинного абзаца и/или абзаца со сложными отступами может быть
  медленным.

==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
