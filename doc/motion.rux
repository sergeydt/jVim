*motion.txt*    Для Vim version 6.3.  Последнее изменение: 2004 May 13


		      СПРАВОЧНИК ПО VIM - Брам Мооленаар


                                                      *navigation* *навигация*
Перемещение курсора		        *cursor-motions* *перемещение_курсора*

Команды, которые здесь рассматриваются, управляют позицией курсора в файле.
Если новая позиция находится за пределами экрана, то происходит прокрутка
экрана (см. также опции 'scrolljump' и 'scrolloff').

1. Перемещения и операторы		|оператор|
2. Перемещения курсора влево и вправо	|перемещения-влево_вправо|
3. Перемещения курсора вверх и вниз     |перемещения-вверх_вниз|
4. Перемещения по словам	        |перемещения-по_словам|
5. Перемещения по текстовым объектам	|перемещения-по_объектам|
6. Выделение текстовых объектов	        |объект-выделение|
7. Отметки				|отметки-перемещения|
8. Прыжки			        |прыжки-перемещения|
9. Различные перемещения		|перемещения-разное|

Общие замечания:

Для выяснения текущий позиции в файле используйте команду "CTRL-G" |CTRL-G|
или команду "g CTRL-G" |g_CTRL-G|. При включённой опции 'ruler' позиция
курсора постоянно отображается в строке состояния (это немного замедляет
работу Vim).

Опытные пользователи предпочитают перемещаться в тексте при помощи кнопок
hjkl, поскольку они находятся всегда под рукой. Начинающие часто предпочитают
использовать кнопки управления курсором, поскольку они не в курсе, что делают
кнопки hjkl. Запомнить значение этих кнопок достаточно просто: j выглядит как
стрелка, указывающая вниз. 

Опция 'virtualedit' позволяет перемещать курсор в положение, где отсутствуют
набранные символы.

==============================================================================
1. Перемещения и операторы				 *operator* *оператор*

Команды для перемещения могут быть использованы после команд-операторов; в
этом случае команда выполняется над фрагментом текста, над которым
перемещается курсор. Иными словами, команда оператор может быть выполнена для
текста, заключённого между текущим положением курсора и положением курсора
после перемещения. Операторы чаще всего используются для изменения или
удаления текста. В Vim имеются следующие операторы:

	|c|	c	изменение
	|d|	d	удаление
	|y|	y	копирование в регистр (без изменения текста)
	|~|	~	изменение регистра символов (при включённой опции
			  'tildeop')
	|g~|	g~     	изменение регистра символов
	|gu|	gu	перевод в нижний регистр
	|gU|	gU	перевод в верхний регистр
	|!|	!	фильтрование текста с помощью внешней программы
	|=|	=	фильтрование текста с помощью 'equalprg' или
			  выполнение форматирования отступов в стиле C, если
			  значение указанной опции пустое
	|gq|	gq	форматирование текста
	|g?|	g?	кодирование текста по алгоритму ROT13
	|>|	>	сдвиг вправо
	|<|	<	сдвиг влево
	|zf|	zf	определить складку

Если число-приставка указывается и в перемещении, и в операторе, то эти два
число умножаются. Например: команда "2d3w" удаляет шесть слов.

После применения оператора курсор как правило остаётся в начале фрагмента
текста, над которым производилась операция. Например, "yfe" не перемещает
курсор, но "yFe" перемещает курсор влево к символу "e" от позиции, где было
начато копирование. 

		                                 *characterwise* *посимвольно*
		                                        *linewise* *построчно*
Оператор может повлиять как на строки между двумя позициями курсора, так и на
символы. Как правило, за некоторыми исключениями, те перемещения, которые
изменяют строку, где находится курсор, приводят к построчному изменению
текста, а перемещения, которые изменяют позицию курсора в строке, приводят к
посимвольному изменению.

                                             *исключительное* *исключительным*
			                           *exclusive* *исключительно*
			                            *inclusive* *включительно*
Посимвольное перемещение может быть включительным или исключительным. При
включительном перемещении фрагмент текста, над которым производится операция,
включает как начальный символ, так и конечный. При исключительном перемещении
конечный символ не включается в область применения операции. Построчные
перемещения всегда включают как начальную, так и конечную позиции курсора.

Далее указывается, какие перемещения являются построчными, включительными или
исключительными. Имеется, однако, два основных исключения:

1. Если перемещение является исключительным, а конец перемещения приходится на
   колонку 1, то конец перемещения переносится в конец предыдущей строки и
   перемещение становится включительным. Например, "}" перемещает курсор в
   первую строку после абзаца, однако "d}" не включает эту строку.
2. Если перемещение является исключительным, конец перемещения приходится на
   колонку 1 и начало перемещения приходится на первый непробельный символ в
   строке или на символ, находящийся перед первым непробельным символом, то
   перемещение становится построчным. Пример: если абзац начинается с
   пробелов, то при выполнении команды "d}" в позиции курсора на первом
   непробельном символе будут удалены все строки абзаца, включая пробелы. При
   последующей вклейке удалённые строки будут помещены в позиции ниже текущей
   позиции курсора. 

Замечание: обратите внимание, что в режиме ожидания оператора (когда введена
команда-оператор, но еще не введено перемещение для указания на фрагмент
текста, над которым должна быть произведена операция) можно использовать
специальный набор привязок. Подробнее смотрите |:omap|.

Вместо последовательного ввода оператора и перемещения, можно также
использовать Визуальный режим: курсор помещается в начало необходимого
фрагмента текста, затем вводится команда "v", курсор перемещается в конец
фрагмента и уже затем вводится команда-оператор. При этом текст между
начальной и конечной позициями курсора выделяется подсветкой, так что можно
наглядно видеть над каким фрагментом текста будет выполнена операция. Это
позволяет чувствовать себя более свободным, но требует нажатия дополнительных
кнопок и накладывает ограничения на отмену операции. См. главу о Визуальном
режиме |визуальный_режим|.

В качестве перемещения можно также использовать ":"-команду. Например, "d:call
FindEnd()". Но такая операция не может быть повторена с помощью ".", если
команда занимает несколько строк.

Это можно повторить:
>
	d:call search("f")<CR>
>
а это повторить нельзя:
>
	d:if 1<CR>
	    call search("f")<CR>
	endif<CR>
<

КАК ЗАСТАВИТЬ ПЕРЕМЕЩЕНИЕ БЫТЬ ПОСТРОЧНЫМ, ПОСИМВОЛЬНЫМ ИЛИ БЛОКОВЫМ

Если вы хотите переопределить тип перемещения, то можно использовать "v", "V"
или CTRL-V сразу после оператора.

Пример: >

	dj

удаляет две строки
>
	dvj

удаляет фрагмент от позиции курсора до символа, расположенного ниже курсора
>
	d<C-V>j

удаляет символ, расположенный в позиции курсора и символ, расположенный в
позиции ниже курсора.

Будьте внимательны при переопределении построчного перемещения в посимвольное
или блоковое -- колонка не всегда может быть определена.

							                 *o_v*
v		При использовании после оператора и перед командой
		перемещения: заставляет команду перемещения выполняться
		посимвольно, даже в том случае, когда перемещение является
		построчным. Если перемещение построчное, то оно становится
		|исключительным|.
		Если перемещение является посимвольным, то происходит
		переключение между включительным и исключительным режимом.
		Этим можно пользоваться, чтобы сделать исключительное
		перемещение включительным, и наоборот. 

							                 *o_V*
V		При использовании после оператора и перед командой
		перемещения: заставляет команду перемещения выполняться
		построчно, даже в тех случаях, когда перемещение является
		посимвольным.

								    *o_CTRL-V*
CTRL-V		При использовании после оператора и перед командой
		перемещения: заставляет команду перемещения выполняться в
		блоковом режиме. Блоковый режим работает точно так же, как и
		режим выделения Визуального блока -- положение курсора до и
		после перемещения определяют углы прямоугольного блока.

==============================================================================
						          *left-right-motions*
2. Перемещения курсора влево и вправо		    *перемещения-влево_вправо*

h		или					                   *h*
<Left>		или					              *<Left>*
CTRL-H		или					       *CTRL-H* *<BS>*
<BS>			Перемещение на [число] символов влево. 
			Это |исключительное| перемещение.
			Замечание: если вы предпочитаете использовать <BS> для
			удаления символа, расположенного слева от курсора, то
			можно использовать привязку: >

				:map CTRL-V<BS>		X
<
			(чтобы ввести "CTRL-V<BS>" нажмите CTRL-V и затем
			кнопку <BS>).
			См. также |:fixdel|, если кнопка <BS> работает не так,
			как вам нужно.

l		или					                   *l*
<Right>		или					   *<Right>* *<Space>*
<Space>			Перемещение на [число] символов вправо. 
			Это |исключительное| перемещение.

							                   *0*
0			Перемещение к первому символу строки.
			Это |исключительное| перемещение.
			При перемещении вверх или вниз курсор остаётся в той
			же колонке экрана, если это возможно.

							    *<Home>* *<kHome>*
<Home>			Перемещение к первому символу строки.
			Это |исключительное| перемещение.
			При перемещении вверх или вниз курсор остаётся в той
			же колонке экрана, если это возможно. Команда работает
			как "1|", что отличается от "0", если строка
			начинается с символа <Tab>.
			{Vi не имеет такой возможности}

							                   *^*
^			Перемещение к первому непробельному символу строки.
			Это |исключительное| перемещение.

							  *$* *<End>* *<kEnd>*
$ или <End>		Перемещение в конец строки. Если указана числовая
			приставка, то также перейти на [число-1] строк назад
			|включительно|.
			В Визуальном режиме курсор переходит в позицию сразу
			после последнего символа в строке.
			При включённой опции 'virtualedit', "$" может
			перемещать курсор назад из позиции после последнего
			символа строки к последнему символу.

							                  *g_*
g_			Перемещение к последнему непробельному символу строки
			и на [число-1] строк назад |включительно|.
			{Vi не имеет такой возможности}

							        *g0* *g<Home>*
g0 или g<Home>		При включённом режиме отображения строк с переносами
			(опция 'wrap'): переместиться к первому символу
			экранной строки. Это |исключительное| перемещение.
			Отличия от команды перемещения "0" проявляются в тех
			случаях, когда строка длиннее, чем ширина экрана. 
			
			Если режим отображения строк с переносами выключен
			(опция 'nowrap'): перемещение к самому левому символу
			текущей строки, который виден на экране в текущий
			момент. Отличается от команды перемещения "0" в тех
			случаях, когда первый символ строки находится за
			пределами видимой области экрана.
			{Vi не имеет такой возможности}
			
							                  *g^*
g^			При включённом режиме отображения строк с переносами
			(опция 'wrap'): Перемещение к первому непробельному
			символу строки экрана. 
			Это |исключительное| перемещение. 
			Отличается от команды перемещения "^" в тех случаях,
			когда строка длиннее, чем ширина экрана.

			Если режим отображения строк с переносами выключен
			(опция 'nowrap'): Перемещение к самому левому видимому
			на экране непробельному символу текущей строки.
			Отличается от команды перемещения "^" в тех случаях,
			когда первый символ строки находится за пределами
			видимой области экрана.
			{Vi не имеет такой возможности}

							                  *gm*
gm			Как "g0", но перемещает курсор к середине строки
			экрана вправо (или как можно ближе к середине).
			{Vi не имеет такой возможности}

							         *g$* *g<End>*
g$ или g<End>		При включённом режиме отображения строк с переносами
			(опция 'wrap'): перемещение к последнему символу
			экранной строки. Если есть числовая приставка, то
			курсор также перемещается на [число-1] экранных строк
			вниз |включительно|. Отличается от команды "$" в тех
			случаях, когда строка длиннее, чем ширина экрана.

			Если режим отображения строк с переносами выключен
			(опция 'nowrap'): перемещение к самому правому
			видимому на экране символу текущей строки. Отличается
			от команды "$" в тех случаях, когда используется с
			числовой приставкой или когда последний символ
			находится за пределами видимой области экрана. Кроме
			того, при вертикальных перемещениях сохраняется
			колонка, в которой находится курсор, вместо перехода к
			концу строки.
			{Vi не имеет такой возможности}

									 *bar*
|			Перейти в колонку, на которую указывает
			[число]-приставка, в текущей строке.
			Это |исключительное| перемещение.

							                   *f*
f{символ}		Перейти к следующему (в соответствии с указанным в
			приставке [числом]) совпадению с заданным {символом}.
			Курсор помещается непосредственно в позицию указанного
			{символа} |включительно|. {символом} может также
			служить диграф, см. |диграф-аргумент|.
			Если значением опции 'encoding' является кодировка
			Unicode, то можно использовать также композитные
			символы, подробнее см. |utf8-символ-аргумент|.
			В качестве {символа} могут также применяться
			|:lmap|-привязки. Команда CTRL-^ в режиме Вставки
			может быть использована для переключения между
			включёнными и отключёнными привязками |i_CTRL-^|.

							                   *F*
F{символ}		Перейти к предыдущему (в соответствии с указанным в
			приставке [числом]) совпадению с заданным {символом}.
			Курсор помещается непосредственно в позицию
			указанного {символа} |включительно|.
			{символ} можно вводить так же, как и в команде |f|.

									   *t*
t{символ}		Перейти в позицию перед следующим (в соответствии с
			заданным [числом]) совпадением с указанным {символом}.
			Курсор помещается слева от {символа} |включительно|.
			{символ} можно вводить так же, как и в команде |f|.

							                   *T*
T{символ}		Перейти в позицию после предыдущего (в соответствии с
			заданным [числом]) совпадения с указанным {символом}.
			Курсор помещается справа от {символа} |включительно|.
			{символ} можно вводить так же, как и в команде |f|.

							                   *;*
;			Повторить последнюю команду f, t, F или T необходимое
			[число] раз.

							                   *,*
,			Повторить последнюю команду f, t, F или T необходимое
			[число] раз в обратном направлении.
			
Все эти команды перемещают курсор в необходимую колонку текущей строки.
Перемещение заканчивается при достижении курсором начала или конца строки, за
исключением команды "$", которая может перемещать курсор к одной из следующих
строк. О том, как добиться, чтобы эти команды позволяли переходить через
границы строки, читайте в справке по опции 'whichwrap'.

==============================================================================
                   				             *up-down-motions*
3. Перемещения курсора вверх и вниз		      *перемещения-вверх_вниз*

k		или					                   *k*
<Up>		или					       *<Up>* *CTRL-P*
CTRL-P			Перемещение на заданное [число] строк вверх
			|построчно|.

j		или					                   *j*
<Down>		или					              *<Down>*
CTRL-J		или					              *CTRL-J*
<NL>		или					       *<NL>* *CTRL-N*
CTRL-N			Перемещение на заданное [число] строк вниз
			|построчно|.

gk		или					          *gk* *g<Up>*
g<Up>			Перемещение на заданное [число] строк вверх. 
			Это |исключительное| перемещение.
			От команды "k" отличается при использовании совместно
			с оператором или в перенесённых экранных строках тем,
			что это не построчное перемещение, а посимвольное.
			{Vi не имеет такой возможности}

gj		или					        *gj* *g<Down>*
g<Down>			Перемещение на заданное [число] строк вниз. 
			Это |исключительное| перемещение.
			От команды "j" отличается при использовании совместно
			с оператором или в перенесённых экранных строках тем,
			что это не построчное перемещение, а посимвольное.
			{Vi не имеет такой возможности}

							                   *-*
-  <минус>		Перемещение на заданное [число] строк вверх, к первому 
			непробельному символу |построчно|.

+		или					                   *+*
CTRL-M		или					       *CTRL-M* *<CR>*
<CR>			Перемещение на заданное [число] строк вниз, к первому 
			непробельному символу |построчно|.

							                   *_*
_  <подчёркивание>	Перемещение на [число]-1 строк вниз, к первому
			непробельному символу |построчно|.

					                                   *G* 
G			Перемещение к строке, на которую указывает [число], по
			умолчанию -- к последней строке, к первому
			непробельному символу |построчно|. Если опция
			'startofline' выключена, то курсор остаётся в той же
			колонке. 
								     *<C-End>*
<C-End>			Перемещение к строке [число] (по умолчанию -- к
			последней строке). Курсор располагается на последнем
			символе |включительно|.
			{Vi не имеет такой возможности}

<C-Home>	или					       *gg* *<C-Home>*
gg			Перемещение к строке, на которую указывает [число], по
			умолчанию -- к первой строке, к первому непробельному
			символу |построчно|. Если опция 'startofline'
			выключена, то курсор остаётся в той же колонке.

:[диапазон]		Перемещение в указанную строку. Если в [диапазоне]
			указано несколько чисел, то используется последнее.

							                  *N%*
{число}%		Перемещение к строке, заданной указанным {числом}
			процентов от общего количества строк в файле, к
			первому непробельному символу |построчно|. Для
			вычисления номера строки используется следующая
			формула:

			    ({число} * количество_строк + 99) / 100

			См. также справку по опции 'startofline'.
			{Vi не имеет такой возможности}

:[диапазон]go[to] [число]				    *:go* *:goto* *go*
[число]go		Перейти к заданному [числом] байту в буфере. По
			умолчанию [число] принимается равным 1, т.е. начало
			файла. Если указан [диапазон], то используется
			последнее число. Символ переноса строки считается в
			зависимости от текущего значения опции 'fileformat'.
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+byte_offset|}

Перечисленные команды вызывают перемещение курсора в указанную строку.
Перемещение заканчивается при достижении первой или последней строки. Первые
две команды помещают курсор (по возможности) в той же колонке, которая была
после последней команды, которая вызвала изменение текущей колонки, за
исключением команды "$" -- в этом случае курсор помещается в позицию
последнего символа строки.

==============================================================================
4. Перемещения по словам	        *word-motions* *перемещения-по_словам*

<S-Right>	или					       *<S-Right>* *w*
w			Перемещение на заданное [число] слов вперёд.
			Это |исключительное| перемещение.

<C-Right>	или			                       *<C-Right>* *W*
W			Перемещение на заданное [число] СЛОВ вперёд.
			Это |исключительное| перемещение.

							                   *e*
e			Перемещение вперёд к концу слова, на которое указывает
			[число] |включительно|.

							                   *E*
E			Перемещение вперёд к концу СЛОВА, на которое указывает
			[число] |включительно|.

<S-Left>	или					        *<S-Left>* *b*
b			Перемещение на заданное [число] слов назад.
			Это |исключительное| перемещение.

<C-Left>    	или				                *<C-Left>* *B*
B			Перемещение на заданное [число] СЛОВ назад.
			Это |исключительное| перемещение.

							                  *ge*
ge			Перемещение назад к концу слова, на которое указывает
			[число] |включительно|.

							                  *gE*
gE			Перемещение назад к концу слова, на которое указывает
			[число] |включительно|.

Эти команды позволяют изменять позицию курсора по словам или СЛОВАМ. 
							
					        *словом* *слово* *word* *слов*
Слово состоит из последовательности букв, цифр и символов подчёркивания, а
также других непробельных символов. Слова разделяются пробельными символами
(пробелами, табуляцией, символами конца строки <EOL>). Символы, которые могут
входить в состав слова, определяются значением опции 'iskeyword'.

					        *СЛОВОМ* *СЛОВО* *WORD* *СЛОВ*
СЛОВО состоит из последовательности непробельных символов. СЛОВО разделяется
пробелами. Пустая строка также считается как словом, так и СЛОВОМ. 

Последовательность строк в закрытой складке считается словом из одного
символа. Команды "w" и "W" ("e" и "E") перемещают курсор в начало (конец)
первого слова или СЛОВА после спрятанных в складке строк. Команды "b" и "B"
перемещают курсор в начало первого слова или СЛОВА перед закрытой складкой. 

Особый случай: команды "cw" и "cW" выполняются как "ce" и "cE", если курсор
находится не на пробельном символе, поскольку "cw" это команда для "изменения
слова", а слово не включает следующий за ним пробел. 
{Vi: если курсор находится на пробеле, за которым следуют другие пробелы, то
команда "cw" изменяет только первый пробел; это, вероятно, глюк Vi, поскольку
команда "dw" удаляет все пробелы}

Ещё один особый случай: если при использовании перемещения "w" совместно с
оператором последнее слова, над которым произошло перемещение, находится в
конце строки, то конечной позицией фрагмента текста для операции будет конец
этого слова, а не первое слово следующей строки.

В Vi команда "e" реализована довольно глючно. Например, команда "e"
останавливается на первом символе строки, если предыдущая строка -- пустая.
Однако, этого не происходит при использовании команды "2e". В Vim команды "ee"
и "2e" совершенно одинаковы, что кажется более логичным, хотя это и приводит к
небольшой несовместимости между Vim и Vi.

==============================================================================
                                                              *object-motions*
5. Перемещения по текстовым объектам	             *перемещения-по_объектам*

							                   *(*
(			Перемещение на заданное [число] предложений назад.
			Это |исключительное| перемещение.

							                   *)*
)			Перемещение на заданное [число] предложений вперёд.
			Это |исключительное| перемещение.

							                   *{*
{			Перемещение на заданное [число] абзацев назад.
			Это |исключительное| перемещение.

							                   *}*
}			Перемещение на заданное [число] абзацев вперёд.
			Это |исключительное| перемещение.

							                  *]]*
]]			Перемещение на заданное [число] разделов вперёд или к
			следующему '{' в первой колонке. При использовании
			после оператора -- к следующему '{' в первой колонке.
			|построчно|

							                  *][*
][			Перемещение на заданное [число] разделов вперёд или к
			следующему '}' в первой колонке. |построчно|

							                  *[[*
[[			Перемещение на заданное [число] разделов назад или к
			предыдущему '{' в первой колонке. |построчно|

							                  *[]*
[]			Перемещение на заданное [число] разделов назад или к
			предыдущему '}' в первой колонке. |построчно|


Эти команды позволяют перемещаться между тремя видами текстовых объектов.

				        *sentence* *предложение* *предложения*
Предложения заканчиваются на символ '.', '!' или '?', за которым следует
конец строки, пробел или табуляция. Между '.', '!' или '?' и символом конца
строки, пробелом или табуляцией в предложении также может быть любое
количество закрывающих ')', ']', '"' и '''. Разделители абзацев и разделов
также могут быть разделителем предложения. 
Если в опции 'cpoptions' присутствует флаг 'J', то после знака препинания
должно быть по меньшей мере два пробела и символы <Tab> не считаются пробелом.
Определение предложения изменить нельзя.

					                   *paragraph* *абзац*
Абзац начинается после пустой строки, а также с определённого набора макросов,
указанных в значении опции 'paragraphs'. Значение этой опции по умолчанию --
"IPLPPPQPP LIpplpipbp", что соответствует макросам ".IP", ".LP" и т. д. (Здесь
речь идёт о макросах nroff, поэтому точка должна быть в первой колонке).
Разделителем абзаца также является разделитель раздела. Замечание: это не
включает '{' или '}' в первой колонке. Кроме того, пробельная строка,
состоящая из одних пробелов, в отличие от пустой строки, НЕ является
разделителем абзацев.

							    *section* *раздел*
Раздел начинается после символа протяжки страницы (<C-L>) в первой колонке, а
также с определённого набора макросов, указанных в значении опции 'sections'.
Значение этой опции по умолчанию -- "SHNHH HUnhsh", что соответствует макросам
nroff ".SH", ".NH", ".H", ".HU", ".nh" и ".sh".

Команды "]" и "[" останавливают перемещение на символах '{' и '}' в первой
колонке текста. Этими командами удобно пользоваться при поиске начала и конца
функции в программе на языке C. Обратите внимание, что первый символ этой
команды определяет направление поиска, а второй символ -- тип скобки, которая
будет найдена.

Если в вашей программе '{' или '}' не находятся в первых колонках, но вы, тем
не менее, хотите использовать команды "[[" и "]]", то можете попробовать
использовать такие привязки: >
>
   :map [[ ?{<CR>w99[{
   :map ][ /}<CR>b99]}
   :map ]] j0[[%/{<CR>
   :map [] k$][%?}<CR>

[эти команды набираются как есть, см. |<>|]

==============================================================================
                                                *object-select* *text-objects*
6. Выделение текстовых объектов	        *объект-выделение* *текстовые_объекты*
						                   *v_a* *v_i*

Обсуждаемые в этом разделе команды можно использовать только в Визуальном
режиме или после оператора. Команды, которые начинаются с символа "a" выделяют
объект, включая пробелы, а команды, которые начинаются с символа "i" выделяют
"внутренний", "inner", объект без пробелов, либо только пробелы. Таким
образом, команды "внутреннего" выделения всегда выделяют меньший фрагмент
текста, чем команды выделения полного объекта.

В {Vi нет этих команд}.
Эти команды доступны только в версиях Vim, в которых при компиляции была
включена особенность |+textobjects|.

							           *v_aw* *aw*
aw			слово, "a word".
			Выделить заданное [число] слов (см. |слово|).
			В область выделения включаются, но не учитываются,
			предыдущие слову или следующие за ним пробелы.
			При использовании в Визуальном режиме, "aw" включает
			посимвольный Визуальный режим.

							           *v_iw* *iw*
iw			внутреннее слово, "inner word".
			Выделить заданное [число] слов (см. |слово|).
			Также учитываются пробелы между словами.
			При использовании в Визуальном режиме, "iw" включает
			посимвольный Визуальный режим.

							           *v_aW* *aW*
aW			СЛОВО, "a WORD".
			Выделить заданное [число] СЛОВ (см. |СЛОВО|).
			В область выделения включаются, но не учитываются,
			предыдущие слову или следующие за ним пробелы.
			При использовании в Визуальном режиме, "aW" включает
			посимвольный Визуальный режим.

							           *v_iW* *iW*
iW			внутреннее СЛОВО, "inner WORD".
			Выделить заданное [число] СЛОВ (см. |СЛОВО|).
			Также учитываются пробелы между словами.
			При использовании в Визуальном режиме, "iW" включает
			посимвольный Визуальный режим.

							           *v_as* *as*
as			предложение, "a sentence".
			Выделить заданное [число] предложений (см.
			|предложение|).
			В Визуальном режиме происходит посимвольное выделение.

							           *v_is* *is*
is			внутреннее предложение, "inner sentence". 
			Выделить заданное [число] предложений (см.
			|предложение|).
			В Визуальном режиме происходит посимвольное выделение.

							           *v_ap* *ap*
ap			абзац, "a paragraph".
			Выделить заданное [число] абзацев (см. |абзац|).
			В Визуальном режиме происходит построчное выделение.
			Исключение: пустая строка (содержащая только пробелы)
			также считается границей абзаца.

							           *v_ip* *ip*
ip			внутренний абзац, "inner paragraph".
			Выделить заданное [число] абзацев (см. |абзац|).
			В Визуальном режиме происходит построчное выделение.
			Исключение: пустая строка (содержащая только пробелы)
			также считается границей абзаца.

a]						       *v_a]* *v_a[* *a]* *a[*
a[			блок [], "a [] block".
			Выделить заданное [число] блоков '[' ']'. По этой
			команде курсор перемещается назад на заданное [число]
			незакрытых '[' и затем выделяется текст между '[' и
			соответствующей ей ']', включая также сами символы '['
			и ']'. В Визуальном режиме происходит посимвольное
			выделение. 

i]						       *v_i]* *v_i[* *i]* *i[*
i[			внутренний блок [], "inner [] block".
			Выделить заданное [число] блоков '[' ']'. По этой
			команде курсор перемещается назад на заданное [число]
			незакрытых '[' и затем выделяется текст между '[' и
			соответствующей ей ']', исключая символы '[' и ']'. 
			В Визуальном режиме происходит посимвольное выделение.

a)							      *v_a)* *a)* *a(*
a(							    *v_ab* *v_a(* *ab*
ab			блок, "a block".
			Выделить заданное [число] блоков, начиная от заданного
			[числа] '[(' назад до соответствующей ')', включая
			также сами символы '(' и ')' (см. |[(|). Пробелы вне
			скобок в выделение не включаются.
			В Визуальном режиме происходит посимвольное выделение.

i)							      *v_i)* *i)* *i(*
i(							    *v_ib* *v_i(* *ib*
ib			внутренний блок, "inner block".
			Выделить заданное [число] блоков, начиная от заданного
			[числа] '[(' назад до соответствующей ')', исключая
			символы '(' и ')' (см. |[(|).
			В Визуальном режиме происходит посимвольное выделение.

a>						       *v_a>* *v_a<* *a>* *a<*
a<			блок <>, "a <> block".
			Выделить заданное [число] блоков <>, начиная от
			заданного [числа] '<' назад до соответствующего '>',
			включая также сами символы'<' и '>'.
			В Визуальном режиме происходит посимвольное выделение.

i>						       *v_i>* *v_i<* *i>* *i<*
i<			внутренний блок <>, "inner <> block".
			Выделить заданное [число] блоков <>, начиная от
			заданного [числа] '<' назад до соответствующего '>',
			исключая символы '<' и '>'.
			В Визуальном режиме происходит посимвольное выделение.

a}							      *v_a}* *a}* *a{*
a{							    *v_aB* *v_a{* *aB*
aB			Блок, "a Block".
			Выделить заданное [число] Блоков, начиная от заданного
			[числа] '[{' до соответствующей '}', включая также
			сами символы '{' и '}' (см. |[{|).
			В Визуальном режиме происходит посимвольное выделение.

i}							      *v_i}* *i}* *i{*
i{							    *v_iB* *v_i{* *iB*
iB		 	внутренний Блок, "inner Block".
			Выделить заданное [число] Блоков, начиная от заданного
			[числа] '[{' до соответствующей '}', исключая символы
			'{' и '}' (см. |[{|).
			В Визуальном режиме происходит посимвольное выделение.


При использовании после оператора
---------------------------------

Для неблоковых объектов:
	Команды, начинающиеся с "a": Оператор применяется к объекту и пробелу
	после объекта. Если после объекта нет пробела или курсор находится на
	пробеле перед объектом, то включается пробел перед объектом.
	
	"Внутренние" команды, начинающиеся с"i": Если курсор находится на
	объекте, то оператор применяется к объекту. Если курсор находится на
	пробеле, то оператор применяется к пробелу.

Для блоковых объектов:
	Оператор применяется к блоку, в котором находится курсор, или к блоку,
	к которому относятся скобки, если курсор находится на скобке.
	Внутренние команды, начинающиеся с "i" не включают в операцию сами
	скобки, а команды, начинающиеся с "a" -- включают.

При использовании в Визуальном режиме
-------------------------------------

Если начало и конец Визуальной области совпадают (как сразу после ввода
команды "v"):
	Выбирается один объект, тот же что и при использовании команды
	совместно с оператором.
Если начало и конец Визуальной области находятся в разных позициях:
	Для неблоковых объектов область расширяется на один объект или пробелы
	вплоть до следующего объекта, или происходит и то и другое при
	выполнении команды, начинающейся с "a". Направление расширения
	Визуальной области зависит от позиции курсора в Визуальной области
	(начального и конечного). Для блоковых объектов происходит расширение
	выделения на один блок снаружи от выделения.

В качестве примера, приведём список команд удаления, от наименьших по величине
объектов к наибольшим. Обратите внимание, что для одного символа и целой
строки используются обычные команды vi.

	"dl"	удалить символ (синоним: "x")				  |dl|
	"diw"	удалить внутреннее слово			         *diw*
	"daw"	удалить слово				                 *daw*
	"diW"	удалить внутреннее СЛОВО (см. |СЛОВО|)		         *diW*
	"daW"	удалить СЛОВО (см. |СЛОВО|)		                 *daW*
	"dd"	удалить одну строку				          |dd|
	"dis"	удалить внутреннее предложение			         *dis*
	"das"	удалить предложение			                 *das*
	"dib"	удалить внутренний блок '(' ')'		                 *dib*
	"dab"	удалить блок '(' ')' 		                         *dab*
	"dip"	удалить внутренний абзац		                 *dip*
	"dap"	удалить абзац		                                 *dap*
	"diB"	удалить внутренний блок '{' '}'		                 *diB*
	"daB"	удалить блок '{' '}'			                 *daB*

Обратите внимание на различие между командами перемещения и объектами. Команда
перемещения выполняется от текущей позиции курсора до позиции остановки
перемещения. При использовании объекта команда применяется ко всему объекту
целиком, независимо от позиции курсора внутри объекта. Например, сравните
команды "dw" и "daw": команда "dw" удаляет символы от текущей позиции курсора
до начала следующего слова, а "daw" удаляет слово в позиции курсора, включая
пробелы до или после него.

==============================================================================
7. Отметки		      *mark-motions* *E20* *E78* *отметки-перемещения*

Прыжок к какой-либо отметке выполняется одним из двух способов:

1. При помощи ` (обратной кавычки):	  
			Курсор помещается в позицию отметки. Выполняется
			|исключительное| перемещение.

2. При помощи '(одинарной кавычки):
			Курсор помещается в позицию первого непробельного
			символа строки, содержащей указанную отметку.
			Выполняется построчное перемещение.

				                   *m* *mark* *Mark* *отметка*
m{a-zA-Z}		Установить отметку {a-zA-Z} в позиции курсора. Это не
			команда перемещения, поэтому курсор остаётся на	месте.

                                                                     *m'* *m`*
m' или m`		Установить отметку предыдущего контекста. К такой
			отметке можно прыгнуть по командам "''" и "``". Это не
			команда перемещения, поэтому при её выполнении курсор
			остаётся на месте.
			
			                                             *m[* *m]*
m[ или m]		Установить отметку |'[| или |']|.  Полезно, когда
                        под видом оператора выполняется несколько команд. (не
			приводит к перемещению курсора, это не команда
			перемещения).

						          *:ma* *:mark* *E191*
:[диапазон]ma[rk] {a-zA-Z}	
			Установить отметку {a-zA-Z} в нулевой колонке
			последней строки указанного диапазона. По умолчанию --
			в строке, где находится курсор в момент выполнения
			команды.

						                          *:k*
:[диапазон]k{a-zA-Z}	То же, что и :mark, но пробел перед именем отметки
			можно опустить.

						             *'* *'a* *`* *`a*
'{a-z}  `{a-z}		Прыжок к отметке {a-z}.

						           *'A* *'0* *`A* *`0*
'{A-Z0-9}  `{A-Z0-9}	Прыжок к отметке {A-Z0-9} в нужном файле. Если отметка
			находится не в текущем файле, то команда не является
			перемещением.
			{Vi не имеет такой возможности}

						         *g'* *g'a* *g`* *g`a*
g'{отметка} g`{отметка} Прыжок к указанной {отметке}, но без изменения списка
			прыжков при выполнении перехода в пределах текущего
			буфера. Пример: >

				g`"
<			
			выполнит прыжок к последней известной позиции курсора
			в файле. См. $VIMRUNTIME/vimrc_example.vim.
			{Vi не имеет такой возможности}
						
						                      *:marks*
:marks			Показать список всех существующих отметок. 
			Это не команда перемещения.
			В списке не показываются следующие отметки: 
			|'(|, |')|, |'{| и |'}|.
			{Vi не имеет такой возможности}
						
						                        *E283*
:marks {аргумент}	Показать список отметок, указанных в {аргументе}. 
			Это не команда перемещения. Например: >

				:marks aB
<			
			показывает отметки 'a' и 'B'.
			{Vi не имеет такой возможности}

Отметки никак не видны в тексте. Это просто позиция в файле, которая
запоминается редактором Vim. Не путайте отметки и именные регистры, они никак
друг с другом не связаны.

'a - 'z		отметки со строчными именами, действуют в пределах одного
		  файла
'A - 'Z		отметки с прописными именами, действуют глобально: к такой
		  отметке можно, например, перейти из другого файла.
'0 - '9		числовые отметки, устанавливаются из файла .viminfo
			lines:

Vim помнит отметки, имена которых представляют собой строчные буквы, до тех
пор, пока файл сохраняется в списке буферов. Если вы удалите файл из списка
буферов, то все локальные отметки для этого файла также будут утрачены. Если
вы удаляете строку, содержащую отметку, то эта отметка также стирается.

Для удаления отметки необходимо проделать следующее: создать новую строку,
поместить в ней отметку, а затем удалить эту строку. Например, "o<Esc>mxdd".
Следует, однако, иметь ввиду, что это приводит к изменению файла, причём
использование "u" не помогает, поскольку команда отмены в том числе
восстанавливает отметки.

Локальные отметки могут использоваться совместно с операторами. Например,
"d't" удаляет строки от позиции курсора до отметки 't'. Совет: используйте
отметку 't' для начала файла ("Top", "Верх"), 'b' для конца файла ("Bottom",
"Низ") и т.д. Локальные отметки восстанавливаются при использовании команд
отмены операции и повторного выполнения.

Отметки, имена которых представляют собой прописные буквы от 'A до 'Z,
являются глобальными: помимо позиции курсора в них также запоминается имя
файла {Vi: глобальных отметок нет} Глобальными отметками можно пользоваться
для перемещений между файлами. Глобальная отметка могут использоваться
совместно с оператором только если она определена в текущем файле. Номер
строки для отметки остаётся правильным даже в том случае, если вы удаляете или
добавляете строки в файле, или временно переходите к редактированию другого
файла. Если опция 'viminfo' не пустая, то глобальные отметки сохраняются в
файле .viminfo. См. |viminfo-глобальные_отметки|.

Отметки, имена которых являются цифрами от '0 до '9, следует рассмотреть
отдельно. Их значения нельзя установить напрямую. Эти отметки применимы только
если используется файл viminfo |файл_viminfo|. В отметке '0 сохраняется
позиция курсора в момент, когда вы в последний раз закончили работу с Vim,
в отметке '1 -- позиция курсора в момент предыдущего выхода, и т.д. Чтобы
указать файлы, для которых не должны сохраняться числовые отметки, используйте
флаг "r" в значении опции 'viminfo'. 
Подробнее см. |viminfo-глобальные_отметки|.


							             *'[* *`[*
'[  `[			Переход к первому символу изменённого или
			скопированного раннее фрагмента текста.
			{Vi не имеет такой возможности}

							             *']* *`]*
']  `]			Переход к последнему символу изменённого или
			скопированного раннее фрагмента текста.
			{Vi не имеет такой возможности}

После выполнения оператора курсор помещается в начало фрагмента текста, над
которым выполнялась операция. После выполнения команды вклейки ("p" или "P"),
курсор иногда помещается в первую вклеенную в текст строку, а иногда -- в
позицию последнего вклеенного символа. Четыре указанные выше команды позволяют
перенести курсор в другой конец фрагмента. Например: после копирования 10
строк вы хотите перейти к последней скопированной строке: "10Y']". После
вклейки нескольких строк по команде "p" можно переместиться к самой нижней:
"p']". Это полностью применимо к тексту, который был только что вклеен.

Замечание: после удаления текста начальная и конечная позиция курсора
совпадают, за исключением режима Визуального блока. Эти команды не работают,
если в текущий файл ещё не были внесены изменения.

							             *'<* *`<*
'<  `<			Переход к первому символу последнего Визуально
			выделенного фрагмента в текущем буфере.
			{Vi не имеет такой возможности}

							             *'>* *`>*
'>  `>			Переход к последнему символу последнего Визуально
			выделенного фрагмента в текущем буфере.
			{Vi не имеет такой возможности}

							             *''* *``*
''  ``			Переход к позиции перед последним прыжком, либо к
			позиции, где была в последний раз отдана команда "m'"
			или "m`". Отметка не устанавливается, если была
			применена команда-модификатор |:keepjumps|.
			См. также |восстановление_позиции|.

							     *'quote* *`quote*
'"  `"			Переход к позиции курсора на момент предыдущего
			закрытия текущего буфера. По умолчанию -- первый
			символ первой строки. Подробнее о том, как этим можно
			пользоваться для каждого открытого файла, см.
			|прыжок_к_последней_позиции|.
			Для каждого буфера запоминается только одна позиция.
			Она не изменяется до тех пор, пока остаётся открытым
			хотя бы одно окно с данным буфером.
			{Vi не имеет такой возможности}

							             *'^* *`^*
'^  `^			Переход к позиции, где курсор находился в последний
			момент, когда был прекращён режим вставки. Именно эта
			отметка используется в команде |gi|. Отметка не
			устанавливается, если была применена
			команда-модификатор |:keepjumps|.
			{Vi не имеет такой возможности}

							             *'.* *`.*
'.  `.			Переход к позиции, где было сделано последнее
			изменение. (Имеется в виду позиция в начале или около
			начала изменения, но иногда команда может выполнять
			целую серию изменений и тогда речь может идти о
			позиции ближе к концу внесённого изменения. Например,
			при вставке слова позицией, помеченной отметкой '.',
			будет последний символ слова.)
			{Vi не имеет такой возможности}

							             *'(* *`(*
'(  `(			Переход в начало текущего предложения, как по команде
			|(|.
			{Vi не имеет такой возможности}

							             *')* *`)*
')  `)			Переход в конец текущего предложения, как по команде
			|)|.
			{Vi не имеет такой возможности}

							             *'{* *`{*
'{  `{			Переход в начало текущего абзаца, как по команде |{|.
			{Vi не имеет такой возможности}

							             *'}* *`}*
'}  `}			Переход в конец текущего абзаца, как по команде |}|.
			{Vi не имеет такой возможности}

Следующие команды сами по себе не являются отметками, но выполняют переходы к
заданным отметкам:

							                  *]'*
]'			перейти на заданное [число] локальных отметок вниз, в
			позицию первого непробельного символа строки с
			отметкой.
			{Vi не имеет такой возможности}

							                  *]`*
]`			перейти на заданное [число] локальных отметок вниз.
			{Vi не имеет такой возможности}

							                  *['*
['			перейти на заданное [число] локальных отметок вверх, в
			позицию первого непробельного символа строки с
			отметкой.
			{Vi не имеет такой возможности}

							                  *[`*
[`			перейти на заданное [число] локальных отметок вверх.
			{Vi не имеет такой возможности}

:loc[kmarks] {команда}					   *:loc* *:lockmarks*
			выполнить указанную {команду} без изменения отметок.
			Эта команда может оказаться полезной, если общее
			количество строк текста в результате выполнения
			команды остаётся без изменений.
			ПРЕДУПРЕЖДЕНИЕ: Если количество строк в тексте
			изменяется, то отметки, расположенные ниже по тексту
			после внесённого изменения будут сохранять
			первоначальный номер строки, ссылаясь, таким образом,
			на совершенно иную строку.
			
			При вставке и удалении строк не будут изменяться
			следующие позиции:
			
			- отметки, имена которых являются прописными буквами
			  'a - 'z
			- отметки, имена которых являются строчными буквами
			  'A - 'Z
			- числовые отметки '0 - '9
			- позиция последней вставки '^
			- позиция последнего изменения '.
			- отметки Визуальной области '< и '>
			- номера строк в помещённых знаках
			- номера строк в позициях быстрых исправлений
			- позиции в |списке_прыжков|
			- позиции в |стеке_меток|
			
			Тем не менее, следующие позиции будут изменяться:

			- отметка предыдущего контекста ''
			- позиция курсора
			- вид буфера, отображаемый в окне
			- складки
			- различия

:kee[pmarks] {команда}					   *:kee* *:keepmarks*
			В настоящий момент команда оказывает влияние только
			при использовании команды-фильтра |:range!|:
			
			- Если количество строк после применения
			  команды-фильтра не отличается или больше, чем до
			  применения такой команды, то все отметки сохраняются
			  на своих местах.
			- Если количество строк уменьшается, то отметки в
			  исчезнувших строках удаляются.

			В любом случае, отметки, расположенные ниже текста,
			который был пропущен через фильтр, изменяются таким
			образом, чтобы оставаться на своём месте в тексте.
			Если флаг 'R' отсутствует в значении опции
			'cpoptions', то это имеет такие же последствия, как и
			использование команды ":keepmarks".

							 *:keepj* *:keepjumps*
:keepj[umps] {команда}	
			Не изменять отметки |''|, |'.| и |'^|,
			|список_прыжков| и |список_изменений|. Полезно при
			внесении изменения или автоматической вставке текста,
			если пользователь не желает, чтобы курсор перемещался
			в соответствующую позицию. Например, при обновлении
			отметки "Последнего изменения":
>
	autocmd BufWritePre,FileWritePre *.abc keepjumps call SetLastChange()

==============================================================================
8. Прыжки			           *jump-motions* *прыжки-перемещения*

"Прыжки" выполняются следующими командами: "'", "`", "G", "/", "?", "n",
"N", "%", "(", ")", "[[", "]]", "{", "}", ":s", ":tag", "L", "M", "H", а также
командами, которые начинают редактирование нового файла. Перед выполнением
"прыжка" текущая позиция курсора запоминается, и к ней можно вернуться по
команде "''" или "``", если только эта строка не была изменена или удалена. 

							              *CTRL-O*
CTRL-O			Переход к прежней позиции в списке прыжков ("более
			старая", "Older"). Номер позиции можно задавать при
			помощи [числа]. Это не команда перемещения. 
			{Vi не имеет такой возможности}
			{доступно только в Vim, скомпилированном с
			особенностью |+jumplist|}

<Tab>		или					      *CTRL-I* *<Tab>*
CTRL-I			Перейти к более новой позиции в списке прыжков (номер
			позиции можно указать с помощью [числа]). Это не
			команда перемещения.
			В |окне_быстрых_исправлений| эта команда перемещает
			курсор к позиции соответствующей ошибки.
			{Vi не имеет такой возможности}
			{доступно только в Vim, скомпилированном с
			особенностью |+jumplist|}

							        *:ju* *:jumps*
:ju[mps]		Показать список прыжков. Это не команда перемещения.
			{Vi не имеет такой возможности}
			{доступно только в Vim, скомпилированном с
			особенностью |+jumplist|}

				   *jumplist* *списке_прыжков* *список_прыжков*
Совершённые прыжки запоминаются в списке прыжков. При помощи команд CTRL-O и
CTRL-I можно перемещаться к позиции курсора, соответствующей более раннему или
более позднему прыжку, и назад, передвигаясь таким образом по списку прыжков.
Для каждого окна существует свой собственный список прыжков. Максимальное
количество прыжков, хранящихся в списке, равняется 100. 
{доступно только в Vim, скомпилированном с особенностью +jumplist}

Например, после трёх совершённых прыжков список прыжков может выглядеть так: 

  прыжок стр  кол файл или текст ~
     3	   1    0 какой-то текст  ~
     2	  70    0 другая строка ~
     1  1154   23 конец. ~
 > ~

В колонке "файл или текст" показано имя файла или текст в позиции прыжка, если
этот прыжок находится в текущем файле (отступы в списке не показываются, а
длинные строки обрезаются по ширине окна).

Если в данный момент курсор находится в строке 1167, то команда CTRL-O
позволяет переместиться в строку 1154. Результат выглядит так: 

  прыжок стр  кол файл или текст ~
     2	   1    0 какой-то текст ~
     1	  70    0 другая строка ~
 >   0  1154   23 конец. ~
     1	1167    0 что-то ещё ~

Указатель помещается в позицию последнего прыжка. Следующая команда CTRL-O
использует позицию в списке, расположенную выше указателя, а команда CTRL-I --
позицию ниже указателя. Если указатель находится ниже последней позиции в
списке, то это значит, что команды CTRL-O или CTRL-I ещё не использовались. 
В данном случае команда CTRL-O добавляет текущую позицию курсора (строку 1167)
к списку прыжков, чтобы можно было вернуться к ней по команде CTRL-O.

Последующие команды CTRL-O позволяют переместиться к строкам 70 и 1. При
помощи команды CTRL-I можно затем опять вернуться к строкам 1154 и 1167.
Обратите внимание, что число в колонке "прыжок" можно указывать в виде
числовой приставке в командах CTRL-O и CTRL-I для перехода в нужную позицию.

При использовании команды прыжка текущая позиция курсора добавляется в конец
списка прыжков. Если такая строка уже присутствует в списке прыжков, то она
удаляется. Поэтому, при повторном вводе команды CTRL-O в прежнюю позицию можно
вернуться только один раз. 

При использовании команды-модификатора |:keepjumps|, прыжки не сохраняются в
списке прыжков.

После выполнения команды CTRL-O, приводящей к прыжку в строку 1154, можно
выполнить другую команды прыжка, например "G", и список прыжков будет
соответствующим образом изменён:

  прыжок стр  кол файл или текст ~
     4	   1    0 какой-то текст ~
     3	  70    0 другая строка ~
     2  1167    0 что-то ещё ~
     1	1154   23 конец. ~
 > ~

Номера строк соответствующим образом изменяются при удалении или вставке
строк, если только вы не заканчиваете редактирование файла без записи
изменений, как например по команде ":n!".

При разделении окна список прыжков копируется в новое окно.

Если в списке значений опции 'viminfo' указан элемент ', то список прыжков
сохраняется в файле viminfo и восстанавливается при запуске Vim.


                                       *changelist* *change-list-jumps* *E664*
ПРЫЖКИ ПО СПИСКУ ИЗМЕНЕНИЙ     *список_изменений* *прыжки_по_списку_изменений*

При внесении изменений позиция курсора запоминается. Для каждого изменения, не
подлежащего отмене, запоминается позиция курсора, кроме случаев, когда эта
позиция находится рядом с позицией предыдущего изменения. Для перемещения к
позициям внесения изменений, в том числе тех, которые не могут быть отменены,
используется две команды:

							           *g;* *E662*
g;			Перейти к более старой позиции в списке изменений, 
                        в соответствии с заданным [числом]. Если указанное
			[число] превосходит количество позиций предыдущих
			изменений, то выполняется переход к самому старому
			изменению.
			Если более старая позиция в списке изменений не
			найдена, то выводится сообщение об ошибке.
			(это не команда перемещения)
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+jumplist|}

							           *g,* *E663*
g,			Переход к более свежей позиции курсора в списке
			изменений, в соответствии с заданным [числом].
			Команда работает как "g;", но в противоположном
			направлении.
			(это не команда перемещения)
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+jumplist|}

При использовании числа-приставки вы можете отправиться так далеко назад или
вперёд в списке изменений, как пожелаете. Чтобы переместиться к самому первому
изменению, позиция которого всё ещё сохраняется в памяти, можно использовать
заведомо очень большое число, например "999g;". Количество записей в списке
изменений жестко ограничено и по величине точно такое же, как и в
|списке_прыжков|.

Если в одной строке имеется два изменения, которые можно отменить, и колонки,
в которых произошли эти изменения, отстоят друг от друга на величину, меньшую
чем значение опции 'textwidth', то запоминается только последнее изменение.
Это позволяет избежать внесения лишних записей в список изменений, когда
имеется последовательность небольших изменений в строке, например, при вводе
"xxxxx". Если значение опции 'textwidth' равно 0, то используется значение
опции 'wrapmargin'. Если же и значение опции 'wrapmargin' равно 0, то
используется фиксированное значение 79. Подробность: при вычислениях
используется длина в байтах, а не в символах, чтобы избежать потери
производительности (имеет значение только при использовании мультибайтных
кодировок).

Обратите внимание, что при вставке или удалении текста позиция курсора может
отличаться от позиции внесения изменения. Особенно это касается удаления
строк.

При использовании команды-модификатора |:keepjumps|, позиция внесения
изменения не запоминается.

							            *:changes*
:changes		Команда выводит список изменений. Символ ">" указывает
			на текущую позицию в списке. Сразу после внесения
			изменения этот символ помещается под самой свежей
			записью, указывая, что по команде "g;" будет выполнен
			переход к самой свежей записи в списке изменений.
			В первой колонке показывается число, которое следует
			использовать для перехода к этому изменению. Например:

				измен.  стр  кол текст~
				    3     9    8 ы ы ы
				    2    11   57 цололо цололо
				    1    14   54 последняя изменённая строка
				>

			Команда "3g;" позволяет перейти в строку 9. После её
			выполнения вывод команды ":changes" выглядит так:

				измен.  стр  кол текст~
				>   0     9    8 ы ы ы
				    1    11   57 цололо цололо
				    2    14   54 последняя изменённая строка
			
			Теперь вы можете использовать команду "g," для
			перехода в строку 11 и "2g," для перехода в строку 14.

==============================================================================
9. Различные перемещения		*various-motions* *перемещения-разное*

							                   *%*
%			Найти один из указанных ниже элементов в позиции
			курсора или после неё и перейти к его соответствию.
			Это |включительное| перемещение.

			Элементы могут быть следующими:
			
			([{}])		круглые, квадратные или фигурные
					скобки (набор элементов можно задавать
					с помощью опции 'matchpairs').
			/* */		начало или конец комментария в стиле C
			#if, #ifdef, #else, #elif, #endif
					Условия препроцессора кода на языке C
					(если курсор находится на # или далее
					не следует символов ([{ ).
			Для других элементов можно использовать модуль
			matchit, см. |matchit-установка|.

			Если значение опции 'cpoptions' содержит "M" |cpo-M|,
			то символы обратной косой черты перед круглыми и
			квадратными скобками игнорируются. Без флага "M"
			количество символов обратной косой начинает иметь
			значение: чётное число не соответствует нечётному
			числу. Таким образом, в "( \) )" и "\( ( \)"
			соответствовать будут первая и последняя скобки.

			Если символ '%' не указан в списке значений опции
			'cpoptions' |cpo-%|, то скобки внутри двойных кавычек
			также игнорируются, за исключением тех случаев, когда
			число скобок в строке нечётное и данная строка, а
			также предыдущая строка, не заканчиваются на обратную
			косую черту. '(', '{', '[', ']', '}' и ')' (скобки
			внутри одинарных кавычек) также игнорируются.
			Замечание: это хорошо для C, но не для Perl, где
			строки могут быть заключены в одинарные кавычки.
			Числовая приставка в этой команде не применяется
			(команда {число}% выполняет прыжок к строке,
			расположенной в указанном {числе} процентов от начала
			текста |N%|).  Использование '%' для перемещения по
			соответствующим #if/#else/#endif выполняет построчное
			перемещение. 

						                          *[(*
[(			Перейти к предыдущей незакрытой '('. [число] указывает
			на количество перемещений.
			Это |исключительное| перемещение.
			{Vi не имеет такой возможности}

						                          *[{*
[{			Перейти к предыдущей незакрытой '{'. [число] указывает
			на количество перемещений.
			Это |исключительное| перемещение.
			{Vi не имеет такой возможности}

						                          *])*
])			Перейти к следующей незакрытой ')'. [число] указывает
			на количество перемещений.
			Это |исключительное| перемещение.
			{Vi не имеет такой возможности}

						                          *]}*
]}			Перейти к следующей незакрытой '}'. [число] указывает
			на количество перемещений.
			Это |исключительное| перемещение.
			{Vi не имеет такой возможности}

Указанные выше четыре команды позволяют перемещаться в начало или конец
текущего блока в коде программы. Они похожи на выполнение команды "%" для '(',
')', '{' и '}' в конце блока, но их можно выполнять в любом месте блока, что
может быть очень полезно при редактировании исходного текста программ на языке
C. Например, если курсор находится где-нибудь на "case x:", то команда "[{"
перемещает курсор назад к слову "switch".

						                          *]m*
]m			Перейти к следующему началу метода в Java-подобном
			коде (можно использовать [число] для указания номера
			метода). Если курсор находится не перед началом
			метода, то перейти к началу или концу класса.
			Это |исключительное| перемещение.
			{Vi не имеет такой возможности}
						                          *]M*
]M			Перейти к следующему концу метода в Java-подобном
			коде (можно использовать [число] для указания номера
			метода). Если курсор находится не перед концом
			метода, то перейти к началу или концу класса.
			Это |исключительное| перемещение.
			{Vi не имеет такой возможности}
						                          *[m*
[m			Перейти к предыдущему началу метода в Java-подобном
			коде (можно использовать [число] для указания номера
			метода). Если курсор не находится после начала метода,
			то перейти к началу или концу класса.
			Это |исключительное| перемещение.
			{Vi не имеет такой возможности}
						                          *[M*
[M			Перейти к предыдущему концу метода в Java-подобном
			коде (можно использовать [число] для указания номера
			метода). Если курсор не находится после конца метода,
			то перейти к началу или концу класса.
			Это |исключительное| перемещение.
			{Vi не имеет такой возможности}

При использовании указанных выше команд предполагаются, что в файле содержатся
описания класса с методами. Определения класса заключаются в скобки '{' и '}'.
Каждый метод в классе также заключается в скобки '{' и '}'. Так устроен
синтаксис языка Java. Файл с кодом на этом языке выглядит примерно так: >

	// comment
	class foo {
		int method_one() {
			body_one();
		}
		int method_two() {
			body_two();
		}
	}

Если курсор находится на слове "body_two()", то по команде "[m" будет
совершено перемещение к '{' в начале "method_two()" (конечно, если описание
метода в нашем примере было бы длиннее, то это было бы намного более полезное
перемещение!). Команда "2[m" перемещает курсор в начало "method_one()".
Команда "3[m" перемещает курсор в начало класса.

						                          *[#*
[#			перейти к предыдущему (можно также использовать
			[число]) незакрытому "#if" или "#else".
			Это |исключительное| перемещение.
			{Vi не имеет такой возможности}

						                          *]#*
]#			перейти к следующему (можно также использовать
			[число]) незакрытому "#else" или "#endif".
			Это |исключительное| перемещение.
			{Vi не имеет такой возможности}

Эти команды хорошо работают с текстом программ на языке C, в которых
применяются конструкции #if/#else/#endif. Они перемещают курсор в начало или
конец #if/#else/#endif, включающих текущую строку. Для перехода к следующей
соответствующей строке можно использовать "%".

						     *[star* *[/* *[звёздочка*
[*  or  [/		перейти к предыдущему (можно также использовать
			[число]) началу комментария в стиле C "/*".
			Это |исключительное| перемещение.
			{Vi не имеет такой возможности}

						     *]star* *]/* *]звёздочка*
]*  or  ]/		перейти к следующему (можно также использовать
			[число]) концу комментария в стиле C "*/".
			Это |исключительное| перемещение.
			{Vi не имеет такой возможности}

						                           *H*
H			Переход к строке, заданной [числом] (по умолчанию:
			первая строка экрана), от самой верхней строки экрана,
			к первому непробельному символу |построчно|. Мнемоника
			команды связана с английским словом "Home" ("дом").
			См. также справку по опции 'startofline'. Положение
			курсора учитывает значение опции 'scrolloff'.

						                           *M*
M			Переход к средней строке экрана (Middle, середина) к
			первому непробельному символу |построчно|.
			См. также справку по опции 'startofline'.

						                           *L*
L			Переход к строке, заданной [числом] (по умолчанию:
			нижняя строка экрана), от самой нижней строки экрана,
			к первому непробельному символу |построчно|. Мнемоника
			команды связана с английским словом "Last"
			("последний"). См. также справку по опции
			'startofline'. Положение курсора учитывает значение
			опции 'scrolloff'.

<ЛеваяКнопкаМыши>	Перемещает курсор в позицию на экране, где произошло
<LeftMouse>		нажатие левой кнопки мыши |включительно|.
			См. также |<LeftMouse>|. Если эта позиция находится на
			строке состояния окна, то вместо перемещения будет
			просто активировано данное окно. 
			{Vi не имеет такой возможности}

==============================================================================
vim:tw=78:ts=8:ft=help:norl:
