*editing.txt*   Для Vim version 6.3.  Последнее изменение: 2004 Apr 28


		      СПРАВОЧНИК ПО VIM - Брам Мооленаар


Редактирование файлов			  *edit-files* *редактирование_файлов*

1.  Введение			    |редактирование-введение|
2.  Редактирование файла	    |редактирование_файла|
3.  Диалоги			    |редактирование-диалоги|
4.  Текущий каталог		    |текущий_каталог|
5.  Список аргументов		    |аргументы-список|
6.  Запись			    |запись|
7.  Запись и выход из программы	    |запись_и_выход|
8.  Редактирование бинарных файлов  |редактирование-бинарные_файлы|
9.  Шифрование текста               |шифрование|
10. Отметка времени изменения файла |отметка_времени_изменения|

==============================================================================
1. Введение			        *edit-intro* *редактирование-введение*

Под редактированием файлов с помощью Vim понимается:

1. Чтение файла в буфер Vim.
2. Изменение содержимого буфера с помощью команд редактирования.
3. Запись содержимого буфера в файл.

					         *current-file* *текущий_файл*
Оригинал файла, записанный на диске, изменяется только при записи буфера. В
начале редактирования файла (при чтении файла в буфер), имя этого файла
запоминается как "текущий файл".

					      *alternate-file* *соседний_файл*
В том случае, если уже существует текущий файл, при чтении нового файла старый
файл становится "соседним файлом". Все имена файлов запоминаются в списке
файлов. При вводе имени файла в команде редактирования (например, ":e файл")
или в команде записи (например, ":w файл"), оно добавляется к этому списку.
Списком можно пользоваться для просмотра последних файлов, которые
редактировались в Vim, а также для быстрого перемещения между ними (например,
чтобы скопировать фрагмент текста) с помощью команды CTRL-^. Для этого
достаточно ввести номер файла в списке и нажать CTRL-^. 
{Vi позволяет использовать только один соседний файл}

CTRL-G		или				   *CTRL-G* *:f* *:fi* *:file*
:f[ile]			Показывает имя текущего файла, положение курсора при
		        отключенной линейке (опция 'ruler' выключена), а также
			статус файла: изменён, только для чтения, прочитан с
			ошибками, новый файл. Чтобы сделать эти сообщения
			короче, обратитесь к справке по опции 'shortmess'.
			{Vi не показывает номер колонки}

{число}CTRL-G		Как CTRL-G, но показывает полный путь к текущему
			файлу. Если {число} больше 1, то также показывается
			текущий номер буфера.
			{Vi не имеет такой возможности}

					  *g_CTRL-G* *word-count* *byte-count*
					             *число_слов* *число_байт*
g CTRL-G		Показывает текущую позицию курсора в файле: номер
			колонки, строки, слова и байта. В том случае, если в
			строке имеются символы, занимающие несколько колонок
			экрана (<Tab> или спецсимвол), то указывается как
			"настоящая" колонка, так и колонка экрана, разделённые
			дефисом. См. также справку по опции 'ruler'.
			{Vi не имеет такой возможности}

							          *v_g_CTRL-G*
{Визуально}g CTRL-G	Как "g CTRL-G", но показывается количество слов, строк
			и байт для области, выделенной в визуальном режиме.
			При выделении визуального блока также показывается
			количество колонок. (Подробнее о значении {Визуально}
			читайте здесь: |визуальный_режим|).
			{Vi не имеет такой возможности}

							             *:file_f*
:f[ile] {имя}		Устанавливает имя текущего файла равным {имя}.

:buffers
:files
:ls			Показывает список всех известных имён файлов. См.
			'windows.txt' |:files| |:buffers| |:ls|.
			{Vi не имеет такой возможности}

Vim запоминает полный путь к файлу. В большинстве случаев показывается только
имя файла, так, как вы его ввели в команде, однако после ввода команды ":cd"
используется полный путь к файлу |:cd|.

			       *home-replace* *отображение_домашнего_каталога*
Если установлена переменная окружения $HOME и имя файла начинается с домашнего
каталога, то оно часто отображается с символом "~" вместо домашнего каталога.
Это делается для того, чтобы сделать имя файла короче. При записи и чтении
файла используется полный путь к нему, символ "~" используется только для
отображения имени файла. Если такое имя файла окажется равным "~", то чтобы
избежать путаницы с окончанием, принятым для резервных копий файла
(устанавливается при помощи опции 'backupext'), используется форма "~/".

При записи буфера на диск, по умолчанию используется текущее имя файла. Таким
образом, при выполнении команды "ZZ" или ":wq" оригинал файла будет изменён.
Если это не то, что вам требуется, то можно сохранить буфер в какой-либо
другой файл, снабдив команду ":write" соответствующим аргументом. Например: >

	vim testfile
	[редактирование буфера]
	:w newfile
	:q

В данном случае будет создан файл "newfile", содержащий изменённый вариант
"testfile". Файл "testfile" останется без изменений. Если включена опция
'backup', то Vim копирует оригинал файла с соответствующим именем перед тем,
как он будет перезаписан. Если вам потребуется оригинал позднее, то можно
пользоваться резервной копией. См. также справку по опции 'patchmode'. Имя
резервной копии файла, как правило, такое же, как у оригинала, но с
добавлением окончания, указанного в значении опции 'backupext'. По умолчанию
используется окончание "~", которое вряд ли будет использовано где-то ещё,
чтобы избежать случайной перезаписи существующего файла. Если вам больше
нравится окончание ".bak", то измените опцию 'backupext'. На MS-DOS лишние
точки заменяются символом "_". То же самое происходит в тех случаях, когда Vim
обнаруживает, что используется MS-DOS-подобная операционная система (например,
messydos или crossdos), или в тех случаях, когда включена опция 'shortname'.
Для записи резервной копии файла в другом каталоге используйте опцию
'backupdir'.

			      *auto-shortname* *автоматические_короткие_имена*
Технические детали:
	   На Amiga вы можете использовать имена файлов длиной до 30 символов.
	   Однако, на MS-DOS-совместимой файловой системе можно использовать
	   только 8+3 символов. При создании файла .swp Vim пытается
	   определить тип используемой файловой системы. Если имеется
	   подозрение на MS-DOS-совместимую файловую систему, то
	   устанавливается специальный флаг, который имеет то же значение, что
	   и включение опции 'shortname'. Этот флаг отключается при
	   редактировании нового файла и используется при создании имён файлов
	   ".swp" и "~" для текущего файла. Обратите внимание, что этот флаг
	   не будет включён при записи файла, открытого с нормальной файловой
	   системы, на MS-DOS-совместимую файловую систему. В этом случае
	   создание файла ".~" может оказаться неудачным, что приведёт к
	   появлению сообщения об ошибке. В этом случае используйте опцию
	   'shortname'.

Если имя файла не указано, то в сообщениях выводится "Нет файла". При
использовании команды ":write" с именем файла, значение текущего имени файла
будет переопределено соответствующим образом, если в опции 'cpoptions'
присутствует флаг 'F' (по умолчанию этот флаг присутствует). Такое поведение
полезно при вводе текста в пустом буфере и его последующей записи в файл. Если
опция 'cpoptions' содержит флаг 'f' (по умолчанию НЕ содержит), то для буфера
без имени файла также будет устанавливаться имя при использовании команды
":read файл". Это может быть полезным, если Vim запускается без аргументов, но
для начала редактирования того или иного файла используется команда ":read
файл".
					      *not-edited* *не-редактировался*
Поскольку в этом случае имя файла было установлено без редактирования файла
как такового, то Vim предохраняет вас от случайной перезаписи этого файла. Это
делается при помощи установки специального флага для этого буфера, который
можно увидеть по команде CTRL-G или ":file": в этом случае вывод будет
содержать "[Не редактировался]". При записи буфера по команде ":w!" этот флаг
будет снят.

							   *буфер_был_покинут*
			                                  *abandon* *оставить*
Vim помнит, если содержимое буфера было изменено. Таким образом вы защищены от
потери внесённых изменений. При попытке выйти без сохранения изменений или
перехода к редактированию другого файла, Vim выдаст сообщение и откажется
выполнять операцию. Для отмены такой защиты необходимо добавить к команде
символ '!'. В этом случае изменения будут утрачены. Например, при наличии
несохранённых изменений команда ":q" не будет работать, но будет работать
команда ":q!". Для просмотра информации о том, был ли изменён данный буфер,
пользуйтесь командой "CTRL-G". В том случае, если в буфере имеются
несохранённые изменения, в выводе команды будет указано "[Изменён]".

Для автоматического сохранения изменений без лишних вопросов можно включить
опцию 'autowriteall'. Также существует Vi-совместимая опция 'autowrite',
которая работает не со всеми командами.

Если вы хотите оставить изменения в буфере несохранёнными на данный момент, то
включите опцию 'hidden'. Подробнее см. |скрытый_буфер|.

==============================================================================
2. Редактирование файла	                  *edit-a-file* *редактирование_файла*

							          *:e* *:edit*
:e[dit] [++opt] [+cmd]	Редактировать текущий файл. Полезно для повторного
                        открытия файла, изменённого в другой программе.
			Команда не выполняется, если в буфере имеются
			несохранённые изменения, а опция 'autowriteall'
			выключена. См. также |++opt| и |+cmd|.
			{Vi не позволяет задавать ++opt}

							              *:edit!*
:e[dit]! [++opt] [+cmd]
			Редактировать текущий файл, несмотря на наличие
			изменений в буфере. Все несохранённые изменения будут
			утрачены. Полезно для того, чтобы начать
			редактирование файла с самого начала.
			См. также |++opt| и |+cmd|.
			{Vi не позволяет задавать ++opt}

							             *:edit_f*
:e[dit] [++opt] [+cmd] {файл}
			Редактировать {файл}.
			Команда не выполняется, если в текущем буфере имеются
			несохранённые изменения и не включена опция
			'autowriteall' или 'hidden'.
			См. также |++opt| и |+cmd|.
			{Vi не позволяет задавать ++opt}

							            *:edit!_f*
:e[dit]! [++opt] [+cmd] {файл}
			Редактировать {файл}, несмотря на наличие
			несохранённых изменений.  Все изменения в текущем
			буфере будут утрачены.
			См. также |++opt| и |+cmd|.
			{Vi не позволяет задавать ++opt}

:e[dit] [++opt] [+cmd] #[число]
			Редактировать один из соседних файлов, на который в
			списке файлов, выводимом по команде :files, указывает
			[число]. Эта команда равноценна команде [число]
			CTRL-^. Различие между двумя командами состоит в том,
			что если соседний буфер не имеет имени, то команда 
			":e #" не будет выполняться, в то время как команда
			CTRL-^ работает и в этом случае.
			См. также |++opt| и |+cmd|.
			{Vi не позволяет задавать ++opt}

							        *:ene* *:enew*
:ene[w]			Редактировать новый буфер без имени. Команда не
			выполняется, если в текущем буфере имеются
			несохранённые изменения и не включена опция
			'autowriteall' или 'hidden'.
			Если значение опции 'fileformats' не является пустым,
			то для нового буфера будет использоваться первое
			значение из списка, заданного в этой опции. В
			противном случае используется значение опции
			'fileformat' для текущего буфера.
			{Vi не имеет такой возможности}

							      *:ene!* *:enew!*
:ene[w]!		Редактировать новый буфер без имени. Несохранённые
			изменения в текущем буфере будут утрачены.
			Значение опции 'fileformat' устанавливается так же,
			как и в команде |:enew|.
			{Vi не имеет такой возможности}

							        *:fin* *:find*
:fin[d][!] [++opt] [+cmd] {файл}
			Найти {файл} в одном из каталогов, указанных в опции
			'path' и затем выполнить для него команду |:edit|.
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+file_in_path|}

:{число}fin[d][!] [++opt] [+cmd] {файл}
			То же, что и ":find", но используется {число} для
			указания на номер соответствия в 'path'. Иными
			словами, ":2find file" найдёт второй файл "file" из
			имеющихся в каталогах, указанных в 'path'. Если
			имеется меньше соответствий, чем указывает {число}, то
			будет выведено сообщение об ошибке.

							                 *:ex*
:ex [++opt] [+cmd] [файл]
			То же, что и |:edit|.

							       *:vi* *:visual*
:vi[sual][!] [++opt] [+cmd] [файл]
			В режиме Ex: выйти из режима Ex (см. |режим_Ex|) и
			перейти в Обычный режим. 
			В остальных случаях то же, что и |:edit|.

							        *:vie* *:view*
:vie[w] [++opt] [+cmd] файл
			В режиме Ex: выйти из режима Ex (см. |режим_Ex|) и
			перейти в Обычный режим. В остальных случаях то же,
			что и |:edit|, но с включением опции 'readonly' для
			данного буфера.
			{Vi не имеет такой возможности}

						             *CTRL-^* *CTRL-6*
[число]CTRL-^		Редактировать один из соседних файлов, на который в
			списке файлов, выводимом по команде :files, указывает
			[число]. Эта команда равноценна команде ":e #[число]".
			Если число не указано, то выполняется переход к
			предыдущему соседнему файлу. Этой командой удобно
			пользоваться для быстрого переключения между двумя (и
			более) файлами. 
			Если включена опция 'autowrite' или 'autowriteall', то
			при наличии несохранённых изменений в буфере, они
			будут сохранены.
			Символ ^ как правило находится на той же кнопке, что и
			цифра 6, поэтому вы можете добиться ввода символа
			CTRL-^ путём совместного нажатия кнопок CTRL и 6.
			Однако, на некоторых неамериканских клавиатурах может
			потребоваться другой способ ввода CTRL-^.

[число]]f						             *]f* *[f*
[число][f		То же, что и "gf". Команда является устаревшей.

							    *gf* *E446* *E447*
[число]gf		Редактировать файл, имя которого находится под
			курсором (или после курсора). Мнемоника команды: "goto
			file, переход к	файлу". 
			Для выяснения символов, которые могут входить в имя
			файла, используется значение опции 'isfname'. Символы
			пунктуации ".,:;!" на конце слова игнорируются.
			Поиск файла происходит в каталогах, указанных в
			значении опции 'path', а также относительно текущего
			файла. 
			Для поиска имён файлов с определёнными окончаниями
			используется значение опции 'suffixesadd'.
			Если файл с заданным именем не может быть найден, то
			выполняется вторая попытка, при которой имя файла
			изменяется в соответствии со значением опции
			'includeexpr'.
			Если указано [число], то для редактирования будет
			открыт файл с указанным номером в списке найденных
			соответствий. 
			Если Vim не может |оставить| текущий файл, то команда
			выполняться не будет. 
			Если вы хотите, тем не менее, открыть новый файл для
			редактирования, то используйте команду: >
			
				:e <cfile>

<			Чтобы gf всегда вела себя указанным образом, настройте
			привязку: >

				:map gf :e <cfile><CR>
<			
			В том случае, если имя файла является гипертекстовой
			ссылкой, наподобие "type://machine/path", то для
			доступа к файлу вам потребуется модуль |netrw|. В Unix
			выполняется подстановка для символа '~', например в
			имени "~user/file". Кроме того, выполняется
			подстановка переменных окружения
			|подстановка_переменных_окружения|.
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+file_in_path|}

							                *v_gf*
{Визуально}[число]gf	То же, что и "gf", но в качестве имени файла
			используется выделенный в Визуальном режиме текст.
			Значение опции 'isfname' в данном случае игнорируется.
			При поиски файла опускаются начальные пробелы, но все
			остальные пробелы и специальные символы включаются в
			имя для поиска. (Подробнее о {Визуально} читайте
			здесь: |визуальный_режим|).
			{Vi не имеет такой возможности}

Перечисленные команды используются для начала редактирования какого-либо
файла. При этом файл считывается в буфер и устанавливается текущее имя файла.
Для редактирования открывается файл относительно текущего каталога, см. |:cd|.

Пояснения по сообщениям, которые выдаются после прочтения файла, смотрите
здесь: |чтение-сообщения|.

Если вы желаете начать редактирование файла заново, то можете использовать
команду ":e!". Команда ":e" полезна только в тех случаях, если вы изменили
имя файла. 

					         *:filename* *{file}* *{файл}*
Замечание, касающееся систем, кроме Unix и MS-DOS: при использовании команды,
которая принимает в качестве аргумента единственное имя файла (например,
":edit file"), пробелы в имени файла допускаются, но пробелы на конце имени
файла игнорируются. Это позволяет вводить имена файлов на тех системах,
которые позволяют включать пробелы в именах файлов (например, на Amiga). Так,
по команде ":e   Длинное Имя Файла " будет редактироваться файл "Длинное Имя
Файла". В командах, которые позволяют указывать в качестве аргумента несколько
имён файлов (например, ":next file1 file2"), пробелы внутри имени файла должны
быть экранированы с помощью символа обратной косой черты.

Также выполняется подстановка масок в {файле}. Используемый для масок набор
символов зависит от операционной системы. Наиболее часто употребляются
следующие:

	*	соответствует любому количеству (в т.ч. 0) любых символов
	?	соответствует одному символу
	[abc]	соответствует 'a', 'b' или 'c'

Для экранирования символа, обычно выполняющего роль маски, используйте
обратную косую черту. Исключение составляют системы типа MS-Windows, где
обратная косая черта выполняет роль разделителя каталогов в пути к файлу -- в
этом случае "path\[abc]" по прежнему воспринимается как маска, если символ "["
указан в значениях опции 'isfname'. Простой способ решения этой проблемы --
использование конструкции вроде "path\[[]abc]".

	     *backtick-expansion* *`-expansion* *обратная_кавычка-подстановка*
	                                                       *`-подстановка*
На Unix можно также использовать в именах файлов обратные кавычки. Например: >

	:e `find . -name ver\\*.c -print`

Обратные косые черты перед звёздочкой необходимы для предотвращения
подстановки в "ver*.c" средствами оболочки перед выполнением программы find.
Это также работает на большинстве других систем, с тем ограничением, что
обратные кавычки должны включать в себя весь элемент -- т.е., непосредственно
перед первой кавычкой и непосредственно после последней кавычки текста быть не
должно.

Вместо подстановки вывода внешней программы, в обратных кавычках можно также
использовать выражения Vim, применяя синтаксис `={выражение}`. Например: >
>
	:let foo='bar'
	:e `=foo . ".c" `

В данном случае будет редактироваться файл "bar.c". Обратите внимание, что
выражение не может содержать обратную кавычку.

						   *++opt* *[++opt]* *++опция*
Аргумент [++opt] используется для задания значения опции 'fileformat' или
'fileencoding' для данной команды. Формат аргумента следующий: >
>
	++{имя-опции}={значение}
<
                                              *++ff* *++enc* *++bin* *++nobin*
Здесь {имя-опции} должно быть следующим:

    ff    или fileformat    переопределяет 'fileformat'
    enc   или encoding	    переопределяет 'fileencoding'
    bin   или binary        включает       'binary'
    nobin или nobinary      отключает      'binary'

{значение} не может содержать пробелов. Оно может быть любым допустимым
значением для указанных опций. Примеры: >

	:e ++ff=unix

Выполняется повторное открытие того же самого файла со значением опции
'fileformat', равным "unix".
>
	:w ++enc=latin1 newfile

Выполняется запись текущего буфера в файл "newfile" в кодировке latin1.

Замечание: при чтении устанавливаются указанные значения опций 'fileformat' и
'fileencoding'. В то же время, при записи значения опций не изменяются и при
следующей записи будут использованы старые значения. То же самое касается и
опции 'binary'.

Возможно указание нескольких аргументов ++opt, через пробел. Все аргументы
++opt должны предшествовать аргументу |+cmd|.

						    *+cmd* *[+cmd]* *+команда*
Аргумент [+cmd] может использоваться для установки позиции курсора в открытом
файле, либо для выполнения какой-либо другой команды:

	+		Начать редактирование на последней строке.
	+{номер}	Начать редактирование на строке {номер}.
	+/{шаблон}	Начать редактирование на первой строке, содержащей
			   {шаблон}.
	+{команда}	Выполнить {команду} после открытия нового файла.
			В качестве {команды} можно использовать любую 
			   команду Ex.

Для включения пробела в {шаблон} или {команду} следует экранировать его с
помощью обратной косой черты. Обратная косая черта в конце команды должна
также экранироваться обратной косой.

	:edit  +/The\ book	     file
	:edit  +/dir\ dirname\\	     file
	:edit  +set\ dir=c:\\\\temp  file

Обратите внимание, что в последнем примере число обратная косая черта
экранируется дважды: сначала для аргумента "+cmd", а затем для команды ":set".

						 *file-formats* *файл-форматы*
Опция 'fileformat' устанавливает набор символов, используемых для обозначения
переноса строки (<EOL>) в файле:

'fileformat'    символы   	   формат		~
  "dos"		<CR><NL> или <NL>    DOS	     *DOS-format* *DOS-формат*
  "unix"	<NL>		    Unix	   *Unix-format* *Unix-формат*
  "mac"		<CR>		     Mac	     *Mac-format* *Mac-формат*

В предыдущих версиях использовалась устаревшая опция 'textmode'.

При чтении файла для распознавания переноса строк <EOL> используется указанный
символ или пара символов. В формате DOS (по умолчанию для MS-DOS, OS/2 и
Win32), в качестве <EOL> распознаётся как <CR><NL>, так и <NL>. Замечание: при
записи в формате DOS для каждого одиночного символа <NL> добавляется символ
<CR>. См. также |файл-чтение|.

При записи файла используются указанные символы для переноса строки. Для DOS
используется <CR><NL>. См. также |DOS-формат-запись|.

Вы можете прочитать файл в формате DOS и записать его в формате Unix. Это
позволяет заменить все пары символов <CR><NL> на <NL> (предполагается, что в
значении опции 'fileformats' содержится "dos"): >

	:e file
	:set fileformat=unix
	:w

И наоборот: можно прочитать файл в формате Unix и записать его в формате DOS.
При этом все одиночные символы <NL> заменяются на <CR><NL> (предполагается,
что в значении опции 'fileformats' содержится "unix"): >

	:e file
	:set fileformat=dos
	:w

Если значение опции 'fileformats' при редактировании нового файла не является
пустым (по умолчанию оно НЕ пустое), то Vim попытается самостоятельно
определить формат переноса строки, который используется в файле. Если значение
этой опции установлено "unix,dos", то Vim проверяет наличие строк, разделённых
одиночным символом <NL> (как это принято на Unix и Amiga), либо парой символов
<CR><NL> (MS-DOS). Если ВСЕ строки разделяются парой <CR><NL>, то значение
опции 'fileformat' устанавливается равным "dos", в противном случае оно
устанавливается равным "unix". Если в значении опции 'fileformats' содержится
"mac" и в файле не обнаружено символов <NL>, то значение опции 'fileformat'
устанавливается равным "mac".

В том случае, если значение опции 'fileformat' установлено равным "dos", на
системах, использующих не-MS-DOS формат файлов, будет выдано сообщение 
"[формат dos]", чтобы напомнить пользователю о том, что редактируется файл в
неродном для данной системы формате. Аналогично, на MS-DOS-системах выдаётся
сообщение "[формат unix]", если при чтении файла значение опции 'fileformat'
устанавливается равным "unix". Если значение опции 'fileformat'
устанавливается равным "mac", то на всех системах, кроме Macintosh, выдаётся
сообщение "[формат mac]".

Если опция 'fileformats' не имеет значения и используется формат DOS, но при
чтении обнаруживается, что некоторые строки в файле не оканчиваются на
<CR><NL>, то будет выведено сообщение "[пропущены CR]". 
Если у опции 'fileformats' нет значения и используется формат Mac, но при
чтении обнаруживаются символы <NL>, то выводится сообщение "[обнаружены NL]".

Если редактируется новый файл, который не существует на диске, то будет
использовано значение опции 'fileformat' для текущего буфера, если опция
'fileformats' не имеет значения, либо первое из списка значений в опции
'fileformats'.

Перед редактированием бинарного, исполняемого файла или файла сценария Vim
необходимо включить опцию 'binary'. Проще всего это сделать при запуске
редактора с помощью ключа команды запуска "-b".  Это позволяет отключить
использование опции 'fileformat'. В противном случае Vim может заменить
одиночные символы <NL> на пару <CR><NL>.

Вы можете зашифровать файлы при записи путём установки пароля в значении опции
'key', что позволяет обеспечить некоторый уровень защиты ваших файлов от
чтения другими людьми. |шифрование|


Поиск файла   				         *file-searching* *файл-поиск*

{доступно только в том случае, если Vim скомпилирован с особенностью
|+path_extra|}

Поиск файла выполняется с учётом значения опций 'path', 'cdpath' и 'tags'.
Существует три различных типа поиска, используемых при задании значений
указанных опций:

1) Поиск вглубь иерархии каталогов файловой системы:

   При поиске вглубь применяются маски '*', '**' и, возможно, ещё некоторые
   маски, которые зависят от операционной системы. Маски '*' и '**'
   обслуживаются непосредственно в самом редакторе Vim, поэтому работают на
   всех операционных системах. 

   Использовать маску '*' очень просто: она обозначает 0 или более символов.

   Маска '**' более сложна в использовании:
      
      - Она соответствует ТОЛЬКО каталогам.
      - Она заменяет собой до 30 каталогов вглубь, поэтому может применяться
	для поиска по всему дереву каталогов
      - Максимальное количество уровней в иерархии для поиска может быть
	задано с помощью числа, добавленного к символам '**'.
	Таким образом, маска '/usr/**2' будет соответствовать: >
		
		/usr
		/usr/include
		/usr/include/sys
		/usr/include/g++
		/usr/lib
		/usr/lib/X11
		....

<	но не будет соответствовать каталогу '/usr/include/g++/std', поскольку
	он находится на третьем уровне. 
	Допустимое число уровней, которые можно указывать с этой маской, лежит
	в диапазоне от 0 ('**0' не принимается во внимание) до 255.
	Если указано значение меньше 0, то оно по умолчанию считается равным
	30, если число больше 255, то по умолчанию оно принимается равным 255. 
      - '**' может быть использовано только в конце пути, либо должно
	продолжаться символом разделителя каталогов в пути, либо числом и
	затем символом разделителя.

   Маски '*' и '**' можно сочетать в любом порядке: >

	/usr/**/sys/*
	/usr/*/sys/**
	/usr/**2/sys/*

2) Поиск вверх по иерархии каталогов файловой системы:

   Вы можете также выполнять поиск от заданного каталога вверх по дереву
   файловой системы. Для ограничения поиска можно также задавать родительский
   каталог, в котором прекращается поиск. Этот каталог добавляется к пути (в
   опции 'path') или к имени файла (в опции 'tags') с помощью символа ';'.
   Если вам необходимо использовать несколько таких каталогов, то они также
   разделяются символом ';'. Если вы не хотите задавать родительский каталог,
   в котором прекращается поиск вверх по дереву ("искать снизу вверх до
   корневого каталога"). Например, конструкция >
	
	/usr/include/sys;/usr

<   позволяет выполнять поиск файла в каталогах: >

	   /usr/include/sys
	   /usr/include
	   /usr
<
   Если для поиска вверх используется относительный путь, то поиск начинается
   в текущем каталоге Vim или в каталоге текущего файла (если относительный
   путь начинается с './' и флаг 'd' не присутствует в списке значений опции
   'cpoptions').

   Например, если текущий каталог Vim установлен в значение
   /u/user_x/work/release и вы выполняете команду: >

	:set path=include;/u/user_x

<  то поиск файла по команде |gf| будет осуществляться в каталогах: >

	/u/user_x/work/release/include
	/u/user_x/work/include
	/u/user_x/include

3) Комбинированный поиск в обоих направлениях:

   Если текущий путь Vim равен /u/user_x/work/release и вы выполните команду:
   >
	set path=**;/u/user_x
<  
   то поиск файла по команде |gf| будет осуществляться в каталогах: >

	/u/user_x/work/release/**
	/u/user_x/work/**
	/u/user_x/**
<
   БУДЬТЕ ВНИМАТЕЛЬНЫ! Такая команда может потребовать большого количества
   времени для выполнения, поскольку поиск в '/u/user_x/**' уже сам по себе
   подразумевает также и поиск в '/u/user_x/work/**' и
   '/u/user_x/work/release/**', поэтому в данном случае поиск в каталоге
   '/u/user_x/work/release/**' выполняется три раза, а поиск в каталоге
   '/u/user_x/work/**' выполняется дважды.

   В приведённом выше примере можно также установить значение опции 'path' и
   таким образом: >

	:set path=**,/u/user_x/**

<  Что приводит к поиску в каталогах: >

	/u/user_x/work/release/**
	/u/user_x/**

<   Это те же самые каталоги, но расположенные в другом порядке.

==============================================================================
3. Диалоги			       *edit-dialogs* *редактирование-диалоги*

							    *:confirm* *:conf*
:conf[irm] {команда}	Выполнить {команду} с использованием диалога, если
			потребуется подтверждение со стороны пользователя для
			завершения этой команды. Это можно использовать
			совместно с командами ":q", ":qa" и ":w" (в команде
			":w" для вывода подтверждения при записи файла,
			открытого только для чтения).

Примеры: >

  :confirm w foo

<	Требует подтверждения, если "foo" уже существует. >

  :confirm q

<	Требует подтверждения, если имеются несохранённые изменения. >

  :confirm qa

<	Требует подтверждения для сохранения или выхода без сохранения для
        каждого буфера с несохранёнными изменениями. Также имеется выбор между
	"сохранением всех буферов" и "закрытием всех буферов без сохранения".

Если вы хотите всегда использовать команду ":confirm" автоматически, то
включите опцию 'confirm'.

			   *:browse* *:bro* *E338* *E614* *E615* *E616* *E578*
:bro[wse] {команда}	Позволяет открывать системный диалог выбора файла для
			указания аргумента {команды}. В настоящий момент
			используется с командами |:e|, |:w|, |:r|, |:saveas|,
			|:sp|, |:mkexrc|, |:mkvimrc| и |:mksession|.
			{доступно только в графическом интерфейсе Win32,
			Athena, Motif, GTK и Mac}.
			Если выполнение команды ":browse" не возможно, то
			выводится сообщение об ошибке. Если Vim скомпилирован
			без особенности |+browse| или указанная {команда} не
			поддерживает вызов системного диалога выбора файла, то 
			{команда} выполняется без открытия диалога для выбора
			файла.
			Команда ":browse set" работает так же, как и команда
			|:options|.

Синтаксис этой команды лучше всего проиллюстрировать с помощью примеров: >
>
	:browse e $vim/foo
	
<		Открыть диалог для выбора файла в каталоге $vim/foo и перейти
		к редактированию выбранного файла.
>
	:browse e
<		Открыть диалог для выбора файла в каталоге, указанном в
                значении опции 'browsedir' и перейти к редактированию
		выбранного файла.
>
	:browse w
<		Открыть диалог для выбора файла в каталоге текущего буфера, с
		использованием имени файла текущего буфера по умолчанию, и
		сохранить изменения под именем выбранного файла.
>
	:browse w C:/bar

<		Открыть диалог для выбора файла в каталоге C:/bar, с
		использованием имени файла текущего буфера по умолчанию, и
		сохранить изменения под именем выбранного файла.
		
См. также справку по опции |'browsedir'|.
В тех версиях Vim, где диалог выбора файла не поддерживается, команда
выполняется так, как если бы не было указано команды :browse.

			        *browsefilter* *фильтр_в_диалоге_выбора_файла*
На MS Windows вы можете изменить фильтр для отображения файлов в диалоге
выбора. Это достигается путём установки значения переменной g:browsefilter
(глобальный фильтр) или b:browsefilter (локальный фильтр по отношению к
буферу). Этим переменным может быть присвоено значение в формате
"{метка-фильтра}\t{шаблон};{шаблон}\n", где {метка-фильтра} это текст, который
появляется в выпадающем списке "Тип файла", а {шаблон} это шаблон, по которому
фильтруются файлы. Можно указывать несколько шаблонов, разделённых символом
';'.

В Motif используется аналогичный формат, но в действительности будет
использоваться только первый шаблон (Motif позволяет использовать только один
шаблон, но его можно редактировать).

Например, чтобы в диалоге были показаны только файлы Vim, можно пользоваться
такой командой: >

     let g:browsefilter="Сценарии Vim\t*.vim\nСценарии запуска Vim\t*vimrc\n"

Настройки фильтра можно устанавливать для каждого буфера в отдельности, если
пользоваться переменной b:browsefilter вместо g:browsefilter. Обычно
переменная b:browsefilter получает своё значение в модуле типа файла, чтобы
необходимые настройки автоматически применялись к файлом того или иного типа.
Чтобы было проще начать редактирование, можно также добавить в качестве
последнего фильтра "Все файлы\t*.*\n", и тогда пользователь сможет выбрать
любой файл, который пожелает.

==============================================================================
4. Текущий каталог	                 *current-directory* *текущий_каталог*

Для перехода в другой каталог, чтобы не набирать путь перед именами файлов,
используйте команды |:cd| и |:lcd|. Эти команды также влияют на выполнение
внешних программ, таких как ":!ls".

							          *:cd* *E472*
:cd			На не-Unix системах: выводит текущий каталог.
			На Unix: изменяет текущий каталог на домашний. Для
			вывода значения текущего каталога на всех системах
			используйте команду |:pwd|.

:cd {путь}		Изменяет текущий каталог на указанный {путь}. 
			Если указан относительный {путь}, то выполняется поиск
			совпадений по каталогам, указанным в значении опции
			|'cdpath'|.
			Путь к открытому в буфере файлу при этом не
			изменяется, поскольку Vim помнит полный путь к каждому
			файлу. В то же время, файлы в |списке_аргументов|
			могут быть изменены!
			На MS-DOS эта команда также позволяет изменить имя
			текущего диска. Для перехода в каталог, в котором
			находится текущий файл, используйте команду: >

				:cd %:h
<
							         *:cd-* *E186*
:cd -			Переход к предыдущему текущему каталогу (который был
			текущем перед предыдущей командой ":cd {путь}".
			{Vi не имеет такой возможности}

							       *:chd* *:chdir*
:chd[ir] [путь]		То же, что и |:cd|.

							          *:lc* *:lcd*
:lc[d] {путь}		То же, что и |:cd|, но текущий каталог изменяется
			только для текущего окна. Текущий каталог для других
			окон не изменяется.
			{Vi не имеет такой возможности}

							      *:lch* *:lchdir*
:lch[dir]		То же, что и |:lcd|. {Vi не имеет такой возможности}

							   *:pw* *:pwd* *E187*
:pw[d]			Выводит значение текущего каталога. 
			{Vi не имеет такой возможности}
			См. также |getcwd()|.

До тех пор, пока не используется команда |:lcd|, все окна используют
одинаковое значение текущего каталога. Переход в другое окно не изменяет
текущий каталог.
После выполнения команды |:lcd| для данного окна будет установлено своё
значение текущего каталога. Окна, в которых не использовалась команда |:lcd|,
по прежнему используют глобальное, общее значение текущего каталога. При
переходе в другое окно текущий каталог становится последним из определённых
локальных текущих каталогов. Если локальный каталог не определён, то
используется глобальное значение.
При выполнении команды |:cd|, текущее окно утрачивает значение своего
локального текущего каталога и с этого момента пользуется глобальным
значением.

После использования команды |:cd| при чтении и записи используется полный путь
к файлу. Это может вызвать проблемы на некоторых сетевых файловых системах.
Полный путь к файлу позволяет быть уверенным, что все используемые в данный
момент имена файлов, по прежнему указывают на всё те же самые файлы. Например,
представьте, что у вас имеется файл a:test и каталог a:vim. В этом случае
команды ":e test" ":cd vim" ":w" перепишут файл a:test, но не файл a:vim/test.
Однако, если вы выполните команду ":w test", то будет записан файл a:vim/test,
поскольку вы указали новое имя файла и не сослались на данный файл перед
выполнением команды ":cd".

==============================================================================
                                       *списке_аргументов* *списка_аргументов* 
		                                           *список_аргументов*
5. Список аргументов		  *argument-list* *arglist* *аргументы-список*

Если Vim запускается с указанием нескольких имён файлов, то они запоминаются в
списке аргументов. После запуска редактора вы сможете переходить от одного
файла к другому в этом списке.

Список аргументов не следует путать со списком буферов, который можно
посмотреть по команде |:buffers|. Список аргументов существует также и в Vi,
но список буферов появился уже только в Vim. Имя файла, которое присутствует в
списке аргументов, будет также присутствовать и в списке буферов (если только
оно не было удалено по команде ":bdel").

Основные сведения на эту тему можно прочитать в руководстве пользователя Vim,
раздел |07.2|.

По умолчанию для всех окон используется один общий список аргументов. Кроме
того, возможно создание нового списка аргументов, который будет локальным по
отношению к какому-либо окну, с помощью команды |:arglocal|.

Список аргументов можно использовать с указанными ниже командами, а также в
функциях |argc()| и |argv()|. Все они работают со списком аргументов текущего
окна.

							         *:ar* *:args*
:ar[gs]			Выводит список аргументов, текущий файл отображается в
			квадратных скобках.

:ar[gs] [++opt] [+cmd] {список-аргументов}			     *:args_f*
			Позволяет задавать новый {список-аргументов} и
			редактировать первый файлы из этого списка. Команда не
			выполняется, если были сделаны изменения и Vim не
			может по тем или иным причинам |оставить| текущий
			буфер. См. также |++opt| и |+cmd|.
			{Vi: нельзя задавать ++opt}

:ar[gs]! [++opt] [+cmd] {список-аргументов}			    *:args_f!*
			Позволяет задавать новый {список-аргументов} и
			редактировать первый файлы из этого списка. Все
			изменения в текущем буфере будут утрачены.
			См. также |++opt| и |+cmd|.
			{Vi: нельзя задавать ++opt}

:[число]arge[dit][!] [++opt] [+cmd] {имя}		    *:arge* *:argedit*
			Добавляет {имя} к списку аргументов и переходит к
			редактированию этого файла. Если {имя} уже
			присутствует в списке аргументов, то просто
			редактируется данный файл.
			Эта команда похожа на выполнение команды |:argadd| и
			последующее выполнение команды |:edit|.
			Замечание: можно указывать только одно имя файла,
			которое может содержать пробелы, как при использовании
			команды |:edit|.
			[число] используется как с командой |:argadd|.
			Если текущий буфер нельзя |оставить|, то требуется
			добавление символа [!] к команде.
			См. также |++opt| и |+cmd|.
			{Vi не имеет такой возможности}

:[число]arga[dd] {имя} ..		              *:arga* *:argadd* *E479*
			Добавить {имя} или несколько {имён} к списку
			аргументов.
			Если [число] не указано, то {имена} добавляются сразу
			после текущей позиции в списке аргументов.
			В противном случае файлы добавляются после позиции в
			списке аргументов, отмеченной [число]м. Если текущий
			список аргументов -- "a b c", а текущий файл в списке
			-- "b", то результат выполнения команды будет такой:
				
				команда		новый список аргументов ~
				
				:argadd x	a b x c
				:0argadd x	x a b c
				:1argadd x	a x b c
				:99argadd x	a b c x
			
			Проверка дубликатов в списке на выполняется, поэтому
			один и тот же файл может присутствовать в списке
			аргументов дважды. Текущий файл при выполнении этой
			команды не изменяется. 
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+listcmds|}
			Замечание: можно также пользоваться командой: >

				:args ## x
<			
			К списку аргументов будет добавлен аргумент "x", после
			чего список будет отсортирован.

:argd[elete] {шаблон} ..		           *:argd* *:argdelete* *E480*
			Удалить из списка аргументов файлы, соответствующие
			{шаблону}. В качестве {шаблона} используется обычный
			шаблон для задания имён файлов, см. |файл-шаблон|.
			Для удаления текущего файла из списка можно
			использовать "%".
			Команда сохраняет текущий файл, даже если он удаляется
			из списка аргументов. 
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+listcmds|}

:{диапазон}argd[elete]	Удаляет {диапазон} файлов из списка аргументов. Если
			последнее число в диапазоне слишком велико, то из
			списка удаляются файлы вплоть до последнего. Например:
>
				:10,1000argdel

<			Эта команда удаляет файлы из списка аргументов,
			начиная с 10-го аргумента (и до 1000-го или
			последнего), но сохраняет в списке аргументы с 1-го
			по 9-ый.
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+listcmds|}

							   *:argu* *:argument*
:[число]argu[ment] [число] [++opt] [+cmd]
			Редактировать файл, находящийся в позиции [число] в
			списке аргументов. Если [число] не указано, то
			используется текущая позиция. Команда не выполняется,
			если в текущем буфере были сделаны изменения и Vim не
			может их |оставить| без сохранения.
			См. также |++opt| и |+cmd|.
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+listcmds|}

:[число]argu[ment]! [число] [++opt] [+cmd]
			Редактировать файл, находящийся в позиции [число] в
			списке аргументов. Все изменения в текущем буфере
			будут утрачены. Если [число] не указано, то
			используется текущая позиция в списке аргументов.
			См. также |++opt| и |+cmd|.
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+listcmds|}

:[число]n[ext] [++opt] [+cmd]		      *:n* *:ne* *:next* *E165* *E163*
			Редактировать следующий ([число] указывает на позицию
			от текущего) файл в списке аргументов. Команда не
			выполняется, если в текущем буфере были сделаны
			изменения и Vim не может их |оставить| без
			сохранения. 
			См. также |++opt| и |+cmd|.
			{Vi: нельзя задавать ++opt или число}

:[число]n[ext]! [++opt] [+cmd]
			Редактировать следующий ([число] указывает на позицию
			от текущего) файл в списке аргументов. Все изменения в
			текущем буфере будут утрачены.
			См. также |++opt| и |+cmd|.
			{Vi: нельзя задавать ++opt или число}

:n[ext] [++opt] [+cmd] {список-аргументов}			     *:next_f*
			То же, что и |:args_f|.

:n[ext]! [++opt] [+cmd] {список-аргументов}
			То же, что и |:args_f!|.

:[число]N[ext] [число] [++opt] [+cmd]			   *:Next* *:N* *E164*
			Редактировать предыдущий ([число] указывает на позицию
			от текущего) файл в списке аргументов. Команда не
			выполняется, если в текущем буфере были сделаны
			изменения и Vim не может их |оставить| без
			сохранения. 
			См. также |++opt| и |+cmd|.
			{Vi: нельзя задавать ++opt или число}

:[число]N[ext]! [число] [++opt] [+cmd]
			Редактировать предыдущий ([число] указывает на позицию
			от текущего) файл в списке аргументов. Все изменения в
			текущем буфере будут утрачены.
			См. также |++opt| и |+cmd|.
			{Vi: нельзя задавать ++opt или число}

:[число]prev[ious] [число] [++opt] [+cmd]		   *:prev* *:previous*
			То же, что и :Next.
			См. также |++opt| и |+cmd|.
			{Vi: команда доступна не во всех версиях}

							      *:rew* *:rewind*
:rew[ind] [++opt] [+cmd]
			Начать редактирование первого файла в списке
			аргументов. Команда не выполняется, если в текущем
			буфере были сделаны изменения и Vim не может их
			|оставить| без сохранения.
			См. также |++opt| и |+cmd|.
			{Vi: нельзя задавать ++opt}

:rew[ind]! [++opt] [+cmd]
			Начать редактирование первого файла в списке
			аргументов. Все изменения в текущем буфере будут
			утрачены.
			См. также |++opt| и |+cmd|.
			{Vi: нельзя задавать ++opt}

							       *:fir* *:first*
:fir[st][!] [++opt] [+cmd]
			То же, что и ":rewind". 
			{Vi не имеет этой команды}

							         *:la* *:last*
:la[st] [++opt] [+cmd]
			Начать редактирование последнего файла в списке
			аргументов. Команда не выполняется, если в текущем
			буфере были сделаны изменения и Vim не может их
			|оставить| без сохранения.
			См. также |++opt| и |+cmd|.
			{Vi не имеет этой команды}

:la[st]! [++opt] [+cmd]
			Начать редактирование последнего файла в списке
			аргументов. Все изменения в текущем буфере будут
			утрачены.
			См. также |++opt| и |+cmd|.
			{Vi не имеет этой команды}

							        *:wn* *:wnext*
:[число]wn[ext] [++opt] [+cmd]
			Записать текущий файл и перейти к редактированию
			файла, следующего в списке аргументов. [число]
			определяет позицию в списке аргументов после текущего
			файла. 
			См. также |++opt| и |+cmd|.
			{Vi не имеет этой команды}

:[число]wn[ext] [++opt] [+cmd] {файл}
			Записать текущий файл под именем {файл} и перейти к
			редактированию файла, следующего в списке аргументов.
			Команда выполняется только в тех случаях, когда {файл}
			ещё не существует, или если включена опция 'writeany'.
			[число]	определяет позицию в списке аргументов после
			текущего файла. 
			См. также |++opt| и |+cmd|.
			{Vi не имеет этой команды}

:[число]wn[ext]! [++opt] [+cmd] {файл}
			Записать текущий файл под именем {файл} и перейти к
			редактированию файла, следующего в списке аргументов.
			[число] определяет позицию в списке аргументов после
			текущего файла.
			См. также |++opt| и |+cmd|.
			{Vi не имеет этой команды}

:[число]wN[ext][!] [++opt] [+cmd] [файл]		        *:wN* *:wNext*
:[число]wp[revous][!] [++opt] [+cmd] [файл]		    *:wp* *:wprevious*
			То же, что и :wnext, но вместо следующего файла
			перейти к редактированию предыдущего файла в списке
			аргументов.
			См. также |++opt| и |+cmd|.
			{Vi не имеет этой команды}

По умолчанию, [число] в вышеперечисленных командах принимается равным 1. В
некоторых командах возможно указание двух чисел, при этом будет использоваться
последнее из указанных чисел (самое правое).

Если не указан аргумент [+cmd], то курсор помещается в последнюю известную
позицию для данного файла. Если включена опция 'startofline', то курсор
помещается на первом непробельном символе, в противном случае используется
последняя известная колонка в данном файле. Если для данного файла не
существует последней известной позиции курсора, то он помещается в первой
строке (или в последней, если редактор находится в режиме Ex).

Маски в шаблонах файлов в списке аргументов будут правильно раскрыты, а
полученный список аргументов будет отсортирован. Поэтому, для редактирования
всех файлов C в текущем каталоге можно использовать команду запуска "vim *.c".
То же самое выполняется по команде ":n *.c" в редакторе. На Unix можно также
использовать обратные кавычки, например: >

	:n `find . -name \\*.c -print`

Обратные косые перед звёздочкой необходимы для того, чтобы предотвратить
подстановку имён файлов вместо маски средствами оболочки до выполнения
программы find.

		        *arglist-position* *список_аргументов-текущая_позиция*
При работе со списком аргументов можно видеть, какой файл в списке в данный
момент редактируется, в заголовке окна (если у окна есть заголовок и включена
опция 'title'), а также в сообщении, которое выдаётся по команде CTRL-G.
Формат сообщения примерно такой: 

	(file 4 of 11)

Или, если в значении опции 'shortmess' указан флаг f, 

	(4 of 11)

В тех случаях, когда в данный момент вы редактируете не тот файл, который
отмечен в текущей позиции списка аргументов, вывод команды будет такой:

	(file (4) of 11)

Это значит, что вы находитесь в 4-ой позиции в списке аргументов, но
редактируете другой файл, отличный от четвёртого в списке аргументов. Это
происходит, например, при выполнении команды ":e file".


ЛОКАЛЬНЫЙ СПИСОК АРГУМЕНТОВ

{Vi не имеет такой возможности}
{доступно только в том случае, если Vim скомпилирован с особенностями
|+windows| и |+listcmds|}

							           *:arglocal*
:argl[ocal]		Создать локальную копию общего списка аргументов. При
			этом Vim не переходит к редактированию нового файла. 

:argl[ocal][!] [++opt] [+cmd] {список-аргументов}
			Создать новый список аргументов, локальный по
			отношению к данному окну. Во всём остальном работает
			так же, как и |:args_f|.

							          *:argglobal*
:argg[lobal]		Использовать общий список аргументов для текущего
			окна. При этом Vim не переходит к редактированию
			нового файла.

:argg[lobal][!] [++opt] [+cmd] {список-аргументов}
			Использовать общий список аргументов для текущего
			окна. Определяется новый общий список аргументов,
			как по команде |:args_f|. Все окна, которые пользуются
			общим списком аргументов, будут использовать новый
			список. 

В Vim может существовать несколько списков аргументов. Список аргументов может
быть общим для нескольких окон; в этом случае, изменения в общем списке,
сделанные из одного окна, будут приводить к изменениям в списке и в других
окнах, использующих тот же самый список. 

При разделении окна новое окно наследует список аргументов из текущего окна.
Оба окна, и старое, и новое, используют общий список аргументов, до тех пор,
пока одно из окон не станет использовать другой список аргументов, по команде
|:arglocal| или |:argglobal|.


ИСПОЛЬЗОВАНИЕ СПИСКА АРГУМЕНТОВ

						                      *:argdo*
:argdo[!] {команда}	Выполнить указанную {команду} для каждого файла в
			списке аргументов.
			Это равносильно выполнению последовательности команд:
>
				:rewind
				:{cmd}
				:next
				:{cmd}
				etc.
<			
			Если Vim не может |оставить| текущий файл и не
			используется [!], то команда выполняться не будет.
			При возникновении ошибки в одном из файлов в списке
			аргументов, команда в следующих файлах в списке
			выполняться не будет. 
			После выполнения команды текущим становится последний
			файл в списке (или тот файл, в котором команда не была
			выполнена по причине ошибок).
			{команда} может состоять из нескольких команд,
			разделённых символом '|'. 
			{команда} не должна приводить к изменениям в списке
			аргументов. 
			Замечание: При выполнении команды отключаются
			обработка события Syntax в автокомандах при помощи
			добавления соответствующего значения к списку в опции
			'eventignore'. Это позволяет значительно ускорить
			редактирование каждого файла.
			{Vi не имеет такой возможности}
			{доступно только в том случае, если Vim скомпилирован
			с особенностью |+listcmds|}
			См. также |:windo| и |:bufdo|.

Пример: >

	:args *.c
	:argdo set ff=unix | update

Это позволяет установить значение опции 'fileformat' равным "unix" и записать
изменения для каждого файла с расширением *.c.

Пример: >
>
	:args *.[ch]
	:argdo %s/\<my_foo\>/My_Foo/ge | update

Изменяет слово "my_foo" на "My_Foo" во всех файлах *.c и *.h. Флаг "e" в
команде ":substitute" используется для предотвращения ошибок в тех файлах, где
не используется "my_foo". Команда "update" записывает файл, если в него были
внесены изменения.

==============================================================================
                                                                      *запись*
6. Запись		                *writing* *save-file* *сохранить-файл*

Замечание: запись файла возможна только при включённой опции 'write'.

							         *:w* *:write*
			                           *E502* *E503* *E504* *E505* 
				                          *E512* *E514* *E667*
:w[rite]		Записать весь буфер в текущий файл. Это наиболее часто
			используемый способ сохранения изменений. Команда не
			будет выполнена, если включена опция 'readonly' или
			если файл не может быть записан по каким-либо другим
			причинам.

:w[rite]!		То же, что и ":write", но работает даже в тех случаях,
			когда включена опция 'readonly' или если файл не мог
			быть записан по каким-либо другим причинам. 
			Замечание: эта команда может изменить существующие
			права на доступ к файлу, а также нарушить
			(символические) ссылки. Чтобы этого избежать, добавьте
			в значение опции 'cpoptions' флаг 'W'.

:[диапазон]w[rite][!]	Записать в текущий файл указанный диапазон строк. Эта
			команда употребляется довольно редко, поскольку в
			файле будут сохранены не все строки, которые находятся
			в буфере. 

							     *:w_f* *:write_f*
:[диапазон]w[rite] {файл}	
			Записать указанный диапазон строк в {файл}. Команда
			выполняется только в том случае, если {файл} не
			существует и опция 'writeany' выключена. 

							                 *:w!*
:[диапазон]w[rite]! {файл}	
			Записать указанный диапазон строк в {файл}.
			Существующий файл будет перезаписан. 

					              *:w_a* *:write_a* *E494*
:[диапазон]w[rite][!] >>	
			Добавить указанный диапазон строк к текущему файлу. 

:[диапазон]w[rite][!] >> {файл}
			Добавить указанный диапазон строк в {файл}. '!'
			позволяет осуществить запись даже в том случае, если
			{файл} не существует. 

							     *:w_c* *:write_c*
:[диапазон]w[rite] !{команда}	
		 	Выполнить {команду} с указанным диапазоном строк в
			качестве стандартного ввода (обратите внимание на
			пробел перед символом '!'). {команда} выполняется
			точно так же, как и команда "!:{команда}", все '!'
			заменяются предыдущей командой |:!|.

По умолчанию в качестве [диапазон]а для команды ":w" принимается весь буфер
(1,$). Если в команде ":w" указано имя файла, то он становится соседним
файлом. Это можно использовать, например, в тех случаях, когда файл не может
быть записан с тем же именем и вы хотите попробовать позднее ещё раз при
помощи команды ":w #". Такое поведение можно отключить, убрав флаг 'A' из
значения опции 'cpoptions'.

							      *:sav* *:saveas*
:sav[eas][!] {файл}	Сохранить содержимое текущего буфера в {файл}. {файл}
			становится именем файла для текущего буфера.
			Предыдущее имя используется в качестве соседнего
			файла. Для перезаписи существующего файла требуется
			добавление [!].
			{Vi не имеет такой возможности}

							       *:up* *:update*
:[диапазон]up[date][!] [>>] [файл]
			Работает так же, как и ":write", но запись
			производится только в том случае, если в буфере есть
			свежие изменения.
			{Vi не имеет такой возможности}


ЗАПИСЬ НЕСКОЛЬКИХ БУФЕРОВ		         *buffer-write* *буфер-запись*

							         *:wa* *:wall*
:wa[ll]			Записать все буферы, в которых есть изменения. Буферы
			без имени или буферы, открытые только для чтения,
			записаны не будут. 
			{Vi не имеет такой возможности}

:wa[ll]!		Записать все буферы, в которых есть изменения, в том
			числе открытые только для чтения. Буферы без имени
			записаны не будут.
			{Vi не имеет такой возможности}

Vim предупредит вас при попытке перезаписи файла, который был изменён в
какой-либо другой программе. См. |отметка_времени_изменения|.

                                                             *резервная_копия*
			    *backup* *E207* *E506* *E507* *E508* *E509* *E510*
При записи существующего файла (но не при добавлении к файлу), производится
резервное копирование файла если включена опция 'backup', 'writebackup' или
'patchmode'. Файл копируется или переименовывается (см. 'backupcopy'). Если
включена опция 'writebackup', но выключена опция 'writebackup', то после
успешной записи резервная копия файла удаляется. При включённой опции
'patchmode' резервная копия может быть переименована. 

			        *backup-table* *резервное_копирование-таблица*
'backup' 'writebackup'	действие	~

   off	     off	резервное копирование не производится
   off	     on		производится резервное копирование текущего файла, но
			копия удаляется после успешной записи (по умолчанию)
   on	     off	удаляется старая резервная копия, производится
			резервное копирование текущего файла
   on	     on		удаляется старая резервная копия, производится
			резервное копирование текущего файла

Если шаблон, указанный в опции 'backupskip' соответствует тому или иному имени
файла, то резервное копирование файла не производится. Значения опций 'backup'
и 'writebackup' в этом случае игнорируются. 

При включённой опции 'backup' старая резервная копия (с тем же именем, что и
новая резервная копия) будет удалена. Если опция 'backup' выключена, но
включена опция 'writebackup', то существующая резервная копия файла не будет
удалена. В этом случае резервная копия при записи файла будет иметь другое
имя.

На некоторых файловых системах возможна потеря как резервной копии, так и
данных в свежезаписанном файле, при аварийном завершении работы. В этом случае
попробуйте восстановить информацию из своп-файла, поскольку своп-файл
записывается на диск и может содержать необходимую информацию для
восстановления файла. |:recover|

Резервная копия файла помещается в одном из каталогов, указанных в значении
опции 'backupdir'. По умолчанию резервная копия делается в том же каталоге,
что и сам файл.

От значения опции 'backupcopy' зависит, будет ли резервная копия новым файлом,
который является копией оригинального файла, или же резервная копия
представляет собой переименованный оригинальный файл. Смотрите справку по этой
опции для получения дополнительной информации о процессе резервного
копирования. 

Если резервная копия файла не может быть создана, то запись не производится.
Если вы, тем не менее, хотите записать файл без резервного копирования, то
добавьте '!' к команде.

				       *write-readonly* *запись-только_чтение*
Если в значении опции 'cpoptions' содержится 'W', то Vim откажется сохранять
файл, открытый только для чтения. Если флаг 'W' не указан, то записать
открытый только для чтения файл можно по команде ":w!", если это позволяет
система (каталог, в котором находится файл должен позволять пользователю
запись, а также система должна позволять изменять права на доступ к файлу для
данного пользователя). 

					       *write-fail* *запись-неудачная*
Если запись нового файла не увенчалась успехом, вам необходимо проследить,
чтобы не потерять изменения И оригинал файла. Если резервное копирование файла
не производится и запись нового файла не удалась, то у вас уже нет
оригинального файла на диске! НЕ ВЫХОДИТЕ ИЗ VIM ДО ТЕХ ПОР, ПОКА НЕ СОХРАНИТЕ
ФАЙЛ! Если есть резервная копия, то постарайтесь восстановить оригинальный
файл из резервной копии. В этом случае, если вы выйдете из Vim без сохранения
изменений, то оригинал будет на месте. Если вам не удалось восстановить
оригинал файла из резервной копии, то Vim выдаст сообщение о том, что вы
потеряли оригинал файла.

					*DOS-format-write* *DOS-формат-запись*
Если значение опции 'fileformat' равно "dos", то для переноса строк <EOL>
используется пара символов <CR><NL>. Это значение устанавливается по умолчанию
на MS-DOS, Win32 и OS/2. На других системах будет показано сообщение "[формат
dos]", чтобы напомнить вам о том, что в файле используется необычная
комбинация символов для <EOL>.

				      *Unix-format-write* *Unix-формат-запись*
Если значение опции 'fileformat' равно "unix", то для переноса строк <EOL>
используется символ <NL>. На MS-DOS, Win32 и OS/2 будет показано сообщение
"[формат unix]".

				        *Mac-format-write* *Mac-формат-запись*
Если значение опции 'fileformat' равно "mac", то для переноса строк <EOL>
используется <CR>. На всех системах, кроме Macintosh, будет показано сообщение
"[формат mac]".

См. также раздел |файл-форматы| и справку по опциям 'fileformat' и
'fileformats'.

						                         *ACL*
ACL это Access Control List, "список для управления доступом". ACL
представляет собой продвинутый механизм для управления правами на доступ к
файлу в современных системах MS-Windows и Unix, на файловых системах, которые
поддерживают такую возможность. 
   При записи файла Vim пытается сохранить информацию ACL. Резервная копия
наследует информацию ACL от оригинального файла.
   Информация ACL также используется для проверки прав на запись при открытии
файла. 

	    *read-only-share* *разделяемый_ресурс_с_правами_только_для_чтения*
   При совместном использовании ресурса в сети в MS-Windows, он может быть
открыт только для чтения. Это приводит к тому, что даже если атрибуты файла
и установки ACL на ресурсах NT позволяют осуществлять запись файла, тем не
менее файл будет открыт только для чтения. На платформе Win32 Vim корректно
определяет файлы на таких ресурсах и отмечает их как открытые только для
чтения. Такие файлы не могут быть записаны при помощи команды |:write|.

					    *write-device* *запись-устройство*
Если имя файла указывает на устройство, то Vim не делает резервной копии файла
(это было бы невозможно). Вам также потребуется использовать "!", поскольку
устройство уже существует. Пример для Unix: >

	:w! /dev/lpt0

и для MS-DOS или MS-Windows: >
>
	:w! lpt0

На Unix устройство определяется, если имя не относится к обычному файлу или
каталогу. Vim также воспринимает как устройство fifo или именную трубу. На
MS-DOS или MS-Windows устройство определяется по имени:

	AUX
	CON
	CLOCK$
	NUL
	PRN
	COMn	n=1,2,3... и т.д.
	LPTn	n=1,2,3... и т.д.

Имена могут быть набраны прописными или строчными буквами. 

==============================================================================
7. Запись и выход из программы			 *write-quit* *запись_и_выход*

							          *:q* *:quit*
:q[uit]			Закрыть текущее окно. Если это единственное открытое
			окно, то выйти из Vim. Команда не выполняется, если в
			текущем буфере имеются изменения, которые Vim не может
			|оставить|, а также в том случае, если были
			отредактированы не все файлы в списке аргументов. 

:conf[irm] q[uit]	Выйти, но с выдачей запроса при наличии несохранённых
			изменений или неотредактированных файлов в списке
			аргументов. Подробнее см. |:confirm| и 'confirm'.
			{Vi не имеет такой возможности}

:q[uit]!		Выйти без сохранения изменений в видимых буферах.
			Команда не выполняется, если имеются изменения в
			скрытых буферах. Для выхода при любой ситуации
			используйте ":qall!".

:cq[uit]		Выйти без записи изменений с возвратом кода ошибки.
			Подробнее см. |:cq|. Используется в режиме быстрого
			исправления Manx (см. |быстрое_исправление|).
			{Vi не имеет такой возможности}

							                 *:wq*
:wq			Записать текущий файл и выйти. Запись не происходит,
			если файл был открыт только для чтения, либо буфер не
			имеет имени. Выход из редактора не происходит в том
			случае, если в списке аргументов имеются
			неотредактированные файлы.

:wq!			Записать текущий файл и выйти. Запись не происходит,
			если текущий буфер не имеет имени.

:wq {файл}		Записать изменения в {файл} и выйти из редактора.
			Выход не происходит в том случае, если были
			отредактированы не все файлы в списке аргументов. 

:wq! {файл}		Записать изменения в {файл} и выйти.

:[диапазон]wq[!] [файл]	То же, что и выше, но записываются только строки,
			указанные в [диапазоне].

								   *:x* *:xit*
:[диапазон]x[it][!] [файл]
			То же, что и ":wq", но запись происходит только тогда,
			когда в буфере действительно имеются изменения.
			Если включена опция 'hidden' и имеются другие окна, то
			после записи файла текущий буфер становится скрытым. 

							        *:exi* *:exit*
:[диапазон]exi[t][!] [файл]
			То же, что и :xit.

							                  *ZZ*
ZZ			Записать текущий файл, если имеются несохранённые
			изменения, и выйти (то же, что и ":x"). (Замечание:
			если для текущего файла открыто несколько окон, то
			файл сохраняется если он был изменён и окно закрыто).

							                  *ZQ*
ZQ			Выйти без проверки несохранённых изменений (то же, что
                        и ":q!").
			{Vi не имеет такой возможности}


НЕСКОЛЬКО ОКОН И БУФЕРОВ                            *window-exit* *окно-выход*

							         *:qa* *:qall*
:qa[ll]		Выйти из Vim, если все изменения во всех буферах были
		сохранены. (Для перехода в следующий буфер с изменениями
		используйте команду ":bmod"). Если включена опция
		'autowriteall', то все изменения во всех буферах будут
		автоматически сохранены, как по команде |:wqall|.
		{Vi не имеет такой возможности}

:conf[irm] qa[ll]
		Выйти из Vim, с выдачей запроса, если имеются буферы с
		несохранёнными изменениями. См. |:confirm|.
		{Vi не имеет такой возможности}

:qa[ll]!	Выйти из Vim. Все изменения в буферах будут потеряны.
		{Vi не имеет такой возможности}

							   *:quita* *:quitall*
:quita[ll][!]	То же, что и ":qall". 
		{Vi не имеет такой возможности}

:wqa[ll]					 *:wqa* *:wqall* *:xa* *:xall*
:xa[ll]		Записать все изменения во всех буферах и выйти из Vim. Выход
		из Vim не состоится, если имеются изменения в буферах без
		имени файла или открытых только для чтения, или буферы,
		которые не могут быть сохранены по каким-либо другим причинам. 
		{Vi не имеет такой возможности}

:conf[irm] wqa[ll]
:conf[irm] xa[ll]
		Записать все изменения во всех буферах и выйти из Vim. Если
		какой-либо буфер открыт только для чтения или не может быть
		записан по какой-либо другой причине, то выдаётся запрос. См.
		|:confirm|.
		{Vi не имеет такой возможности}

:wqa[ll]!
:xa[ll]!	Записать все изменения во всех буферах, включая открытые
		только для чтения, и выйти из Vim. Выход не произойдёт, если
		имеются изменения в буферах без имени файла или если буфер не
		может быть записан по каким-либо другим причинам.
		{Vi не имеет такой возможности}

==============================================================================
			                                         *edit-binary*
8. Редактирование бинарных файлов              *редактирование-бинарные_файлы*

Хотя Vim это редактор текстовых файлов, в нём также возможно редактирование
бинарных файлов. Ключ |-b| в строке запуска Vim позволяет открывать и
записывать файлы в бинарном режиме и устанавливает значения для ряда других
опций, необходимые для редактирования бинарных файлов (включается опция
'binary', значение опции 'tetwidth' устанавливается равным 0, выключаются
опции 'modeline' и 'expandtab'). Тот же эффект достигается включением опции
'binary'. Не забудьте сделать это до чтения бинарного файла.

При редактировании бинарных файлов следует помнить о нескольких вещах:

- При редактировании исполняемых файлов не должно изменяться число символов в
  файле. Для изменения текста следует пользоваться только командами "R" и "r"
  и не удалять символы.
- Значение опции 'textwidth' должно быть равно 0. В противном случае строки
  могут быть перенесены в неподходящем месте, со вставкой символа переноса
  строки в текст. 
- Если в файле встречается мало символов переноса строки <EOL>, то строка
  может оказаться слишком длинной. Чтобы редактировать строки, которые не
  умещаются на экране, можно отключить опцию 'wrap' и использовать
  горизонтальную прокрутку. Вы не сможете редактировать слишком длинные строки
  (около 32767 символов на Amiga, гораздо больше на 32-битных системах;
  подробнее см. |ограничения|) -- в этом случае при чтении файла такая строка
  будет разделена на две. При чтении файла также возможно появление ошибки о
  нехватке памяти.
- Убедитесь, что опция 'binary' включена ПЕРЕД чтением файла. В противном
  случае Vim будет считать, что строки переносятся как при помощи пары
  символов <CR><NL>, так и с помощью символа <NL> и при записи файла все
  одиночные <NL> будут заменяться на <CR><NL>.
- Символы <Nul> отображаются на экране как ^@. Ввести символ <Nul> с
  клавиатуры можно при помощи команды "CTRL-V CTRL-@" или "CTRL-V 000".
  {Vi не может работать с символом <Nul>}
- Чтобы вставить символ <NL> в файл, перенесите строку. При записи буфера в
  файл все переносы строки <EOL> будут сохранены как символ <NL>.
- Если в конце файла нет переноса строки, то Vim обычно добавляет его при
  записи файла. Избежать этого позволяет включённая опция 'binary'. Если вы
  хотите добавить символ <EOL> в конец файла, то включите опцию 'endofline'.
  Вы также можете проверить значение этой опции, чтобы выяснить, имеется ли в
  конце файла символ <EOL> (в тексте этого не видно).

==============================================================================
9. Шифрование текста                                 *encryption* *шифрование*

Vim может выполнять шифрование текста при записи и расшифровку при чтении.
Зашифрованный текст можно прочитать только с правильным паролем. 

Замечание: своп-файл и текст, хранящийся в памяти не шифруются. Системный
администратор, таким образом, сможет увидеть текст во время его
редактирования. При выполнении внешней программы-фильтра с помощью команды
":!filter" или по команде ":w !command" текст также не шифруется, в результате
чего он может стать известным посторонним. 

ПРЕДУПРЕЖДЕНИЕ: Если при вводе пароля вы допустите ошибку и затем сохраните
файл, то текст может быть полностью потерян для последующего чтения после
выхода из редактора. 

Лучше всего выполнять шифрование с помощью команды ":X", которая выдаёт запрос
на ввод пароля. Этот пароль используется при последующей записи файла. При
последующем открытии этого файла Vim выдаст запрос на ввод пароля. При вводе
правильного пароля текст снова будет читаемым, в противном случае содержание
текста будет невозможно разобрать. 

							                  *:X*
:X	Вывести запрос на ввод пароля. Введённый пароль не отображается на
	экране, чтобы его нельзя было подглядеть при наборе. Введённый пароль
	хранится в значении опции 'key' и используется для шифрования файла
	при записи. Сам файл остаётся неизменённым до момента записи. См.
	также |-x|. 

При записи файла используется значение опции 'key'. Если значение этой опции
не пустое, то оно используется в качестве пароля для шифрования файла. Чтобы
Vim мог распознавать зашифрованные файлы, в начале файла размещается служебная
информация. 

Для отключения шифрования нужно установить пустое значение опции 'key': >

	:set key=

При чтении зашифрованного файла используется значение опции 'key'. Если оно не
пустое, то это значение используется в качестве пароля, в противном случае
выводится приглашение ввести пароль. Если пароль не введён, то дешифрация
файла не производится.

Если вы хотите прочитать файл, зашифрованный с другим паролем, то сбросьте
значение опции 'key' перед чтением этого файла, чтобы Vim выдал запрос на ввод
пароля. Не используйте для установки пароля команду ":set", поскольку в этом
случае кто-нибудь может подсмотреть введённый пароль.

Поскольку значение опции 'key' должно храниться в тайне, то его нельзя
просмотреть средствами Vim. Эту опцию также не стоит настраивать в файле
vimrc.

Зашифрованный файл может быть опознан программой "file", если добавить в файл
magic ("/etc/magic", "/usr/share/misc/magic" или другое место, где в вашей
системе хранится этот файл) строку следующего содержания: >

     0	string	VimCrypt~	Vim encrypted file

Замечания:

- Шифрование невозможно при выполнении преобразования с помощью опции
  'charconvert'.
- Копируемый и удаляемый текст попадает в цифровые регистры. Содержимое этих
  регистров может сохраняться в файле .viminfo и может быть прочитано
  посторонними. В целях безопасности измените также значение опции 'viminfo'.
- Если вы отойдёте от компьютера, то посторонний может воспользоваться этим
  моментом для ввода каких-либо команд. При этом пароль нельзя подсмотреть.
  Замечание переводчика: (посторонний в этом случае может изменить пароль,
  которым вы пользуетесь).
- Если при наборе пароля вы допустите ошибку, то можете потерять текст в файле
  для последующего прочтения!
- При вводе пароля при помощи команды ":set key=пароль" он может попасть в
  историю команд и может быть сохранён в истории командной строки. 
- 100%-ной безопасности не существует. Проверок криптостойкости шифрования в
  Vim не проводилось. 
- Используемый алгоритм может быть сломан. Пароль из 4-х символов ломается
  примерно за час, пароль из 6-ти символов -- примерно за день (на Pentium
  133). Для взлома требуется знание какого-нибудь фрагмента текста. Эксперт
  может взломать файл, зашифрованный в Vim с любым паролем. После взлома
  пароля возможен доступ к другим файлам, зашифрованным с тем же паролем. 
- Аналогичный алгоритм шифрования используется в Pkzip и на него не
  распространяются экспортные ограничения правительства США. Алгоритм подробно
  описывается в файле APPNOTE.TXT в пакете Pkzip. 
- Vim сделан в Нидерландах, поэтому код для шифрования не экспортируется из
  США. 

==============================================================================
                                      *timestamps* *отметки_времени_изменения*
10. Отметка времени изменения файла   *timestamp*  *отметка_времени_изменения*

В начале редактирования файла Vim запоминает время последнего изменения файла.
Она используется для того, чтобы предупредить появление двух различных версий
файла. 

После выполнения команды оболочки (|:!cmd| |прервать_работу| |:read| |K|) для
всех буферов в окне сравниваются отметки времени изменения. При работе в
графическом интерфейсе это также происходит после того, как окно Vim вновь
становится активной задачей. Если будут обнаружены изменённые файлы, то будет
выдано предупреждение, или будут выполнены автокоманды события
|FileChangedShell|.

							         *E321* *E462*
Если вы хотите автоматически выполнять загрузку файла в тех случаях, когда он
был изменён вне Vim, то включите опцию 'autoread'. Это позволит заново читать
файл, если он изменяется вне редактора, но не при записи файла из Vim. 

Замечание: если определена автокоманда по событию FileChangedShell, то
предупреждение выдаваться не будет, поскольку с этой ситуацией должна
разобраться сама автокоманда.

При изменении каталога (например, если в окне открыт
|проводник_по_файловой_системе|) предупреждение также не выдаётся.  Однако,
если вы начинаете редактировать новый файл, а в процессе редактирования вне
Vim будет создан каталог с таким же именем, то будет выдано предупреждение.

Если Vim обнаруживает, что отметка времени изменения файла изменилась, а в
содержимом буфера нет несохранённых изменений, то Vim проверяет, является ли
содержимое буфера и содержимое файла одинаковым. Это делается с помощью чтения
файла в скрытый буфер, который тут же удаляется, и сравнения текста с
соответствующим буфером. Если текст совпадает, то предупреждение не выдаётся.

Чтобы узнавать об изменениях файла вне Vim в процессе редактирования, можно
также использовать следующую команду:

							*:checkt* *:checktime*
:checkt[ime]		Проверяет изменения в буферах, сделанные вне Vim.
			Если в результате проверки выясняется, что у вас две
			разные версии файла, то выдаётся предупреждение. 
			Если эта команда вызывается из автокоманды, команды
			":global" или не вводится с клавиатуры, то проверка
			как таковая откладывается до того момента, когда
			последствия выполнения команды (перезагрузка файла) не
			принесут вреда.
			При этом сравнивается содержимое буфера и связанного с
			ним файла на диске. Vim предпринимает необходимые
			действия в тех случаях, когда файл на диске и в буфере
			не совпадают. Если включена опция 'autoread' и в
			буфере нет несохранённых изменений, то файл будет
			прочитан заново. В противном случае вам будет
			предложено перезагрузить файл вручную. Если файл был
			удалён вне Vim, то будет выдано сообщение об ошибке. 
			Предупреждение выдаётся также в том случае, если файл
			не существовал в момент начала редактирования, но был
			создан вне Vim в процессе редактирования.
			После проверки отметки времени изменения файла она
			будет установлена в новое значение и больше
			предупреждений не выдаётся.

:[N]checkt[ime] {имя-файла}
:[N]checkt[ime] [N]
			Проверить отметку времени изменения файла в указанном
			буфере. Необходимый буфер может быть определён с
			помощью имени файла, номера буфера или по шаблону.


Отметка о времени изменения файла проверяется перед записью файла. Если она
была изменена, то Vim выдаст предупреждение и запрос на продолжение записи:

	ПРЕДУПРЕЖДЕНИЕ: Файл был изменён с момента чтения!!!
	Серьёзно хотите записать его (y/n)?

Если вы нажмёте 'y', то Vim продолжит запись файла. Если вы нажмёте 'n', то
запись будет прервана. При выполнении команды ":wq" или "ZZ" работа Vim не
будет завершена, чтобы у вас была возможность записать все несохранённые
изменения. 

Обычно это сообщение выдаётся в тех случаях, когда кто-то записал файл во
время редактирования в Vim. Это может быть посторонний человек, и вы возможно
захотите проверить, следует ли объединить изменения сделанные другим человеком
с вашими собственными. Для этого запишите файл под другим именем и проверьте
различия (с этой целью можно пользоваться программой "diff").

Если вы сами изменили файл при помощи другой программы, то вы, скорее всего,
уже знаете, какую именно версию файла хотите сохранить. 

==============================================================================
vim:tw=78:ts=8:ft=help:norl:
